<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MattarLeister 1.0 ‚Äî Alta Performance para Concursos</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#f5f6fb; --card:#ffffff; --text:#1f2937; --muted:#6b7280; --border:#e5e7eb;
    --shadow: 0 10px 25px rgba(17,24,39,.06); --radius:16px; --pad:16px;
    --blue:#dbeafe; --green:#dcfce7; --pink:#fce7f3; --lav:#ede9fe; --yellow:#fef9c3;
    --red:#fee2e2;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Arial,sans-serif;background:var(--bg);color:var(--text);}
  header{position:sticky;top:0;z-index:10;backdrop-filter: blur(10px);background: rgba(245,246,251,.85);border-bottom:1px solid var(--border);}
  .topbar{max-width:1100px;margin:0 auto;padding:14px 16px;display:flex;gap:12px;align-items:center;justify-content:space-between;}
  .brand{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.2px}
  .dot{width:12px;height:12px;border-radius:999px;background:linear-gradient(135deg,#a7f3d0,#bfdbfe,#fbcfe8);box-shadow:0 6px 14px rgba(0,0,0,.12);}
  nav{display:flex;gap:8px;flex-wrap:wrap}
  .tab{border:1px solid var(--border);background:rgba(255,255,255,.7);padding:10px 12px;border-radius:999px;cursor:pointer;color:var(--muted);font-weight:700;transition:.15s;}
  .tab.active{color:var(--text);background:#fff;box-shadow:0 6px 16px rgba(0,0,0,.06);}
  main{max-width:1100px;margin:0 auto;padding:18px 16px 40px;}
  .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:14px;}
  @media (max-width: 960px){.grid{grid-template-columns:1fr;}}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:var(--pad);}
  h2{margin:0 0 10px 0;font-size:18px;}
  h3{margin:0 0 10px 0;font-size:15px;color:var(--muted);font-weight:800;}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
  @media (max-width: 640px){.row{grid-template-columns:1fr;}}
  label{font-size:12px;color:var(--muted);font-weight:800;display:block;margin:2px 0 6px;}
  input,select,textarea{width:100%;border:1px solid var(--border);border-radius:12px;padding:10px 12px;background:#fff;outline:none;font-size:14px;}
  textarea{min-height:88px;resize:vertical;}
  .btn{border:1px solid var(--border);background:#fff;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800;transition:.15s;}
  .btn.primary{border-color:transparent;background:linear-gradient(135deg,#dbeafe,#ede9fe);}
  .btn.danger{background:linear-gradient(135deg,var(--red),#fce7f3);border-color:transparent;}
  .btnbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:#fff;color:var(--muted);font-weight:800;font-size:12px;}
  .kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;}
  @media (max-width: 860px){.kpis{grid-template-columns:repeat(2,1fr);} }
  .kpi{border-radius:14px;padding:12px;border:1px solid var(--border);background:#fff;}
  .kpi .n{font-size:22px;font-weight:900;line-height:1.1;}
  .kpi .t{font-size:12px;color:var(--muted);font-weight:900;margin-top:6px;}
  .kpi.blue{background:var(--blue)} .kpi.green{background:var(--green)} .kpi.pink{background:var(--pink)} .kpi.lav{background:var(--lav)} .kpi.yellow{background:var(--yellow)}
  table{width:100%;border-collapse:separate;border-spacing:0;overflow:hidden;border-radius:14px;border:1px solid var(--border);}
  th,td{padding:10px 10px;border-bottom:1px solid var(--border);vertical-align:top;font-size:13px;}
  th{background:#fafafa;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.04em;}
  tr:last-child td{border-bottom:none;}
  .muted{color:var(--muted)} .tiny{font-size:12px;}
  .actions{display:flex;gap:8px;flex-wrap:wrap;}
  .badge{display:inline-flex;align-items:center;padding:4px 8px;border-radius:999px;font-size:11px;font-weight:900;border:1px solid var(--border);background:#fff;}
  .badge.overdue{background:var(--pink)} .badge.today{background:var(--yellow)} .badge.soon{background:var(--blue)}
  .section-title{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;}
  .hr{height:1px;background:var(--border);margin:14px 0;}
  .note{font-size:12px;color:var(--muted);line-height:1.35;}
  .toast{position:fixed;right:16px;bottom:16px;background:#111827;color:#fff;padding:10px 12px;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,.22);opacity:0;transform:translateY(8px);transition:.18s;max-width:min(520px, calc(100vw - 32px));font-size:13px;}
  .toast.show{opacity:1;transform:translateY(0);}

  details{border:1px solid var(--border); border-radius:14px; background:#fff; padding:10px 12px; box-shadow:none;}
  details + details{margin-top:10px;}
  summary{cursor:pointer; font-weight:900; color:var(--text); list-style:none; display:flex; align-items:center; justify-content:space-between;}
  summary::-webkit-details-marker{display:none;}
  .chev{font-size:12px; color:var(--muted);}
  .compact .actions .btn{padding:8px 10px; border-radius:10px;}
  .compact table th, .compact table td{padding:9px 9px;}


  .chips{display:flex;gap:8px;flex-wrap:wrap;}
  .chip{border:1px solid var(--border);background:#fff;padding:8px 10px;border-radius:999px;cursor:pointer;font-weight:900;font-size:12px;color:var(--muted);transition:.12s;}
  .chip:hover{transform:translateY(-1px);box-shadow:0 10px 18px rgba(0,0,0,.06);}
  .seg{display:flex;gap:8px;flex-wrap:wrap;}
  .seg .btn{padding:8px 10px;border-radius:999px;}
  .statgrid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;}
  @media (max-width: 960px){.statgrid{grid-template-columns:1fr;}}
  .statcard{border:1px solid var(--border);border-radius:14px;padding:12px;background:#fff;}
  .statcard .h{font-weight:900;color:var(--muted);font-size:12px;text-transform:uppercase;letter-spacing:.04em;}
  .statcard .v{font-weight:900;font-size:18px;margin-top:6px;}
  .bar{height:10px;border-radius:999px;border:1px solid var(--border);background:#fafafa;overflow:hidden;}
  .bar > div{height:100%;background:linear-gradient(135deg,#dbeafe,#ede9fe);}


  .fatal{
    position:sticky; top:0; z-index:9999;
    margin:12px auto 0;
    max-width:1100px;
    border:1px solid rgba(239,68,68,.35);
    background:rgba(254,242,242,.9);
    color:#7f1d1d;
    border-radius:14px;
    padding:12px 14px;
    box-shadow:0 10px 24px rgba(0,0,0,.08);
    backdrop-filter: blur(6px);
    font-weight:800;
  }
  .fatal .tiny{font-weight:700;color:#991b1b;margin-top:6px;}
  .fatal code{
    display:block;
    white-space:pre-wrap;
    background:rgba(255,255,255,.75);
    border:1px solid rgba(239,68,68,.25);
    padding:10px;
    border-radius:12px;
    margin-top:10px;
    font-weight:700;
    color:#7f1d1d;
  }
  .fatal .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
  .fatal .btn{border-color:rgba(239,68,68,.35);}



  .cognitive-grid{display:grid;grid-template-columns:1fr 1fr;gap:24px;}
  @media (max-width: 960px){.cognitive-grid{grid-template-columns:1fr;}}
  .status-excelente{border-left:5px solid #2ecc71;}
  .status-estavel{border-left:5px solid #3498db;}
  .status-atencao{border-left:5px solid #f39c12;}
  .status-critico{border-left:5px solid #e74c3c;}

/* ===== Forced layout overrides ===== */
.mode-pc .shell{ max-width: 1180px; margin: 0 auto; }
.mode-phone .shell{ max-width: 520px; margin: 0 auto; padding: 10px; }
.mode-phone header .topbar{ flex-wrap: wrap; gap: 8px; }
.mode-phone .tabs{ overflow-x: auto; -webkit-overflow-scrolling: touch; }
.mode-phone .tabs .tab{ white-space: nowrap; }
.mode-phone .grid{ grid-template-columns: 1fr !important; }
.mode-phone .kpis{ grid-template-columns: 1fr 1fr !important; }
.mode-phone table{ display:block; width:100%; overflow-x:auto; }
.mode-phone .card{ border-radius: 18px; }


/* Switch (toggle) */
.switch{ position:relative; display:inline-block; width:52px; height:28px; }
.switch input{ opacity:0; width:0; height:0; }
.slider{ position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#d0d5dd; transition:.2s; border-radius:999px; }
.slider:before{ position:absolute; content:""; height:22px; width:22px; left:3px; bottom:3px; background:white; transition:.2s; border-radius:999px; box-shadow:0 1px 2px rgba(0,0,0,.15); }
.switch input:checked + .slider{ background:#7dd3fc; }
.switch input:checked + .slider:before{ transform:translateX(24px); }

/* Notebook layout refinements */
#app .card select, #app .card input, #app .card textarea{width:100%;box-sizing:border-box;}
</style>
</head>
<body>
  <div id="fatalBanner" class="fatal" style="display:none;"></div>

<header>
  <div class="topbar">
    <div class="brand"><span class="dot"></span> MattarLeister <span class="muted tiny">1.0 ‚Äî Alta Performance</span></div>
    <nav>
      <button class="tab active" data-tab="dashboard">Dashboard</button>
            <button class="tab" data-tab="cognitive">üß† Performance Cognitiva</button>
      <button class="tab" data-tab="schedule">Cronograma</button>
      <button class="tab" data-tab="matrix">Matriz</button>
<button class="tab" data-tab="sim">Simulados</button>
      <button class="tab" data-tab="compare">Comparativo</button>
            <button class="tab" data-tab="radar">Radar</button>
<button class="tab" data-tab="questions">Quest√µes</button>
            <button class="tab" data-tab="notebook">Caderno</button>
<button class="tab" data-tab="settings">Backup</button>
    </nav>
  </div>
</header>

<main>
  <div id="app"></div>
</main>

<div id="toast" class="toast"></div>

<script>

// ========= Multiusu√°rio (opcional) - v3.0.5 =========
// Default: 1 usu√°rio por m√°quina (sem prefixo)
// Se ativar, chaves do localStorage passam a ser prefixadas por userId.
const ML_MULTIUSER_FLAG = "ML_MULTIUSER_ENABLED";
function isMultiUser(){
  try{ return localStorage.getItem(ML_MULTIUSER_FLAG)==="1"; }catch(e){ return false; }
}
function ensureUserId(){
  try{
    const prof = (typeof loadProfile==="function") ? loadProfile() : null;
    let uid = (prof && (prof.userId||prof.uid)) ? (prof.userId||prof.uid) : "";
    if(!uid){
      uid = localStorage.getItem("ML_USER_ID") || "";
    }
    if(!uid){
      uid = "U" + Math.random().toString(36).slice(2,8) + Date.now().toString(36).slice(-4);
      localStorage.setItem("ML_USER_ID", uid);
    }
    return uid;
  }catch(e){ return "Udefault"; }
}
function mlPrefix(){
  try{
    if(!isMultiUser()) return "";
    return "MLU_" + ensureUserId() + "_";
  }catch(e){ return ""; }
}
function mlKey(k){ return mlPrefix() + k; }

function migrateToMultiUser(){
  // Copia chaves legadas -> chaves prefixadas (se ainda n√£o existirem)
  try{
    const uid = ensureUserId();
    const pref = "MLU_" + uid + "_";
    const keys = [
      "ML_PROFILE","ML_ACTIVE_EXAM","ML_STATE","ML_SNAPSHOTS",
    ];
    // Copia chaves exatas
    keys.forEach(base=>{
      const legacy = localStorage.getItem(base);
      if(legacy!=null && localStorage.getItem(pref+base)==null){
        localStorage.setItem(pref+base, legacy);
      }
    });
    // Copia padr√µes (Matriz / Plano do Dia / Disciplinas do Dia)
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if(!k) continue;
      if(k.startsWith("ML_MATRIX_") || k.startsWith("ML_MATRIXDAY_") || k.startsWith("ML_DAY_PLAN_") || k.startsWith("ML_DAY_DISCS_")){
        const v = localStorage.getItem(k);
        if(v!=null && localStorage.getItem(pref+k)==null){
          localStorage.setItem(pref+k, v);
        }
      }
    }
    try{ window.dispatchEvent(new CustomEvent("ML:MULTIUSER_MIGRATED",{detail:{userId:uid}})); }catch(e){}
  }catch(e){}
}
function mlGetPerfRange(){
  try{
    const v = localStorage.getItem(mlKey(PERF_RANGE_KEY));
    if(v==="7"||v==="30"||v==="all") return v;
  }catch(e){}
  return "all";
}
function mlSetPerfRange(v){
  try{
    localStorage.setItem(mlKey(PERF_RANGE_KEY), v);
  }catch(e){}
}

function mlFilterQuestionsByRange(questions, range){
  const r = range || "all";
  const q = Array.isArray(questions) ? questions : [];
  if(r==="all") return q;
  const days = r==="7" ? 7 : 30;
  const now = new Date();
  const cutoff = new Date(now.getTime() - days*24*60*60*1000);
  return q.filter(it=>{
    const t = it && it.createdAt ? new Date(it.createdAt) : null;
    return t && !isNaN(t) && t >= cutoff;
  });
}

// ====================================================
// ===== Build target =====
const FORCE_MODE = 'pc';
try{ document.documentElement.classList.add(FORCE_MODE==='phone'?'mode-phone':'mode-pc'); }catch(e){}

/* =========================
   CORE (Store + Storage)
========================= */

const STORAGE_KEY = "ML_STATE_V1";
const STORAGE_BACKUP_KEY = STORAGE_KEY + "_BACKUP";
const STORAGE_META_KEY = STORAGE_KEY + "_META";
const STATE_VERSION = "1.0";
const CORE_STABLE_VERSION = "1.0";
const SCHEMA_VERSION = 2; // core contract version
const DEBUG_KEY = "SAPE_DEBUG";
const AGGRO_KEY = "SAPE_AGGRO"; // 0.5..1.5
const WHY_DISC_KEY = "SAPE_WHY_DISC";

function uid(){
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}

function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function fmtDate(d){
  if(!d) return "-";
  const x = (d instanceof Date) ? d : new Date(d);
  if(Number.isNaN(x.getTime())) return "-";
  return x.toLocaleDateString("pt-BR");
}

function fmtDateTime(iso){
  try{
    const d = new Date(iso);
    if(!isFinite(d.getTime())) return ""+iso;
    return d.toLocaleString("pt-BR");
  }catch{ return ""+iso; }
}
function safeString(v){ return (typeof v === "string") ? v : (v == null ? "" : String(v)); }
function escapeHtml(str){
  const s = safeString(str);
  return s.replace(/[&<>"']/g, ch => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[ch]));
}

// Compat alias (alguns m√≥dulos usam escapeHTML)
const escapeHTML = escapeHtml;

function toast(msg){
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(()=> el.classList.remove("show"), 1800);
}

function sanitizeError(e){
  const x = e && typeof e === "object" ? e : {};
  return {
    id: safeString(x.id) || uid(),
    createdAt: x.createdAt ? new Date(x.createdAt).toISOString() : new Date().toISOString(),
    examId: safeString(x.examId) || getActiveExam(),
    disc: safeString(x.disc),
    topic: safeString(x.topic),
    bank: safeString(x.bank),
    cause: safeString(x.cause),
    notes: safeString(x.notes),
    mistakeType: safeString(x.mistakeType),
    nextReviewAt: x.nextReviewAt ? new Date(x.nextReviewAt).toISOString() : null,
    reviewHistory: Array.isArray(x.reviewHistory) ? x.reviewHistory.map(d => new Date(d).toISOString()) : []
  };
}

function sanitizeTrap(t){
  const x = t && typeof t === "object" ? t : {};
  return {
    id: safeString(x.id) || uid(),
    createdAt: x.createdAt ? new Date(x.createdAt).toISOString() : new Date().toISOString(),
    examId: safeString(x.examId) || getActiveExam(),
    disc: safeString(x.disc),
    topic: safeString(x.topic),
    bank: safeString(x.bank) || "AUTO",
    type: safeString(x.type) || "Amb√≠gua/dupla interpreta√ß√£o",
    text: safeString(x.text),
    fix: safeString(x.fix),
    danger: Number.isFinite(Number(x.danger)) ? Math.max(0, Math.min(100, Number(x.danger))) : 50,
    typical: Array.isArray(x.typical) ? x.typical.map(safeString).slice(0,8) : [],
    trainPlan: Array.isArray(x.trainPlan) ? x.trainPlan.map(safeString).slice(0,8) : []
  };
}

function sanitizeQuestion(q){
  const x = q && typeof q === "object" ? q : {};
  return {
    id: safeString(x.id) || uid(),
    createdAt: x.createdAt ? new Date(x.createdAt).toISOString() : new Date().toISOString(),
    examId: safeString(x.examId) || getActiveExam(),
    disc: safeString(x.disc),
    topic: safeString(x.topic),
    bank: safeString(x.bank),
    source: safeString(x.source),
    qtext: safeString(x.qtext),
    answerKey: safeString(x.answerKey),      // gabarito (opcional)
    userAnswer: safeString(x.userAnswer),    // resposta marcada (opcional)
    isCorrect: (typeof x.isCorrect === "boolean") ? x.isCorrect : null,
    difficulty: safeString(x.difficulty),    // f√°cil/m√©dia/dif√≠cil (opcional)
    timeMin: Number.isFinite(Number(x.timeMin)) ? Math.max(0, Number(x.timeMin)) : null,
    notes: safeString(x.notes),
    tags: Array.isArray(x.tags) ? x.tags.map(safeString).slice(0,10) : [],
    createdErrorId: safeString(x.createdErrorId),
    createdTrapId: safeString(x.createdTrapId),
    // MattarLeister (cognitivo)
    emotion: safeString(x.emotion),
    focus: Number.isFinite(Number(x.focus)) ? Math.max(1, Math.min(5, Number(x.focus))) : null,
    fatigue: Number.isFinite(Number(x.fatigue)) ? Math.max(1, Math.min(5, Number(x.fatigue))) : null,
    blockMode: safeString(x.blockMode),
    qIndexInBlock: Number.isFinite(Number(x.qIndexInBlock)) ? Math.max(1, Number(x.qIndexInBlock)) : null,
    mistakeType: safeString(x.mistakeType),

  };
}

function sanitizeState(raw){
  const s = raw && typeof raw === "object" ? raw : {};
  const errors = Array.isArray(s.errors) ? s.errors : [];
  const traps = Array.isArray(s.traps) ? s.traps : [];
  const questions = Array.isArray(s.questions) ? s.questions : [];
  const advSim = s.advSim && typeof s.advSim === "object" ? s.advSim : null;
  const notebook = (s.notebook && typeof s.notebook==="object") ? s.notebook : {};

  return {
  version: s.version || STATE_VERSION,
  schemaVersion: Number.isFinite(s.schemaVersion) ? s.schemaVersion : SCHEMA_VERSION,
  errors: errors.map(sanitizeError),
  traps: traps.map(sanitizeTrap),
  questions: questions.map(sanitizeQuestion),
  advSim: advSim,
  notebook: notebook,

  // MattarLeister state
  mlCore: (s.mlCore && typeof s.mlCore==="object") ? s.mlCore : {
    metaGlobalBase: 70,
    metaGlobalAtual: 70,
    decayLambda: 0.02,
    timeIdealSecByQuestion: 140
  },
  mlUsers: (s.mlUsers && typeof s.mlUsers==="object") ? s.mlUsers : { activeUserId: null, users: {} },
  mlEventLog: (s.mlEventLog && typeof s.mlEventLog==="object") ? s.mlEventLog : {},
  mlPerformance: (s.mlPerformance && typeof s.mlPerformance==="object") ? s.mlPerformance : {},
  mlAnalytics: (s.mlAnalytics && typeof s.mlAnalytics==="object") ? s.mlAnalytics : {},
  mlPlan: (s.mlPlan && typeof s.mlPlan==="object") ? s.mlPlan : {}
};
}

function migrate(raw){
  const s = sanitizeState(raw);

  // Ensure at least one user exists (7-users design). Default uses local profile name when available.
  const profile = (typeof loadProfile === "function") ? loadProfile() : null;
  const defaultName = (profile && profile.name) ? profile.name : "Usu√°rio 1";
  const usersObj = (s.mlUsers && s.mlUsers.users && typeof s.mlUsers.users==="object") ? { ...s.mlUsers.users } : {};
  let activeUserId = s.mlUsers && s.mlUsers.activeUserId ? String(s.mlUsers.activeUserId) : null;

  if(Object.keys(usersObj).length === 0){
    const id = "u1";
    usersObj[id] = {
      id,
      name: defaultName,
      cargo: (profile && profile.mainExamId) ? profile.mainExamId : getActiveExam(),
      createdAt: new Date().toISOString()
    };
    activeUserId = id;
  }else if(!activeUserId || !usersObj[activeUserId]){
    activeUserId = Object.keys(usersObj)[0];
  }

  const next = {
    ...s,
    version: STATE_VERSION,
    schemaVersion: SCHEMA_VERSION,
    mlUsers: { ...s.mlUsers, users: usersObj, activeUserId }
  };

  // Initialize analytics dirty flag for active user
  next.mlAnalytics[activeUserId] = next.mlAnalytics[activeUserId] || { dirty: true };

  
  // One-time migration: legacy state.errors (old Caderno de Erros) -> notebook[examId][disc][topic].errors
  next.migrations = (next.migrations && typeof next.migrations==="object") ? next.migrations : {};
  if(!next.migrations.errorsToNotebookDone){
    try{
      const legacy = Array.isArray(next.errors) ? next.errors : [];
      if(legacy.length){
        // clone notebook shallow
        const nb = (next.notebook && typeof next.notebook==="object") ? { ...next.notebook } : {};
        const seen = new Set();
        // build quick index of existing ids
        for(const exId of Object.keys(nb)){
          const ex = nb[exId] || {};
          for(const disc of Object.keys(ex)){
            const d = ex[disc] || {};
            for(const topic of Object.keys(d)){
              const ent = d[topic] || {};
              const arr = Array.isArray(ent.errors) ? ent.errors : [];
              for(const e of arr){ if(e && e.id) seen.add(String(e.id)); }
            }
          }
        }

        for(const e of legacy){
          const examId = e.examId || getActiveExam();
          const disc = e.disc || "Geral";
          const topic = e.topic || "Geral";
          const id = String(e.id || uid());
          if(seen.has(id)) continue;
          seen.add(id);

          const nowIso = new Date(e.createdAt || Date.now()).toISOString();
          const type = (e.mistakeType || "").trim() || "outro";
          const priority = "media";
          const prompt = (e.cause || "").trim() || (e.notes || "").trim() || "";
          const why = (e.cause || "").trim() || "";
          const fix = (e.notes || "").trim() || "";
          const tags = [];
          if(e.bank) tags.push(String(e.bank));
          if(e.mistakeType) tags.push(String(e.mistakeType));
          const nextReviewAt = e.nextReviewAt || null;

          const err = {
            id, type, priority, prompt, why, fix, tags,
            createdAt: nowIso,
            nextReviewAt: nextReviewAt ? new Date(nextReviewAt).toISOString() : null,
            reviewed: false
          };

          nb[examId] = nb[examId] || {};
          nb[examId][disc] = nb[examId][disc] || {};
          const curEntry = (nb[examId][disc][topic] && typeof nb[examId][disc][topic]==="object") ? { ...nb[examId][disc][topic] } : {};
          const curErrors = Array.isArray(curEntry.errors) ? [...curEntry.errors] : [];
          curErrors.push(err);
          nb[examId][disc][topic] = { ...curEntry, errors: curErrors, updatedAt: curEntry.updatedAt || nowIso };
        }

        next.notebook = nb;
      }
    }catch(err){ console.warn("Migration errors->notebook failed", err); }
    next.migrations.errorsToNotebookDone = true;
  }


  return next;
}





// Global error overlay (helps debugging on mobile)
(function(){
  function showErr(msg){
    try{
      let el = document.getElementById('fatalErr');
      if(!el){
        el = document.createElement('div');
        el.id = 'fatalErr';
        el.style.cssText = 'position:fixed;inset:0;background:rgba(255,255,255,0.96);z-index:9999;padding:16px;overflow:auto;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial';
        document.body.appendChild(el);
      }
      el.innerHTML = '<h2 style="margin:0 0 8px 0;">Erro no SAPE</h2>' +
        '<div style="color:#555;margin-bottom:10px;">Copie esta mensagem e me envie no chat:</div>' +
        '<pre style="white-space:pre-wrap;background:#f5f5f5;padding:12px;border-radius:12px;">' + (msg||'') + '</pre>' +
        '<button onclick="location.reload()" style="margin-top:12px;padding:10px 14px;border-radius:12px;border:1px solid #ddd;background:#fff;">Recarregar</button>';
    }catch{}
  }
  window.addEventListener('error', (e)=> showErr(e.message + '\n' + (e.filename||'') + ':' + (e.lineno||'') ));
  window.addEventListener('unhandledrejection', (e)=> showErr(String(e.reason||e)));
})();

/* =========================================================
   MODULE: multi-exam base
   ========================================================= */
const ACTIVE_EXAM_KEY = "ML_ACTIVE_EXAM";
const LEGACY_ACTIVE_EXAM_KEY = "SAPE_ACTIVE_EXAM";
;
const PERF_RANGE_KEY = "ML_PERF_RANGE";

// ===== Perfil (single-user) =====
const PROFILE_KEY = "SAPE_PROFILE";
function loadProfile(){
  try{
    const raw = localStorage.getItem(PROFILE_KEY);
    if(!raw) return null;
    const p = JSON.parse(raw);
    if(!p || typeof p !== "object") return null;
    return {
      name: safeString(p.name) || "Usu√°rio",
      mainExamId: safeString(p.mainExamId) || getActiveExam(),
      // Bloco 0 din√¢mico
      studyHoursPerDay: clampNum(p.studyHoursPerDay, 0.5, 16, 6),
      reviewLoadManual: safeString(p.reviewLoadManual) || "padrao", // leve|padrao|intensivo
      autoIntensiveEnabled: (typeof p.autoIntensiveEnabled === "boolean") ? p.autoIntensiveEnabled : true,
      examDateISO: safeString(p.examDateISO) || "",
      startDateISO: safeString(p.startDateISO) || "",
      createdAt: p.createdAt ? new Date(p.createdAt).toISOString() : new Date().toISOString(),
    };
  }catch{ return null; }
}
function saveProfile(p){
  try{
    const out = {
      name: safeString(p && p.name),
      mainExamId: safeString(p && p.mainExamId) || getActiveExam(),
      // novos par√¢metros (Bloco 0 din√¢mico)
      studyHoursPerDay: clampNum(p && p.studyHoursPerDay, 0.5, 16, 6),
      reviewLoadManual: safeString(p && p.reviewLoadManual) || "padrao", // leve|padrao|intensivo
      autoIntensiveEnabled: (p && typeof p.autoIntensiveEnabled === "boolean") ? p.autoIntensiveEnabled : true,
      examDateISO: safeString(p && p.examDateISO) || "",
      startDateISO: safeString(p && p.startDateISO) || "",
      createdAt: (p && p.createdAt) ? new Date(p.createdAt).toISOString() : new Date().toISOString(),
    };
    localStorage.setItem(PROFILE_KEY, JSON.stringify(out));
    return out;
  }catch{ return null; }
}
function clearProfile(){
  try{ localStorage.removeItem(PROFILE_KEY); }catch{}
}

const EXAMS = {
  TRT_AJ: {
    name: "TRT ‚Äì Analista Judici√°rio",
    // Pesos iniciais (ajust√°veis no painel "Comparativo").
    // Obs.: como TRTs variam por regi√£o e edital, este √© um ponto de partida pragm√°tico.
    weights: {
      "Direito do Trabalho": 1.60,
      "Processo do Trabalho": 1.55,
      "Direito Constitucional": 1.20,
      "Direito Administrativo": 1.10,
      "Direito Civil": 1.00,
      "Processo Civil": 1.00,
      "Direito Penal": 0.70,
      "Processo Penal": 0.70,
      "Portugu√™s": 0.90,
      "RLM": 0.70,
      "Inform√°tica": 0.60,
    }
  },
  TRE_AJ: {
    name: "TRE ‚Äì Analista Judici√°rio",
    weights: {
      "Direito Eleitoral": 1.70,
      "Direito Constitucional": 1.30,
      "Direito Administrativo": 1.10,
      "Direito Civil": 0.90,
      "Processo Civil": 0.90,
      "Portugu√™s": 0.90,
      "Inform√°tica": 0.60,
      "RLM": 0.60,
    }
  },
  INSS_ANALISTA: {
    name: "INSS ‚Äì Analista Seguridade",
    weights: {
      "Direito Previdenci√°rio": 1.70,
      "Portugu√™s": 1.00,
      "RLM": 0.80,
      "Inform√°tica": 0.70,
      "Direito Constitucional": 0.90,
      "Direito Administrativo": 0.90,
      "Administra√ß√£o P√∫blica": 0.70,
    }
  },
  INSS_TEC: {
    name: "INSS ‚Äì T√©cnico Seguridade",
    weights: {
      "Direito Previdenci√°rio": 1.70,
      "Portugu√™s": 1.00,
      "RLM": 0.90,
      "Inform√°tica": 0.80,
      "Direito Constitucional": 0.80,
      "Direito Administrativo": 0.80,
    }
  },
  RFB_AUDITOR: {
    name: "Receita Federal ‚Äì Auditor",
    weights: {
      "Portugu√™s": 0.90,
      "RLM": 0.90,
      "Contabilidade": 1.50,
      "Direito Tribut√°rio": 1.60,
      "Legisla√ß√£o Tribut√°ria": 1.50,
      "Direito Constitucional": 1.10,
      "Direito Administrativo": 1.00,
      "Com√©rcio Internacional": 0.80,
      "TI": 0.80,
    }
  },
  AFT: {
    name: "Auditor-Fiscal do Trabalho",
    weights: {
      "Direito do Trabalho": 1.60,
      "Processo do Trabalho": 1.30,
      "Seguran√ßa e Sa√∫de no Trabalho": 1.20,
      "Legisla√ß√£o do Trabalho": 1.20,
      "Direito Constitucional": 1.00,
      "Direito Administrativo": 1.00,
      "Portugu√™s": 0.80,
      "RLM": 0.70,
      "Economia": 0.70,
    }
  },
  PCPR_AGENTE: {
    name: "PCPR ‚Äì Agente de Pol√≠cia",
    weights: {
      "Portugu√™s": 1.20,
      "RLM": 0.90,
      "Inform√°tica": 0.80,
      "Atualidades": 0.70,
      "Direito Constitucional": 1.00,
      "Direito Administrativo": 0.90,
      "Direito Penal": 1.30,
      "Processo Penal": 1.20,
      "Direitos Humanos": 0.90,
      "Legisla√ß√£o Especial": 0.90,
      "Legisla√ß√£o PCPR/PR": 0.80,
    }
  }
};

const CURRICULUM = {
  TRT_AJ: {
    "Direito Constitucional": [
      "Teoria da Constitui√ß√£o (conceito, classifica√ß√µes, supremacia)",
      "Aplicabilidade / interpreta√ß√£o das normas constitucionais",
      "Direitos e garantias fundamentais (parte 1)",
      "Direitos e garantias fundamentais (parte 2)",
      "Organiza√ß√£o do Estado (compet√™ncias, bens, interven√ß√£o)",
      "Administra√ß√£o P√∫blica (art. 37, servidores, responsabilidade)",
      "A√ß√µes constitucionais",
      "Controle de constitucionalidade (difuso/concentrado, ADI/ADC/ADPF)"
    ],
    "Direito Administrativo": [
      "Conceitos, fontes e regime jur√≠dico-administrativo",
      "Princ√≠pios (expressos e impl√≠citos)",
      "Atos administrativos (elementos, atributos, esp√©cies, desfazimento, convalida√ß√£o)",
      "Poderes administrativos (hier√°rquico, disciplinar, regulamentar, pol√≠cia)",
      "Agentes p√∫blicos (regimes, provimento, responsabilidade)",
      "Responsabilidade civil do Estado",
      "Licita√ß√µes e contratos (Lei 14.133/2021 ‚Äì no√ß√µes e pontos-chave)"
    ],
    "Direito do Trabalho": [
      "Rela√ß√£o de trabalho x rela√ß√£o de emprego",
      "Empregado e empregador",
      "Elementos da rela√ß√£o de emprego (pessoalidade, onerosidade, habitualidade, subordina√ß√£o)",
      "Jornada, intervalos, horas extras e banco de horas",
      "Remunera√ß√£o e sal√°rio (parcelas, adicionais)",
      "Altera√ß√£o contratual, jus variandi, transfer√™ncia",
      "Suspens√£o x interrup√ß√£o",
      "Rescis√£o (modalidades, verbas, aviso pr√©vio)",
      "Estabilidades e garantias provis√≥rias",
      "FGTS (no√ß√µes, hip√≥teses)",
      "Negocia√ß√£o coletiva (acordos, conven√ß√µes, ultratividade)"
    ],
    "Processo do Trabalho": [
      "Princ√≠pios e fontes",
      "Compet√™ncia material/territorial/funcional",
      "Partes, capacidade, jus postulandi",
      "Procedimentos (ordin√°rio, sumar√≠ssimo, sum√°rio)",
      "Audi√™ncia, provas, √¥nus e preclus√µes",
      "Recursos (ordin√°rios e no√ß√µes, pressupostos)",
      "Execu√ß√£o trabalhista (t√≠tulos, embargos, impugna√ß√µes, precat√≥ria)"
    ],
    "Portugu√™s": [
      "Interpreta√ß√£o e compreens√£o de textos",
      "Tipologia textual e coes√£o/coer√™ncia",
      "Ortografia e acentua√ß√£o",
      "Crase",
      "Pontua√ß√£o",
      "Concord√¢ncia nominal e verbal",
      "Reg√™ncia nominal e verbal",
      "Pronomes e coloca√ß√£o",
      "Sem√¢ntica (sinon√≠mia/anton√≠mia, sentido)"
    ]
  },
  INSS_TEC: {
    "Portugu√™s": ["Interpreta√ß√£o", "Coes√£o/coer√™ncia", "Gram√°tica (concord√¢ncia/reg√™ncia/crase/pontua√ß√£o)"],
    "Direito Constitucional": ["Seguridade Social", "Direitos fundamentais", "Administra√ß√£o p√∫blica (art. 37)"],
    "Direito Administrativo": ["Princ√≠pios", "Atos", "Poderes", "Agentes p√∫blicos", "Lei 14.133 (no√ß√µes)"],
    "Direito Previdenci√°rio": ["Seguridade e RGPS", "Benef√≠cios", "Custeio", "Processo administrativo previdenci√°rio"]
  },
  TRE_AJ: {
    "Portugu√™s": ["Interpreta√ß√£o", "Gram√°tica essencial", "Reescrita"],
    "Direito Constitucional": ["Direitos fundamentais", "Organiza√ß√£o do Estado", "Administra√ß√£o p√∫blica"],
    "Direito Administrativo": ["Princ√≠pios", "Atos", "Poderes", "Agentes", "Licita√ß√µes (no√ß√µes)"],
    "Direito Eleitoral": ["Princ√≠pios e justi√ßa eleitoral", "Alistamento", "Partidos", "Propaganda", "A√ß√µes eleitorais (no√ß√µes)"]
  },
  PCPR_AGENTE: {
    "Portugu√™s": ["Interpreta√ß√£o", "Pontua√ß√£o", "Concord√¢ncia", "Reg√™ncia"],
    "RLM": ["Proposi√ß√µes", "Equival√™ncias", "Porcentagem", "Problemas"],
    "Direito Penal": ["Teoria do crime", "Parte geral", "Crimes em esp√©cie (n√∫cleo)", "Leis especiais (no√ß√µes)"],
    "Processo Penal": ["Inqu√©rito", "A√ß√£o penal", "Provas", "Pris√µes e medidas cautelares"],
    "Direitos Humanos": ["Sistema global/interamericano (no√ß√µes)", "Direitos e garantias (CF)"]
  },
  RFB_AUDITOR: {
    "Portugu√™s": ["Interpreta√ß√£o", "Gram√°tica", "Reescrita"],
    "Direito Constitucional": ["STN (CF)", "Direitos fundamentais", "Administra√ß√£o p√∫blica"],
    "Direito Administrativo": ["Princ√≠pios", "Atos", "Poderes", "Licita√ß√µes (Lei 14.133)"],
    "Direito Tribut√°rio": ["Sistema tribut√°rio", "Cr√©dito tribut√°rio", "Lan√ßamento", "Obriga√ß√µes"],
    "Contabilidade": ["Princ√≠pios", "Balan√ßo/DRE", "Lan√ßamentos", "Demonstra√ß√µes (no√ß√µes)"]
  },
  AFT: {
    "Portugu√™s": ["Interpreta√ß√£o", "Gram√°tica essencial"],
    "Direito Constitucional": ["Direitos sociais", "Administra√ß√£o p√∫blica", "Controle (no√ß√µes)"],
    "Direito Administrativo": ["Princ√≠pios", "Atos", "Poderes", "Agentes"],
    "Direito do Trabalho": ["Rela√ß√£o de emprego", "Jornada", "Remunera√ß√£o", "Rescis√£o"],
    "Seguran√ßa e Sa√∫de no Trabalho": ["NRs (no√ß√µes)", "Fiscaliza√ß√£o", "Infra√ß√µes e penalidades"]
  }
};






function isProfileComplete(p){
/* =======================
   Onboarding / P√°gina Inicial (Gate)
   Requisitos: curso/cargo + data de in√≠cio
   Nome √© opcional
======================= */
function isGateComplete(profile){
  try{
    if(!profile) return false;
  }catch(e){}
  try{
    const p = profile || {};
    const hasExam = !!(p.mainExamId || getActiveExam());
    const hasStart = !!(p.startDate && String(p.startDate).length>=8);
    return hasExam && hasStart;
  }catch(e){
    return false;
  }
}

function mountOnboarding(){
  const app = document.getElementById("app");
  if(!app) return;
  const profile = loadProfile() || {};
  const active = getActiveExam();

  // Build options from registry
  const exams = (typeof EXAMS!=="undefined" && Array.isArray(EXAMS)) ? EXAMS : (typeof EXAM_REGISTRY!=="undefined" ? Object.values(EXAM_REGISTRY) : []);
  const options = (exams||[]).map(ex=>{
    const id = ex.id || ex.examId || ex.key || "";
    const label = ex.label || ex.name || id;
    const sel = (profile.mainExamId ? profile.mainExamId===id : active===id) ? "selected" : "";
    return `<option value="${escapeHtml(id)}" ${sel}>${escapeHtml(label)}</option>`;
  }).join("");

  const todayISO = new Date().toISOString().slice(0,10);
  const startVal = profile.startDate ? String(profile.startDate).slice(0,10) : "";
  const nameVal = profile.name || profile.userName || "";

  app.innerHTML = `
    <div class="container" style="max-width:980px;">
      <div class="card" style="padding:22px;border:1px solid #e7e9ee;box-shadow:0 10px 30px rgba(16,24,40,.06);">
        <div class="row" style="align-items:center;justify-content:space-between;gap:14px;">
          <div>
            <div style="font-size:20px;font-weight:750;">Bem-vindo(a) ao MattarLeister ‚Äî Alta Performance</div>
            <div class="muted" style="margin-top:4px;">Fa√ßa seu cadastro b√°sico para o sistema ajustar automaticamente Matriz, Cronograma, Radar e Caderno.</div>
          </div>
          <span class="pill">in√≠cio</span>
        </div>

        <div style="margin-top:18px;display:grid;grid-template-columns:1fr 1fr;gap:14px;">
          <div>
            <label class="tiny muted">Nome (opcional)</label>
            <input id="obName" class="input" placeholder="Ex.: Carolina" value="${escapeHtml(nameVal)}">
          </div>
          <div>
            <label class="tiny muted">Data de in√≠cio (obrigat√≥rio)</label>
            <input id="obStart" class="input" type="date" value="${escapeHtml(startVal)}" max="${todayISO}">
          </div>
          <div style="grid-column:1 / -1;">
            <label class="tiny muted">Escolha seu curso/cargo (obrigat√≥rio)</label>
            <select id="obExam" class="input">
              <option value="">Selecione...</option>
              ${options}
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:18px;gap:10px;justify-content:flex-end;">
          <button class="btn ghost" id="obClear">Limpar</button>
          <button class="btn" id="obSave">Salvar e entrar</button>
        </div>

        <div class="note" style="margin-top:10px;">
          Dica: depois voc√™ pode trocar o concurso no <b>Perfil</b>. Mas a troca j√° vai ficar salva automaticamente (sem voltar para TRT).
        </div>
      </div>
    </div>
  `;

  const btnSave = document.getElementById("obSave");
  const btnClear = document.getElementById("obClear");
  if(btnClear){
    btnClear.onclick = ()=>{
      try{
        document.getElementById("obName").value="";
        document.getElementById("obStart").value="";
        document.getElementById("obExam").value="";
      }catch(e){}
    };
  }

  if(btnSave){
    btnSave.onclick = ()=>{
      const nm = (document.getElementById("obName").value||"").trim();
      const st = (document.getElementById("obStart").value||"").trim();
      const ex = (document.getElementById("obExam").value||"").trim();
      if(!ex){ toast("Escolha o curso/cargo."); return; }
      if(!st){ toast("Informe a data de in√≠cio."); return; }

      const updated = { ...profile };
      if(nm) updated.name = nm;
      updated.startDate = st;
      updated.mainExamId = ex;

      try{ saveProfile(updated); }catch(e){}
      try{ setActiveExamAndSyncProfile(ex); }catch(e){ try{ setActiveExam(ex); }catch(e2){} }

      // Invalida caches e recalcula plano
      try{ invalidateMatrixCacheForExam(ex); }catch(e){}
      try{ emitML("ML:STATE_IMPORTED",{mode:"onboarding"}); }catch(e){}
      try{ emitML("ML:REVIEWS_UPDATED",{source:"onboarding"}); }catch(e){}

      toast("Perfil salvo ‚úì");
      // entra no sistema
      try{ go("dashboard"); }catch(e){ try{ render(); }catch(e2){} }
    };
  }
}

  return !!(p && safeString(p.mainExamId) && safeString(p.startDateISO));
}

// ===== Pesos por disciplina (customiz√°vel) =====
const EXAM_WEIGHTS_PREFIX = "SAPE_EXAM_WEIGHTS::";

function loadExamWeights(examId){
  const key = EXAM_WEIGHTS_PREFIX + examId;
  return loadJSON(key, {});
}
function saveExamWeights(examId, obj){
  const key = EXAM_WEIGHTS_PREFIX + examId;
  saveJSON(key, obj || {});
}
function resetExamWeights(examId){
  const key = EXAM_WEIGHTS_PREFIX + examId;
  try{ localStorage.removeItem(key); }catch{}
}
function getExamWeights(examId){
  const base = (EXAMS[examId] && EXAMS[examId].weights) ? EXAMS[examId].weights : {};
  const custom = loadExamWeights(examId);
  return Object.assign({}, base, custom);
}

// Build a Map of discipline weights for a given examId
function getDiscWeightsMap(examId){
  const ew = getExamWeights(examId) || {};
  const obj = ew.discWeights || {};
  const m = new Map();
  for(const k of Object.keys(obj)){
    m.set(k, Number(obj[k]) || 1);
  }
  return m;
}

function getDiscWeight(examId, disc){
  const w = getExamWeights(examId)[disc];
  const num = Number(w);
  return Number.isFinite(num) && num>0 ? num : 1;
}
function listDiscsForExam(state, examId){
  const out = new Set();
  // do que j√° existe no banco
  (state.errors||[]).forEach(e=>{ if(e.examId===examId && e.disc) out.add(e.disc); });
  (state.questions||[]).forEach(q=>{ if(q.examId===examId && q.disc) out.add(q.disc); });
  // do template do edital (pesos base)
  Object.keys(getExamWeights(examId)||{}).forEach(d=>out.add(d));
  return Array.from(out).filter(Boolean).sort((a,b)=>a.localeCompare(b));
}

function getActiveExam(){
  try{
    // prioridade: chave nova (com prefixo multiusu√°rio) -> legado -> perfil -> default
    const kNew = mlKey(ACTIVE_EXAM_KEY);
    const vNew = localStorage.getItem(kNew);
    if(vNew) return vNew;

    const vLegacy = localStorage.getItem(LEGACY_ACTIVE_EXAM_KEY);
    if(vLegacy) return vLegacy;

    const p = (typeof loadProfile==="function") ? loadProfile() : null;
    if(p && p.mainExamId) return p.mainExamId;

    return "TRT_AJ";
  }catch(e){
    return "TRT_AJ";
  }
}

function setActiveExam(id){
  try{
    // grava nas duas chaves para compatibilidade
    localStorage.setItem(mlKey(ACTIVE_EXAM_KEY), id);
    localStorage.setItem(LEGACY_ACTIVE_EXAM_KEY, id);
  }catch(e){}
}


function setActiveExamAndSyncProfile(id){
  if(!id) return;
  try{ setActiveExam(id); }catch(e){}
  try{
    const p = loadProfile() || {};
    // mant√©m campos existentes e apenas sincroniza o concurso principal
    const next = Object.assign({}, p, { mainExamId: id });
    saveProfile(next);
  }catch(e){}
}
/* =========================================================
   MODULE: core/state-contract
   ========================================================= */
const STATE_ALLOWED_KEYS = new Set(["version","schemaVersion","errors","traps","questions","advSim","notebook","mlCore","mlUsers","mlEventLog","mlPerformance","mlAnalytics","mlPlan"]);
function normalizeState(raw){
  const s = (raw && typeof raw === "object") ? raw : {};
  const out = {
    version: s.version || STATE_VERSION,
    schemaVersion: Number.isFinite(s.schemaVersion) ? s.schemaVersion : SCHEMA_VERSION,

    // Legacy modules
    errors: Array.isArray(s.errors) ? s.errors : [],
    traps: Array.isArray(s.traps) ? s.traps : [],
    questions: Array.isArray(s.questions) ? s.questions : [],
    advSim: s.advSim || null,
    notebook: (s.notebook && typeof s.notebook==="object") ? s.notebook : {},

    // MattarLeister Core (multi-user + performance)
    mlCore: (s.mlCore && typeof s.mlCore==="object") ? s.mlCore : {
      metaGlobalBase: 70,
      metaGlobalAtual: 70,
      decayLambda: 0.02,
      timeIdealSecByQuestion: 140
    },
    mlUsers: (s.mlUsers && typeof s.mlUsers==="object") ? s.mlUsers : {
      activeUserId: null,
      users: {}
    },
    mlEventLog: (s.mlEventLog && typeof s.mlEventLog==="object") ? s.mlEventLog : {},
    mlPerformance: (s.mlPerformance && typeof s.mlPerformance==="object") ? s.mlPerformance : {},
    mlAnalytics: (s.mlAnalytics && typeof s.mlAnalytics==="object") ? s.mlAnalytics : {},
    mlPlan: (s.mlPlan && typeof s.mlPlan==="object") ? s.mlPlan : {}
  };
  return out;
}

function validateStateStrict(state){
  const s = normalizeState(state);

  // unknown keys detection (non-fatal unless debug)
  try{
    const keys = Object.keys(state || {});
    const unknown = keys.filter(k=> !STATE_ALLOWED_KEYS.has(k));
    if(unknown.length) dwarn("Chaves desconhecidas no state (ignoradas):", unknown);
  }catch{}

  // arrays must contain objects with ids (where applicable)
  const ids = new Set();
  for(const e of s.errors){
    invariant(e && typeof e === "object", "error item inv√°lido");
    invariant(typeof e.id === "string" && e.id.length>0, "error.id ausente");
    invariant(!ids.has("e:"+e.id), "error.id duplicado");
    ids.add("e:"+e.id);
  }
  for(const t of s.traps){
    invariant(t && typeof t === "object", "trap item inv√°lido");
    invariant(typeof t.id === "string" && t.id.length>0, "trap.id ausente");
    invariant(!ids.has("t:"+t.id), "trap.id duplicado");
    ids.add("t:"+t.id);
  }
  for(const q of s.questions){
    invariant(q && typeof q === "object", "question item inv√°lido");
    invariant(typeof q.id === "string" && q.id.length>0, "question.id ausente");
    invariant(!ids.has("q:"+q.id), "question.id duplicado");
    ids.add("q:"+q.id);
  }

  // schema/version types
  invariant(Number.isFinite(s.schemaVersion), "schemaVersion inv√°lido");
  invariant(typeof s.version === "string", "version inv√°lida");
  invariant(s.mlCore && typeof s.mlCore==="object", "mlCore inv√°lido");
  invariant(s.mlUsers && typeof s.mlUsers==="object", "mlUsers inv√°lido");
  return s;
}

function loadState(){
  const empty = { version: STATE_VERSION, errors: [], traps: [], questions: [], advSim: null };

  function parseOrNull(raw){
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch{ return null; }
  }
  function isValidShape(x){
    return x && typeof x === "object" &&
      ("errors" in x) && ("traps" in x) && ("questions" in x);
  }

  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    const parsed = parseOrNull(raw);
    if(parsed && isValidShape(parsed)) return migrate(validateStateStrict(parsed));

    // fallback: backup
    const braw = localStorage.getItem(STORAGE_BACKUP_KEY);
    const b = parseOrNull(braw);
    if(b && isValidShape(b)){
      // restore backup as primary for stability
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(b));
        localStorage.setItem(STORAGE_META_KEY, JSON.stringify({ restoredAt: Date.now(), reason: "fallback_backup" }));
      }catch{}
      return migrate(validateStateStrict(b));
    }

    return migrate(validateStateStrict(empty));
  }catch{
    return migrate(validateStateStrict(empty));
  }
}

// ===== Storage helpers (robust) =====
function loadJSON(key, fallback){
  try{
    const raw = localStorage.getItem(key);
    if(!raw) return fallback;
    return JSON.parse(raw);
  }catch(e){
    console.warn("loadJSON failed", key, e);
    return fallback;
  }
}
function saveJSON(key, value){
  try{
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  }catch(e){
    console.warn("saveJSON failed", key, e);
    return false;
  }
}


function saveState(state){
  const safe = validateStateStrict(state);

  try{
    // keep last known-good snapshot
    const prev = localStorage.getItem(STORAGE_KEY);
    if(prev){
      localStorage.setItem(STORAGE_BACKUP_KEY, prev);
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(safe));
    localStorage.setItem(STORAGE_META_KEY, JSON.stringify({ savedAt: Date.now(), version: STATE_VERSION, schemaVersion: SCHEMA_VERSION }));
  }catch(e){
    console.warn("Falha ao salvar", e);
  }
}

// Debounced save to avoid heavy writes
let __saveTimer = null;
function debouncedSave(state){
  try{
    if(__saveTimer) clearTimeout(__saveTimer);
    __saveTimer = setTimeout(()=>{
      __saveTimer = null;
      saveState(state);
      dlog('state salvo');
    }, 200);
  }catch(e){
    console.warn('debouncedSave falhou', e);
  }
}

function createStore({ initialState, reducer }){
  let state = initialState;
  const listeners = new Set();
  function getState(){ return state; }
  function dispatch(action){
    const next = reducer(state, action);
    if(next !== state){
      state = next;
      debouncedSave(state);
      listeners.forEach(fn => fn(state, action));
    }
  }
  function subscribe(fn){ listeners.add(fn); return () => listeners.delete(fn); }
  return { getState, dispatch, subscribe };
}

/* =========================
   ACTIONS
========================= */

const A = {
  ERROR_ADD:"ERROR_ADD",
  ERROR_UPDATE:"ERROR_UPDATE",
  ERROR_DELETE:"ERROR_DELETE",
  ERROR_MARK_REVIEWED:"ERROR_MARK_REVIEWED",
  ERROR_POSTPONE:"ERROR_POSTPONE",
  ERROR_SET_NEXT_REVIEW:"ERROR_SET_NEXT_REVIEW",

  TRAP_ANALYZE:"TRAP_ANALYZE",
  TRAP_ADD:"TRAP_ADD",
  TRAP_DELETE:"TRAP_DELETE",
  TRAP_SIM_START:"TRAP_SIM_START",
  TRAP_SIM_ANSWER:"TRAP_SIM_ANSWER",
  TRAP_SIM_END:"TRAP_SIM_END",

  Q_ADD:"Q_ADD",
  Q_DELETE:"Q_DELETE",

  STATE_IMPORT:"STATE_IMPORT",
  NB_SAVE:"NB_SAVE",
  NB_IMPORT_MERGE:"NB_IMPORT_MERGE",
  STATE_RESET:"STATE_RESET",
};

/* =========================
   REDUCERS
========================= */

function errorsReducer(slice, action){
  const errors = Array.isArray(slice) ? slice : [];
  switch(action.type){
    case A.ERROR_ADD: return [...errors, sanitizeError(action.payload)];
    case A.ERROR_UPDATE:{
      const id = safeString(action.id);
      const patch = action.patch && typeof action.patch === "object" ? action.patch : {};
      return errors.map(e => e.id === id ? sanitizeError({ ...e, ...patch, id: e.id }) : e);
    }
    case A.ERROR_DELETE:{
      const id = safeString(action.id);
      return errors.filter(e => e.id !== id);
    }
    case A.ERROR_SET_NEXT_REVIEW:{
      const id = safeString(action.id);
      const when = action.when ? new Date(action.when) : null;
      const iso = when && !Number.isNaN(when.getTime()) ? when.toISOString() : null;
      return errors.map(e => e.id === id ? { ...e, nextReviewAt: iso } : e);
    }
    case A.ERROR_POSTPONE:{
      const id = safeString(action.id);
      const days = Number(action.days || 1);
      return errors.map(e => {
        if(e.id !== id) return e;
        const base = e.nextReviewAt ? new Date(e.nextReviewAt) : new Date();
        const next = addDays(base, days);
        return { ...e, nextReviewAt: next.toISOString() };
      });
    }
    case A.ERROR_MARK_REVIEWED:{
      const id = safeString(action.id);
      const now = new Date();
      return errors.map(e => {
        if(e.id !== id) return e;
        const hist = Array.isArray(e.reviewHistory) ? e.reviewHistory.slice() : [];
        hist.push(now.toISOString());
        const n = hist.length;
        const delta = (n === 1) ? 3 : (n === 2) ? 7 : 14;
        const next = addDays(startOfDay(now), delta);
        return { ...e, reviewHistory: hist, nextReviewAt: next.toISOString() };
      });
    }
    default: return errors;
  }
}

function analyzeTrapPayload(p){
  const now = Date.now();
  const text = (p.text||"").trim();
  const fix = (p.fix||"").trim();

  const hasNeg = /n√£o|nunca|exceto|salvo|apenas|somente|incorreta|errada/i.test(text);
  const hasQuant = /\bsempre\b|\bnunca\b|\bapenas\b|\bsomente\b|\bexclusivamente\b/i.test(text);
  const hasPegWords = /pegadinh|armadilh|induz|confund|sutil|literal|princ√≠pi|conceit/i.test(text);
  const lengthScore = Math.min(1, text.length/800);

  let danger = 35;
  danger += hasNeg ? 15 : 0;
  danger += hasQuant ? 15 : 0;
  danger += hasPegWords ? 10 : 0;
  danger += Math.round(25*lengthScore);
  danger = Math.max(10, Math.min(98, danger));

  const typical = [];
  if(hasNeg) typical.push("Nega√ß√£o/EXCETO");
  if(hasQuant) typical.push("Absolutismo (sempre/nunca)");
  if(/conceito|defini√ß√£o|natureza|distin√ß√£o/i.test(text)) typical.push("Conceitual (distin√ß√µes finas)");
  if(/compet√™n|prazo|recurso|cabimento|efeitos/i.test(text)) typical.push("Processual (prazo/cabimento/efeitos)");
  if(/princ√≠pi|regra|exce√ß|requisit|elemento|atributo/i.test(text)) typical.push("Requisitos/Exce√ß√µes");
  if(typical.length===0) typical.push("Leitura literal x contexto");

  const trainPlan = [];
  if(hasNeg) trainPlan.push("Sublinhar NEGATIVOS e inverter mentalmente");
  if(hasQuant) trainPlan.push("Procurar exce√ß√µes (sempre/nunca = quase sempre falso)");
  trainPlan.push("Reescrever a assertiva em 1 frase simples");
  trainPlan.push("Provar o contr√°rio com 1 exemplo");
  if(!fix) trainPlan.push("Escrever a corre√ß√£o (qual detalhe muda o gabarito)");

  return sanitizeTrap({
    id: uid(),
    createdAt: new Date(now).toISOString(),
    disc: p.disc || "",
    topic: p.topic || "",
    bank: p.bank || "AUTO",
    type: p.type || "Amb√≠gua/dupla interpreta√ß√£o",
    text,
    fix,
    danger,
    typical,
    trainPlan
  });
}

function trapsReducer(slice, action, fullState){
  const traps = Array.isArray(slice) ? slice : [];
  switch(action.type){
    case A.TRAP_ADD:{
      const t = sanitizeTrap(action.payload);
      const next = [t, ...traps].slice(0, 500);
      return next;
    }
    case A.TRAP_DELETE:{
      const id = safeString(action.id);
      return traps.filter(t => t.id !== id);
    }
    default:
      return traps;
  }
}


function questionsReducer(slice, action){
  const qs = Array.isArray(slice) ? slice : [];
  switch(action.type){
    case A.Q_ADD:{
      const q = sanitizeQuestion(action.payload);
      return [q, ...qs].slice(0, 5000);
    }
    case A.Q_DELETE:{
      const id = safeString(action.id);
      return qs.filter(x => x.id !== id);
    }
    default:
      return qs;
  }
}

function advSimReducer(slice, action, fullState){
  const s = slice && typeof slice === "object" ? slice : null;
  switch(action.type){
    case A.TRAP_SIM_START:{
      const pool = Array.isArray(fullState.traps) ? fullState.traps : [];
      if(pool.length < 3) return { error:"MIN_3" };
      const sample = shuffle(pool.slice()).slice(0, Math.min(10, pool.length));
      return { startedAt: Date.now(), items: sample, idx: 0, right: 0, wrong: 0, done:false };
    }
    case A.TRAP_SIM_ANSWER:{
      if(!s || s.error) return s;
      if(s.done) return s;
      const correct = !!action.correct;
      const idx = s.idx;
      const right = s.right + (correct ? 1 : 0);
      const wrong = s.wrong + (correct ? 0 : 1);
      const nextIdx = idx + 1;
      const done = nextIdx >= s.items.length;
      return { ...s, idx: nextIdx, right, wrong, done };
    }
    case A.TRAP_SIM_END:
      return null;
    default:
      return s;
  }
}

function rootReducer(state, action){
  if(action.type === A.STATE_IMPORT) return migrate(action.payload);
  if(action.type === A.STATE_RESET) return migrate({ version: STATE_VERSION, errors: [], traps: [], questions: [], advSim: null });

  const next = {
    ...state,
    errors: errorsReducer(state.errors, action),
    traps: trapsReducer(state.traps, action, state),
    questions: questionsReducer(state.questions, action),
    advSim: advSimReducer(state.advSim, action, state),
    notebook: notebookReducer(state.notebook, action),
    mlCore: state.mlCore,
    mlUsers: state.mlUsers,
    mlEventLog: state.mlEventLog,
    mlPerformance: state.mlPerformance,
    mlAnalytics: state.mlAnalytics,
    mlPlan: state.mlPlan,
  };
  return next;
}


function notebookReducer(slice, action){
  const nb = (slice && typeof slice === "object") ? slice : {};
  switch(action.type){
    case A.NB_SAVE:{
      const { examId, disc, topic, data } = action.payload || {};
      const ex = safeString(examId);
      const d  = safeString(disc);
      const t  = safeString(topic);
      if(!ex || !d || !t) return nb;
      const exObj = (nb[ex] && typeof nb[ex]==="object") ? nb[ex] : {};
      const dObj  = (exObj[d] && typeof exObj[d]==="object") ? exObj[d] : {};
      const cur   = (dObj[t] && typeof dObj[t]==="object") ? dObj[t] : {};
      const nextT = { ...cur, ...(data||{}), updatedAt: new Date().toISOString() };
      return {
        ...nb,
        [ex]: { ...exObj, [d]: { ...dObj, [t]: nextT } }
      };
    }
    case A.NB_IMPORT_MERGE:{
      // usado no import: mescla notebook vindo de backup
      const incoming = action.payload && typeof action.payload === "object" ? action.payload : {};
      return deepMerge(nb, incoming);
    }
    default: return nb;
  }
}

/* =========================
   SELECTORS
========================= */

function selectKpis(state){
  const errors = filterByExam(state.errors || []);
  const today0 = startOfDay(new Date());
  const tomorrow0 = addDays(today0, 1);
  const in7 = addDays(today0, 7);

  let overdue = 0, dueToday = 0, due7 = 0, noSchedule = 0;

  for(const e of errors){
    if(!e.nextReviewAt){ noSchedule++; continue; }
    const d = new Date(e.nextReviewAt);
    if(Number.isNaN(d.getTime())) { noSchedule++; continue; }
    if(d < today0) overdue++;
    else if(d >= today0 && d < tomorrow0) dueToday++;
    else if(d >= tomorrow0 && d < in7) due7++;
  }
  const trapsCount = Array.isArray(state.traps) ? state.traps.length : 0;
  const qCount = Array.isArray(state.questions) ? state.questions.length : 0;
  const answered = (state.questions||[]).filter(q=> q.isCorrect !== null).length;
  const correct = (state.questions||[]).filter(q=> q.isCorrect === true).length;
  const acc = answered ? Math.round((correct/answered)*100) : 0;
  return { totalErrors: errors.length, overdue, dueToday, due7, noSchedule, trapsCount, qCount, answered, correct, acc };
}


function flattenNotebookErrors(state){
  const out = [];
  const nb = state.notebook || state.notebookState || {};
  const examId = (typeof loadProfile === 'function' ? (loadProfile()||{}).mainExamId : '') || '';
  const scoped = examId && nb[examId] ? { [examId]: nb[examId] } : nb;

  Object.keys(scoped||{}).forEach(ex=>{
    const byDisc = scoped[ex] || {};
    Object.keys(byDisc).forEach(disc=>{
      const byTopic = byDisc[disc] || {};
      Object.keys(byTopic).forEach(topic=>{
        const entry = byTopic[topic] || {};
        const errs = Array.isArray(entry.errors) ? entry.errors : [];
        errs.forEach(er=>{
          if(!er || !er.id) return;
          out.push({
            id: String(er.id),
            examId: ex,
            disc,
            topic,
            type: er.type || "outro",
            priority: er.priority || "media",
            prompt: er.prompt || "",
            fix: er.fix || "",
            why: er.why || "",
            tags: Array.isArray(er.tags) ? er.tags : [],
            createdAt: er.createdAt || null,
            nextReviewAt: er.nextReviewAt || null,
            reviewed: !!er.reviewed
          });
        });
      });
    });
  });

  return out;
}

function selectScheduleBuckets(state){
  const errors = flattenNotebookErrors(state);
  const today0 = startOfDay(new Date());
  const tomorrow0 = addDays(today0, 1);
  const weekEnd0 = addDays(today0, 7);

  const overdue = [];
  const today = [];
  const week = {};
  const backlog = [];

  for(const e of errors){
    if(e.reviewed) continue;
    const nr = e.nextReviewAt ? new Date(e.nextReviewAt) : null;
    if(!nr || isNaN(nr.getTime())){ backlog.push(e); continue; }

    const day0 = startOfDay(nr);
    if(day0 < today0) overdue.push(e);
    else if(day0.getTime() === today0.getTime()) today.push(e);
    else if(day0 >= tomorrow0 && day0 < weekEnd0){
      const key = day0.toISOString().slice(0,10);
      if(!week[key]) week[key] = [];
      week[key].push(e);
    }
  }

  const sortByNext = (a,b)=>{
    const ta = a.nextReviewAt ? new Date(a.nextReviewAt).getTime() : 0;
    const tb = b.nextReviewAt ? new Date(b.nextReviewAt).getTime() : 0;
    return ta - tb;
  };

  overdue.sort(sortByNext);
  today.sort(sortByNext);
  Object.keys(week).forEach(k=>week[k].sort(sortByNext));

  return { overdue, today, week, backlog };
}



/* =========================================================
   MODULE: engine/adaptive-weights
   ========================================================= */
function __tsFromAny(x){
  const v = x && (x.createdAt || x.ts || x.date || x.time);
  if(!v) return null;
  const d = new Date(v);
  if(Number.isNaN(d.getTime())) return null;
  return d.getTime();
}
function __withinDays(list, days){
  const now = Date.now();
  const cutoff = now - (days*24*60*60*1000);
  const withTs = list.filter(it=> __tsFromAny(it) !== null);
  if(withTs.length >= 5){
    return withTs.filter(it=> __tsFromAny(it) >= cutoff);
  }
  // fallback: treat "recent" as slice (newest first)
  return list.slice(0, Math.min(list.length, 250));
}


function sampleWeightedDisc(state){
  const wmap = computeDisciplineWeightMap(state);
  const entries = Array.from(wmap.entries()).filter(([k,v])=>k && Number.isFinite(v));
  if(!entries.length) return "(sem disciplina)";
  const total = entries.reduce((s,[,w])=>s+w,0) || 1;
  let r = Math.random()*total;
  for(const [k,w] of entries){
    r -= w;
    if(r<=0) return k;
  }
  return entries[0][0];
}

function filterByExam(list){
  const active = getActiveExam();
  if(!Array.isArray(list)) return [];
  return list.filter(x => x.examId === active);
}

function computeAdaptiveDisciplinePlan(state){
  const questions = filterByExam(state.questions || []);
  const errors = filterByExam(state.errors || []);
  const traps = filterByExam(state.traps || []);

  function discKey(d){ return (d||"(sem disciplina)").trim() || "(sem disciplina)"; }
  function ensure(map, d){
    const k = discKey(d);
    if(!map.has(k)) map.set(k, { disc:k, qAns:0, qRight:0, qWrong:0, errors:0, overdue:0, traps:0 });
    return map.get(k);
  }

  const discMap = new Map();
  for(const q of questions){
    const row = ensure(discMap, q.disc);
    if(q.isCorrect === null) continue;
    row.qAns++;
    if(q.isCorrect) row.qRight++; else row.qWrong++;
  }
  const today0 = startOfDay(new Date());
  for(const e of errors){
    const row = ensure(discMap, e.disc);
    row.errors++;
    if(e.nextReviewAt){
      const d = new Date(e.nextReviewAt);
      if(!Number.isNaN(d.getTime()) && d < today0) row.overdue++;
    }
  }
  for(const t of traps){
    const row = ensure(discMap, t.disc);
    row.traps++;
  }

  const heatRows = Array.from(discMap.values()).map(r=>{
    const acc = r.qAns ? Math.round((r.qRight/r.qAns)*100) : 0;
    const risk = (r.overdue*3) + (r.qWrong*2) + (r.errors) + Math.round(r.traps*1.2);
    return { ...r, acc, risk };
  }).sort((a,b)=> (b.risk - a.risk) || (a.acc - b.acc));

  const answeredAll = (questions||[]).filter(q=> q.isCorrect !== null);
  const answeredRecent = __withinDays(answeredAll, 14);

  const baseWeekGoal = Math.max(20, Math.round(answeredAll.length * 0.15));

  // pick focus disciplines
  const focus = heatRows.filter(r=> r.disc !== "(sem disciplina)").slice(0,4);
  const totalRisk = focus.reduce((s,r)=> s + Math.max(1,r.risk), 0) || 1;

  function recentCount(disc){
    const k = discKey(disc);
    return answeredRecent.filter(q=> discKey(q.disc) === k).length;
  }

  const plan = focus.map(r=>{
    const w = Math.max(1,r.risk)/totalRisk;
    let goal = Math.max(3, Math.round(baseWeekGoal*w));
    const done = recentCount(r.disc);
    return { disc:r.disc, goal, done, risk:r.risk, acc:r.acc, overdue:r.overdue, wrong:r.qWrong };
  });

  // scale to keep totals reasonable
  const sumGoals = plan.reduce((s,x)=> s + x.goal, 0);
  const maxTotal = Math.round(baseWeekGoal * 1.2);
  const scale = sumGoals > maxTotal ? (maxTotal/sumGoals) : 1;
  for(const g of plan){
    if(scale !== 1) g.goal = Math.max(2, Math.round(g.goal*scale));
  }

  // discipline trend (last10 vs prev10 per discipline, using newest-first ordering)
  const answeredByDisc = new Map();
  for(const q of answeredAll){
    const k = discKey(q.disc);
    if(!answeredByDisc.has(k)) answeredByDisc.set(k, []);
    answeredByDisc.get(k).push(q);
  }
  function acc(list){
    if(!list.length) return 0;
    const right = list.filter(q=> q.isCorrect).length;
    return Math.round((right/list.length)*100);
  }
  for(const g of plan){
    const arr = answeredByDisc.get(discKey(g.disc)) || [];
    const last10 = arr.slice(0,10);
    const prev10 = arr.slice(10,20);
    g.trend = acc(last10) - acc(prev10);
  }

  return { baseWeekGoal, answeredRecentCount: answeredRecent.length, heatRows, plan };
}

function computeDisciplineWeightMap(state){
  const { plan, heatRows } = computeAdaptiveDisciplinePlan(state);
  const weight = new Map();

  // baseline risk average for normalization
  const avgRisk = heatRows.length ? (heatRows.reduce((s,r)=> s + Math.max(0,r.risk),0) / heatRows.length) : 1;

  function discKey(d){ return (d||"(sem disciplina)").trim() || "(sem disciplina)"; }

  // default weights for all known disciplines
  for(const r of heatRows){
    const k = discKey(r.disc);
    // mild risk factor everywhere (keeps behavior stable)
    const riskFactor = avgRisk ? Math.min(1.0, Math.max(0, r.risk) / (avgRisk*2)) : 0;
    weight.set(k, 1 + (riskFactor*0.35));
  }

  // boost focus plan disciplines
  for(const g of plan){
    const k = discKey(g.disc);
    const base = weight.get(k) || 1;
    const behind = g.goal ? Math.max(0, 1 - (g.done / g.goal)) : 0; // 0..1
    const ag = getAggro();
    const ahead = g.goal && g.done >= g.goal;
    const trendPenalty = g.trend < 0 ? (0.25 * ag) : 0;

    let w = base;
    w += Math.min(0.9*ag, behind * (0.9*ag));     // scaled by aggressiveness
    w += trendPenalty;                     // +0.25 if trend negative
    if(ahead) w *= (1 - (0.22*ag));              // downweight if already met goal (scaled)

    // clamp for stability
    w = Math.max(0.6, Math.min(2.6, w));
    weight.set(k, w);
  }

  return weight;
}
function explainDisciplineWeight(state, disc){
  const { plan, heatRows } = computeAdaptiveDisciplinePlan(state);
  const discKey = (d)=> (d||"(sem disciplina)").trim() || "(sem disciplina)";
  const key = discKey(disc);
  const ag = getAggro();

  const row = heatRows.find(r=> discKey(r.disc) === key) || { disc:key, risk:0, acc:0, overdue:0, qWrong:0, errors:0, traps:0 };
  const planRow = plan.find(p=> discKey(p.disc) === key) || null;

  // baseline
  const avgRisk = heatRows.length ? (heatRows.reduce((s,r)=> s + Math.max(0,r.risk),0) / heatRows.length) : 1;
  const riskFactor = avgRisk ? Math.min(1.0, Math.max(0, row.risk) / (avgRisk*2)) : 0;
  const base = 1 + (riskFactor*0.35);

  let deltaBehind = 0, deltaTrend = 0, multAhead = 1;

  if(planRow){
    const behind = planRow.goal ? Math.max(0, 1 - (planRow.done/planRow.goal)) : 0;
    deltaBehind = Math.min(0.9*ag, behind*(0.9*ag));
    deltaTrend = (planRow.trend < 0) ? (0.25*ag) : 0;
    const ahead = planRow.goal && planRow.done >= planRow.goal;
    if(ahead) multAhead = (1 - (0.22*ag));
  }

  let w = (base + deltaBehind + deltaTrend) * multAhead;
  w = Math.max(0.6, Math.min(2.6, w));

  // Build explanation lines
  const lines = [];
  lines.push({ label:"Base (risco relativo)", value: base, detail:`risco:${row.risk} ‚Ä¢ m√©dia~${Math.round(avgRisk||0)}` });
  if(planRow){
    lines.push({ label:"Meta atrasada", value: deltaBehind, detail:`feito:${planRow.done}/${planRow.goal}` });
    lines.push({ label:"Tend√™ncia", value: deltaTrend, detail:`trend:${planRow.trend>0?"+":""}${planRow.trend}%` });
    if(multAhead !== 1) lines.push({ label:"Meta batida (redu√ß√£o)", value: (multAhead-1), detail:`x${multAhead.toFixed(2)}` });
  }else{
    lines.push({ label:"Meta adaptativa", value: 0, detail:"disciplina fora do top 4 (sem boost)" });
  }

  return {
    disc: key,
    weight: w,
    aggro: ag,
    metrics: { risk: row.risk, acc: row.acc, overdue: row.overdue, wrong: row.qWrong, errors: row.errors, traps: row.traps },
    planInfo: planRow ? { goal: planRow.goal, done: planRow.done, trend: planRow.trend } : null,
    lines
  };
}


function selectReviewQueue(state, limit=6){
  const activeExam = (state && state.activeExam) ? state.activeExam : getActiveExam();
  const discW = getDiscWeightsMap(activeExam);

  const now = new Date();
  const today0 = startOfDay(now);
  const tomorrow0 = addDays(today0, 1);

  const errors = Array.isArray(state.errors) ? state.errors : [];
  const traps  = Array.isArray(state.traps) ? state.traps : [];
  const questions = Array.isArray(state.questions) ? state.questions : [];

  // compute topic accuracy map from questions
  const accMap = new Map(); // key: disc||topic -> {ans,right}
  function key(d,t){ return (d||"").trim()+"||"+(t||"").trim(); }
  for(const q of questions){
    if(q.isCorrect === null) continue;
    const k = key(q.disc, q.topic);
    const obj = accMap.get(k) || { ans:0, right:0 };
    obj.ans += 1;
    if(q.isCorrect) obj.right += 1;
    accMap.set(k, obj);
  }
  function topicAcc(d,t){
    const o = accMap.get(key(d,t));
    if(!o || !o.ans) return null;
    return Math.round((o.right/o.ans)*100);
  }

  const items = [];

  // Errors scoring
  for(const e of errors){
    let score = 0;
    const nrev = Array.isArray(e.reviewHistory) ? e.reviewHistory.length : 0;
    score += Math.min(40, nrev * 10);

    if(e.nextReviewAt){
      const d = new Date(e.nextReviewAt);
      if(!Number.isNaN(d.getTime())){
        if(d < today0) score += 60;
        else if(d >= today0 && d < tomorrow0) score += 45;
        else score += 10;
      } else score += 5;
    } else {
      score += 15; // no schedule
    }

    const acc = topicAcc(e.disc, e.topic);
    if(acc !== null){
      if(acc < 50) score += 25;
      else if(acc < 70) score += 15;
      else if(acc < 85) score += 8;
    } else {
      score += 5;
    }

    items.push({ kind:"error", id:e.id, disc:e.disc, topic:e.topic, bank:e.bank, score, meta:e });
  }

  // Traps scoring (danger + mild boost for common low-acc topics)
  for(const t of traps){
    let score = 0;
    const danger = Number(t.danger || 0);
    score += Math.min(80, danger);
    const acc = topicAcc(t.disc, t.topic);
    if(acc !== null && acc < 70) score += 10;
    items.push({ kind:"trap", id:t.id, disc:t.disc, topic:t.topic, bank:t.bank, score, meta:t });
  }

  for(const it of items){
    const k = (it.disc||"(sem disciplina)").trim() || "(sem disciplina)";
    const w = discW.get(k) || 1;
    it.score = Math.round(it.score * w);
  }
  items.sort((a,b)=> b.score - a.score);
  return items.slice(0, Math.max(1, limit));
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}


/* =========================
   MattarLeister Core (ML)
========================= */

function mlGetActiveUserId(st){
  return st && st.mlUsers && st.mlUsers.activeUserId ? st.mlUsers.activeUserId : null;
}

function mlCreateEvent({userId, type, payload}){
  return { id: uid(), userId, type, payload: payload||{}, ts: Date.now() };
}

function mlAppendEvent(st, ev){
  const next = { ...st };
  const log = (st.mlEventLog && typeof st.mlEventLog==="object") ? st.mlEventLog : {};
  const arr = Array.isArray(log[ev.userId]) ? log[ev.userId] : [];
  next.mlEventLog = { ...log, [ev.userId]: [...arr, ev] };
  return next;
}

function mlMarkAnalyticsDirty(st, userId){
  const next = { ...st };
  const a = (st.mlAnalytics && typeof st.mlAnalytics==="object") ? st.mlAnalytics : {};
  const u = (a[userId] && typeof a[userId]==="object") ? a[userId] : {};
  next.mlAnalytics = { ...a, [userId]: { ...u, dirty:true } };
  return next;
}

function mlWeightByTime(daysOld, lambda){
  return Math.exp(-lambda * daysOld);
}

function mlCalculateUserPerformance(st, userId){
  const core = st.mlCore || { decayLambda:0.02, timeIdealSecByQuestion:140, metaGlobalAtual:70 };
  const lambda = Number(core.decayLambda)||0.02;
  const ideal = Number(core.timeIdealSecByQuestion)||140;
  const events = (st.mlEventLog && Array.isArray(st.mlEventLog[userId])) ? st.mlEventLog[userId] : [];
  const now = Date.now();

  let wSum=0, wTot=0, wTime=0, wTimeTot=0, wResTot=0;
  let daysSet = new Set();

  for(const e of events){
    const day = new Date(e.ts).toISOString().slice(0,10);
    daysSet.add(day);

    if(e.type!=="question_done") continue;
    const p = e.payload||{};
    const daysOld = (now - e.ts) / 86400000;
    const w = mlWeightByTime(daysOld, lambda);

    if(p.hasResult){
      wResTot += w;
      wSum += (p.correct?1:0)*w;
      wTot += w;
    }
    if(p.timeSec!=null){
      wTime += Math.min(1.2, ideal/Math.max(30, Number(p.timeSec))) * w;
      wTimeTot += w;
    }
  }

  const acc = wTot? (wSum/wTot)*100 : 0;
  const timeScore = wTimeTot? (wTime/wTimeTot)*100 : 0;

  // consist√™ncia simples (dias ativos / janela)
  const first = events.length ? new Date(events[0].ts) : new Date();
  const totalDays = Math.max(1, Math.ceil((now - first.getTime())/86400000));
  const consistency = (daysSet.size/totalDays)*100;

  // IPA simplificado (v1)
  const ipa = (acc*0.55) + (timeScore*0.25) + (consistency*0.20);

  const delta = 0; // v1: pode calcular vs √∫ltima foto
  return { ipa: Math.round(ipa*10)/10, acc: Math.round(acc), timeScore: Math.round(timeScore), consistency: Math.round(consistency), delta };
}

function mlBuildCognitiveAnalytics(st, userId){
  const core = st.mlCore || { decayLambda:0.02 };
  const lambda = Number(core.decayLambda)||0.02;
  const events = (st.mlEventLog && Array.isArray(st.mlEventLog[userId])) ? st.mlEventLog[userId] : [];
  const now = Date.now();

  // Buckets
  const fatigue = {1:{w:0, wrong:0},2:{w:0, wrong:0},3:{w:0, wrong:0},4:{w:0, wrong:0},5:{w:0, wrong:0}};
  const emotion = new Map(); // emo -> {w:0, time:0}
  const focus = {1:{w:0, right:0},2:{w:0, right:0},3:{w:0, right:0},4:{w:0, right:0},5:{w:0, right:0}};
  const phase = {"1-5":{w:0,right:0},"6-10":{w:0,right:0},"11-15":{w:0,right:0},"16-20":{w:0,right:0}};

  let any=false;

  for(const e of events){
    if(e.type!=="question_done") continue;
    const p = e.payload||{};
    const daysOld = (now - e.ts)/86400000;
    const w = mlWeightByTime(daysOld, lambda);

    if(p.hasResult || p.timeSec!=null || p.emotion || p.focus!=null || p.fatigue!=null) any=true;

    if(p.hasResult && p.fatigue!=null){
      const k = String(p.fatigue);
      if(fatigue[k]){
        fatigue[k].w += w;
        if(!p.correct) fatigue[k].wrong += w;
      }
    }

    if(p.timeSec!=null && p.emotion){
      const key = String(p.emotion||"").trim() || "(sem)";
      if(!emotion.has(key)) emotion.set(key,{w:0,time:0});
      const o = emotion.get(key);
      o.w += w;
      o.time += Number(p.timeSec)*w;
    }

    if(p.hasResult && p.focus!=null){
      const k = String(p.focus);
      if(focus[k]){
        focus[k].w += w;
        if(p.correct) focus[k].right += w;
      }
    }

    // fase do bloco (precisa de √≠ndice)
    if(p.hasResult && p.qIndexInBlock!=null){
      const i = Number(p.qIndexInBlock);
      const bucket = (i<=5)?"1-5":(i<=10)?"6-10":(i<=15)?"11-15":"16-20";
      phase[bucket].w += w;
      if(p.correct) phase[bucket].right += w;
    }
  }

  // build datasets
  const erroCansaco = {
    labels: ["1","2","3","4","5"],
    values: ["1","2","3","4","5"].map(k=>{
      const o=fatigue[k]; 
      return o.w ? Math.round((o.wrong/o.w)*100) : 0;
    })
  };

  const tempoEmocao = {
    labels: Array.from(emotion.keys()),
    values: Array.from(emotion.entries()).map(([k,o])=> o.w ? Math.round(o.time/o.w) : 0)
  };

  const focoPrecisao = {
    labels: ["1","2","3","4","5"],
    values: ["1","2","3","4","5"].map(k=>{
      const o=focus[k];
      return o.w ? Math.round((o.right/o.w)*100) : 0;
    })
  };

  const faseBloco = {
    labels: ["1-5","6-10","11-15","16-20"],
    values: ["1-5","6-10","11-15","16-20"].map(k=>{
      const o=phase[k];
      return o.w ? Math.round((o.right/o.w)*100) : 0;
    })
  };

  return { any, erroCansaco, tempoEmocao, focoPrecisao, faseBloco };
}

const mlChartsCache = { erro:null, tempo:null, foco:null, fase:null };

/* =========================
   Donuts (SVG puro) ‚Äî Intelig√™ncia Visual
========================= */

function mlClamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function mlSvgDonutSingle(percent, title, subtitle, meta){
  const p = mlClamp(Number(percent)||0, 0, 100);
  const r = 54;
  const c = 2 * Math.PI * r;
  const dash = (p/100) * c;
  const gap = c - dash;

  return `
  <div style="display:grid;grid-template-columns:180px 1fr;gap:14px;align-items:center;">
    <div style="display:flex;align-items:center;justify-content:center;">
      <svg width="160" height="160" viewBox="0 0 160 160" aria-label="${escapeHtml(title)}">
        <circle cx="80" cy="80" r="${r}" fill="none" stroke="rgba(15,23,42,.12)" stroke-width="14"></circle>
        <circle cx="80" cy="80" r="${r}" fill="none" stroke="currentColor" stroke-width="14"
          stroke-linecap="round"
          stroke-dasharray="${dash} ${gap}"
          transform="rotate(-90 80 80)"></circle>
        <text x="80" y="78" text-anchor="middle" font-size="28" font-weight="800" fill="currentColor">${Math.round(p)}%</text>
        <text x="80" y="102" text-anchor="middle" font-size="11" fill="rgba(15,23,42,.65)">${escapeHtml(subtitle||"")}</text>
      </svg>
    </div>
    <div style="min-width:0;">
      <div style="font-weight:800;font-size:15px;">${escapeHtml(title||"")}</div>
      <div class="tiny muted" style="margin-top:4px;">${escapeHtml(meta||"")}</div>
      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
        <span class="pill">0‚Äì64% cr√≠tico</span>
        <span class="pill">65‚Äì74% aten√ß√£o</span>
        <span class="pill">75‚Äì84% base</span>
        <span class="pill">85%+ forte</span>
      </div>
    </div>
  </div>`;
}

function mlSvgDonutMulti(items, title){
  // items: [{label, value, acc}]
  const list = (items||[]).filter(x=>x && x.value>0);
  const total = list.reduce((s,x)=>s+x.value,0) || 1;
  const r = 54;
  const c = 2 * Math.PI * r;

  // Build segments
  let offset = 0;
  const segs = list.map((x, i)=>{
    const frac = x.value/total;
    const len = frac * c;
    const dash = `${len} ${c-len}`;
    const seg = `
      <circle cx="80" cy="80" r="${r}" fill="none"
        stroke="hsl(${(i*47)%360} 70% 45%)"
        stroke-width="14" stroke-linecap="butt"
        stroke-dasharray="${dash}"
        stroke-dashoffset="${-offset}"
        transform="rotate(-90 80 80)"></circle>`;
    offset += len;
    return seg;
  }).join("");

  // Legend (top 8 by volume)
  const top = [...list].sort((a,b)=>b.value-a.value).slice(0,8);
  const legend = top.map((x,i)=>`
    <div class="row" style="justify-content:space-between;gap:10px;">
      <div style="min-width:0;display:flex;gap:8px;align-items:center;">
        <span style="display:inline-block;width:10px;height:10px;border-radius:3px;background:hsl(${(list.indexOf(x)*47)%360} 70% 45%);"></span>
        <span style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(x.label)}</span>
      </div>
      <div class="tiny muted" style="white-space:nowrap;">${Math.round(mlClamp(x.acc||0,0,100))}% ¬∑ ${x.value}</div>
    </div>
  `).join("");

  return `
  <div style="display:grid;grid-template-columns:180px 1fr;gap:14px;align-items:start;">
    <div style="display:flex;align-items:center;justify-content:center;">
      <svg width="160" height="160" viewBox="0 0 160 160" aria-label="${escapeHtml(title)}">
        <circle cx="80" cy="80" r="${r}" fill="none" stroke="rgba(15,23,42,.12)" stroke-width="14"></circle>
        ${segs}
        <text x="80" y="82" text-anchor="middle" font-size="12" font-weight="800" fill="rgba(15,23,42,.9)">${escapeHtml(title||"")}</text>
      </svg>
    </div>
    <div style="min-width:0;">
      <div class="tiny muted" style="margin-top:2px;">Fatia = <b>volume</b> de quest√µes ¬∑ texto = <b>% acerto</b> e volume</div>
      <div style="margin-top:10px;display:grid;gap:6px;">${legend || `<div class="note">Sem dados suficientes por disciplina ainda.</div>`}</div>
    </div>
  </div>`;
}

function mlComputeAccuracyStats(state){
  const range = mlGetPerfRange();
  const q0 = filterByExam(state.questions || []);
  const q = mlFilterQuestionsByRange(q0, range);
  const total = q.length;
  const correct = q.filter(x=>x.isCorrect===true).length;
  const acc = total ? (correct/total)*100 : 0;

  const by = {};
  for(const it of q){
    const d = (it.disc || "(sem disciplina)").trim() || "(sem disciplina)";
    if(!by[d]) by[d] = { label:d, total:0, correct:0 };
    by[d].total += 1;
    if(it.isCorrect===true) by[d].correct += 1;
  }
  const discs = Object.values(by).map(x=>({
    label: x.label,
    value: x.total,
    acc: x.total ? (x.correct/x.total)*100 : 0
  })).sort((a,b)=>b.value-a.value);

  return { total, correct, acc, discs, range };
}

function mlBandLabel(p){
  const v = mlClamp(Number(p)||0, 0, 100);
  if(v < 65) return {k:"critico", label:"Cr√≠tico", emoji:"üî¥"};
  if(v < 75) return {k:"atencao", label:"Aten√ß√£o", emoji:"üü°"};
  if(v < 85) return {k:"base", label:"Base", emoji:"üîµ"};
  return {k:"forte", label:"Forte", emoji:"üü¢"};
}

function mlRenderMotivationalInsights(state, stats){
  const el = document.getElementById("cognitiveInsights");
  if(!el) return;

  const s = stats || mlComputeAccuracyStats(state);
  const total = s.total||0;
  const acc = mlClamp(s.acc||0,0,100);

  if(!total){
    el.innerHTML = `<div class="card"><div class="section-title"><h3>‚ú® Diagn√≥stico r√°pido</h3></div><div class="note">Quando voc√™ come√ßar a registrar quest√µes (certo/errado), este painel vai te dizer exatamente onde ganhar mais pontos com menos esfor√ßo.</div></div>`;
    return;
  }

  const band = mlBandLabel(acc);
  const discs = (s.discs||[]).filter(x=>x.value>=5); // m√≠nimo para n√£o fazer barulho
  const avg = acc;

  // pick lows/highs (com m√≠nimo de amostra)
  const eligible = discs.filter(x=>x.value>=25);
  const lows = [...eligible].sort((a,b)=> (a.acc - b.acc)).slice(0,3);
  const highs = [...eligible].sort((a,b)=> (b.acc - a.acc)).slice(0,2);

  const strongest = highs[0];
  const weakest = lows[0];

  const delta = (d)=> Math.round((d.acc||0) - avg);

  const line1 = `üéØ Sua m√©dia geral est√° em <b>${Math.round(acc)}%</b> (${total} quest√µes). Voc√™ est√° na faixa <b>${band.label}</b> ${band.emoji}.`;
  let line2 = "";
  if(weakest){
    const d = Math.abs(delta(weakest));
    line2 = `‚ö° O caminho mais r√°pido para subir sua m√©dia: refor√ßar <b>${escapeHtml(weakest.label)}</b> (est√° ${d} pts abaixo da sua m√©dia).`;
  }else{
    line2 = `‚ö° Para subir mais r√°pido: aumente volume de quest√µes nas disciplinas com menos dados (m√≠n. 25 por disciplina para diagn√≥stico fino).`;
  }

  let line3 = "";
  if(strongest){
    const d = Math.abs(delta(strongest));
    line3 = `‚úÖ Ponto forte: <b>${escapeHtml(strongest.label)}</b> (‚âà ${d} pts acima da m√©dia). Use isso para manter confian√ßa e ganhar tempo.`;
  }

  // Build compact table-like list (top 8 by volume)
  const top = [...discs].sort((a,b)=>b.value-a.value).slice(0,8);
  const rows = top.map(x=>{
    const b = mlBandLabel(x.acc);
    const diff = Math.round((x.acc||0) - avg);
    const badge = (x.value>=25 && diff<=-8) ? "‚¨á Abaixo da m√©dia" : (x.value>=25 && diff>=8) ? "‚¨Ü Destaque" : "";
    const prio = (x.value>=25 && x.acc<75) ? "üìå Prioridade sugerida" : "";
    return `
      <div class="row" style="justify-content:space-between;gap:12px;padding:8px 0;border-top:1px dashed rgba(15,23,42,.10);">
        <div style="min-width:0;">
          <div style="font-weight:750;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(x.label)}</div>
          <div class="tiny muted">${b.emoji} ${b.label}${badge?` ¬∑ ${badge}`:""}${prio?` ¬∑ ${prio}`:""}</div>
        </div>
        <div style="text-align:right;white-space:nowrap;">
          <div style="font-weight:800;">${Math.round(x.acc||0)}%</div>
          <div class="tiny muted">${x.value} q</div>
        </div>
      </div>`;
  }).join("");

  el.innerHTML = `
    <div class="card">
      <div class="section-title"><h3>‚ú® Diagn√≥stico r√°pido (motivacional)</h3><span class="pill">automatico</span></div>
      <div class="note">${line1}</div>
      <div class="note" style="margin-top:8px;">${line2}</div>
      ${line3?`<div class="note" style="margin-top:8px;">${line3}</div>`:""}
    </div>

    <div class="card" style="margin-top:12px;">
      <div class="section-title"><h3>üìå Onde ganhar mais pontos</h3></div>
      <div class="tiny muted">Mostrando as disciplinas com maior volume (m√≠n. 5 quest√µes). ‚ÄúPrioridade sugerida‚Äù s√≥ aparece com 25+ quest√µes.</div>
      <div style="margin-top:8px;">${rows || `<div class="note">Ainda n√£o h√° dados suficientes por disciplina.</div>`}</div>
    </div>
  `;
}

function mlDateKey(d){
  try{
    const dt = (d instanceof Date) ? d : new Date(d);
    if(isNaN(dt)) return null;
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,"0");
    const da = String(dt.getDate()).padStart(2,"0");
    return `${y}-${m}-${da}`;
  }catch(e){ return null; }
}

function mlComputeDailySeries(state){
  const range = mlGetPerfRange();
  const q0 = filterByExam(state.questions || []);
  const q = mlFilterQuestionsByRange(q0, range);

  const byDay = {};
  for(const it of q){
    const k = mlDateKey(it.createdAt);
    if(!k) continue;
    if(!byDay[k]) byDay[k] = { day:k, total:0, correct:0 };
    byDay[k].total += 1;
    if(it.isCorrect===true) byDay[k].correct += 1;
  }
  const days = Object.values(byDay).sort((a,b)=> a.day.localeCompare(b.day));
  const series = days.map(x=>({
    day: x.day,
    total: x.total,
    acc: x.total ? (x.correct/x.total)*100 : 0
  }));

  // Downsample if too many points: group by week (ISO-ish) to keep chart readable
  if(series.length > 140){
    const byWeek = {};
    for(const p of series){
      const dt = new Date(p.day+"T00:00:00");
      const onejan = new Date(dt.getFullYear(),0,1);
      const week = Math.floor(((dt - onejan)/86400000 + onejan.getDay()+1)/7);
      const wk = `${dt.getFullYear()}-W${String(week).padStart(2,"0")}`;
      if(!byWeek[wk]) byWeek[wk] = { key:wk, total:0, correct:0, lastDay:p.day };
      byWeek[wk].total += p.total;
      byWeek[wk].correct += (p.acc/100)*p.total;
      byWeek[wk].lastDay = p.day;
    }
    const wkSeries = Object.values(byWeek).sort((a,b)=> a.lastDay.localeCompare(b.lastDay)).map(x=>({
      day: x.lastDay,
      total: x.total,
      acc: x.total ? (x.correct/x.total)*100 : 0,
      weekly: true
    }));
    return { series: wkSeries, range, isWeekly:true, rawCount: series.length };
  }

  return { series, range, isWeekly:false, rawCount: series.length };
}

function mlMovingAverage(series, windowSize){
  const w = Math.max(2, Number(windowSize)||7);
  const out = [];
  for(let i=0;i<series.length;i++){
    let total=0, correct=0;
    for(let j=Math.max(0,i-w+1); j<=i; j++){
      const p = series[j];
      total += (p.total||1);
      correct += (p.acc/100) * (p.total||1);
    }
    const acc = total ? (correct/total)*100 : 0;
    out.push({ day: series[i].day, acc });
  }
  return out;
}

function mlWeightedAccuracyLastDays(state, days){
  const n = Number(days)||7;
  const q0 = filterByExam(state.questions || []);
  const now = new Date();
  const cutoff = new Date(now.getTime() - n*24*60*60*1000);
  let total=0, correct=0;
  for(const it of q0){
    const t = it && it.createdAt ? new Date(it.createdAt) : null;
    if(!t || isNaN(t) || t < cutoff) continue;
    total += 1;
    if(it.isCorrect===true) correct += 1;
  }
  return total ? (correct/total)*100 : 0;
}

function mlRenderEvolucao(state){
  const canvas = document.getElementById("mlChartEvolucao");
  const momEl = document.getElementById("mlMomentum");
  if(!canvas) return;

  const ctx = canvas.getContext("2d");
  if(!ctx) return;

  const { series, isWeekly } = mlComputeDailySeries(state);
  const w = canvas.width = canvas.parentElement ? canvas.parentElement.clientWidth : canvas.width;
  const h = canvas.height; // keep given

  // Clear
  ctx.clearRect(0,0,w,h);

  if(!series || series.length < 2){
    ctx.fillStyle = "rgba(15,23,42,.65)";
    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText("Registre mais quest√µes para ver a evolu√ß√£o.", 10, 30);
    if(momEl) momEl.innerHTML = "üìå Dica: com 7‚Äì10 dias de registro j√° d√° para enxergar tend√™ncia.";
    return;
  }

  const ma = mlMovingAverage(series, 7);

  // Plot area
  const padL=36, padR=10, padT=10, padB=26;
  const pw = Math.max(10, w - padL - padR);
  const ph = Math.max(10, h - padT - padB);

  // Y scale fixed 0-100
  const y = (v)=> padT + (1 - mlClamp(v,0,100)/100) * ph;
  const x = (i)=> padL + (i/(series.length-1))*pw;

  // Grid lines (25/50/75)
  ctx.strokeStyle = "rgba(15,23,42,.10)";
  ctx.lineWidth = 1;
  [25,50,75].forEach(v=>{
    ctx.beginPath();
    ctx.moveTo(padL, y(v));
    ctx.lineTo(padL+pw, y(v));
    ctx.stroke();
  });

  // Axes labels (0 and 100 only)
  ctx.fillStyle = "rgba(15,23,42,.55)";
  ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText("100", 6, y(100)+4);
  ctx.fillText("0", 14, y(0)+4);

  // Raw line (lighter)
  ctx.strokeStyle = "rgba(15,23,42,.22)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  series.forEach((p,i)=>{
    const xx=x(i), yy=y(p.acc);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // Moving average line (stronger)
  ctx.strokeStyle = "rgba(15,23,42,.85)";
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ma.forEach((p,i)=>{
    const xx=x(i), yy=y(p.acc);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // X labels: start/end
  const start = series[0].day;
  const end = series[series.length-1].day;
  ctx.fillStyle = "rgba(15,23,42,.55)";
  ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(start, padL, h-8);
  const endW = ctx.measureText(end).width;
  ctx.fillText(end, padL+pw-endW, h-8);

  // Subtitle indicator
  ctx.fillStyle = "rgba(15,23,42,.55)";
  const label = isWeekly ? "Semanas (agregado)" : "Dias";
  ctx.fillText(label, padL, padT+12);

  // Momentum (weighted accuracies)
  const a7 = mlWeightedAccuracyLastDays(state, 7);
  const a30 = mlWeightedAccuracyLastDays(state, 30);
  const mom = a7 - a30;
  const momAbs = Math.round(mom*10)/10;
  let tag = "‚ûñ Est√°vel";
  if(mom >= 3) tag = "üìà Subindo";
  else if(mom <= -3) tag = "üìâ Caindo";
  if(momEl){
    momEl.innerHTML = `‚ö° Momentum: <b>${tag}</b> ¬∑ √∫ltimos 7d <b>${Math.round(a7)}%</b> vs 30d <b>${Math.round(a30)}%</b> (${momAbs>0?"+":""}${momAbs} pts)`;
  }
}

function mlRenderDonuts(state){
  const overallEl = document.getElementById("mlDonutOverall");
  const discEl = document.getElementById("mlDonutDisc");
  if(!overallEl || !discEl) return;

  const s = mlComputeAccuracyStats(state);
  const meta = s.total ? `Amostra: ${s.total} quest√µes ¬∑ ${s.correct} acertos` : "Sem quest√µes registradas ainda";
  overallEl.innerHTML = mlSvgDonutSingle(s.acc, "Acerto total", "geral", meta);

  // Use top N disciplines for ring clarity (max 12)
  const top = (s.discs || []).slice(0, 12);
  discEl.innerHTML = mlSvgDonutMulti(top, "Disciplinas");

  try{ mlRenderMotivationalInsights(state, s); }catch(e){}
  try{ mlRenderEvolucao(state); }catch(e){}
}

const PERF_USE_CONSISTENCY_KEY = "ML_PERF_USE_CONSISTENCY";

function mlGetUseConsistency(){
  try{
    const v = localStorage.getItem(mlKey(PERF_USE_CONSISTENCY_KEY));
    return v==="1";
  }catch(e){ return false; }
}
function mlSetUseConsistency(v){
  try{ localStorage.setItem(mlKey(PERF_USE_CONSISTENCY_KEY), v ? "1" : "0"); }catch(e){}
}

function mlStdDev(arr){
  const a = (arr||[]).filter(x=>typeof x==="number" && !isNaN(x));
  if(a.length<2) return 0;
  const m = a.reduce((s,x)=>s+x,0)/a.length;
  const v = a.reduce((s,x)=>s+Math.pow(x-m,2),0)/(a.length-1);
  return Math.sqrt(v);
}

function mlComputeConsistencyFromQuestions(state){
  const range = mlGetPerfRange();
  const q0 = filterByExam(state.questions || []);
  const q = mlFilterQuestionsByRange(q0, range);

  // by discipline -> by day -> {total, correct}
  const by = {};
  for(const it of q){
    const disc = (it.disc || "(sem disciplina)").trim() || "(sem disciplina)";
    const day = mlDateKey(it.createdAt);
    if(!day) continue;
    by[disc] = by[disc] || {};
    by[disc][day] = by[disc][day] || { total:0, correct:0 };
    by[disc][day].total += 1;
    if(it.isCorrect===true) by[disc][day].correct += 1;
  }

  const out = [];
  Object.keys(by).forEach(d=>{
    const days = Object.keys(by[d]).sort();
    const totals = days.map(k=>by[d][k].total);
    const accs = days.map(k=> by[d][k].total ? (by[d][k].correct/by[d][k].total)*100 : 0);

    const n = totals.reduce((s,x)=>s+x,0);
    const mean = n ? accs.reduce((s,a,i)=> s + a*totals[i], 0)/n : 0;

    // stddev of daily acc weighted loosely: approximate by duplicating weights capped
    const expanded = [];
    for(let i=0;i<accs.length;i++){
      const reps = Math.min(10, Math.max(1, Math.round(totals[i]/3)));
      for(let r=0;r<reps;r++) expanded.push(accs[i]);
    }
    const sd = mlStdDev(expanded);

    let band = "insuf";
    let emoji = "‚ö™";
    let label = "Sem dados suficientes";
    if(n >= 25){
      if(sd < 6){ band="stable"; emoji="üü¢"; label="Est√°vel"; }
      else if(sd < 12){ band="mid"; emoji="üü°"; label="Oscilando"; }
      else { band="high"; emoji="üî¥"; label="Inconsistente"; }
    }
    out.push({ disc:d, n, mean, sd, band, emoji, label });
  });

  return out.sort((a,b)=>b.n-a.n);
}

function mlRenderConsistency(state){
  const el = document.getElementById("mlConsistency");
  if(!el) return;

  const rows = mlComputeConsistencyFromQuestions(state);
  const filtered = rows.filter(x=>x.n>=5).slice(0, 12);

  if(!filtered.length){
    el.innerHTML = `<div class="note">Registre quest√µes com disciplina e certo/errado para ver sua consist√™ncia.</div>`;
    return;
  }

  const avg = mlComputeAccuracyStats(state).acc || 0;

  const htmlRows = filtered.map(x=>{
    const diff = Math.round((x.mean||0) - avg);
    const badge = (x.n>=25 && diff<=-8) ? "‚¨á Abaixo da m√©dia" : (x.n>=25 && diff>=8) ? "‚¨Ü Destaque" : "";
    const prio = (x.n>=25 && x.mean<75 && x.band==="high") ? "üìå Prioridade estrutural" : (x.n>=25 && x.mean<75) ? "üìå Prioridade sugerida" : "";
    return `
      <div class="row" style="justify-content:space-between;gap:12px;padding:10px 0;border-top:1px dashed rgba(15,23,42,.10);">
        <div style="min-width:0;">
          <div style="font-weight:780;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(x.disc)}</div>
          <div class="tiny muted">${x.emoji} ${x.label}${badge?` ¬∑ ${badge}`:""}${prio?` ¬∑ ${prio}`:""}</div>
        </div>
        <div style="text-align:right;white-space:nowrap;">
          <div style="font-weight:850;">${Math.round(x.mean||0)}%</div>
          <div class="tiny muted">œÉ‚âà${Math.round(x.sd||0)} ¬∑ ${x.n} q</div>
        </div>
      </div>`;
  }).join("");

  el.innerHTML = `
    <div class="tiny muted">Crit√©rio (com 25+ quest√µes): œÉ&lt;6 = est√°vel ¬∑ 6‚Äì12 = oscilando ¬∑ &gt;12 = inconsistente</div>
    <div style="margin-top:6px;">${htmlRows}</div>
  `;
}

function mlApplyLightModelCIntegration(){
  // S√≥ dispara rec√°lculo quando o usu√°rio pedir
  const st = store.getState();
  const exam = st.activeExam || st.profile?.mainExamId;
  if(!exam) return;
  try{ invalidateMatrixCacheForExam(exam); }catch(e){}
  try{ emitML("ML:PERF_SIGNAL", {exam, at:Date.now()}); }catch(e){}
}

function mlRenderCognitiveCharts(st, userId){
  const data = mlBuildCognitiveAnalytics(st, userId);
  const container = document.getElementById("app");
  if(!container) return;

// matrixDay √© calculado localmente nesta aba (n√£o depende do Cronograma)
let matrixDay = null;
try{
  const prof = (typeof loadProfile==="function") ? loadProfile() : null;
  const iso = (typeof dayKeyISO==="function") ? dayKeyISO(new Date()) : (new Date().toISOString().slice(0,10));
  matrixDay = (typeof ensureMatrixDay==="function") ? ensureMatrixDay(prof, iso) : null;
}catch(e){ matrixDay = null; }


  // dados m√≠nimos
  if(!data.any){
    document.getElementById("cognitiveGrid").innerHTML = `
      <div class="card"><div class="note">Ainda n√£o h√° dados suficientes. Registre algumas quest√µes com resultado/tempo e (se poss√≠vel) emo√ß√£o, foco e cansa√ßo.</div>
        ${matrixDay ? `
        <div class="card" style="box-shadow:none;border:1px solid var(--border); margin-top:12px">
          <div class="section-title">
            <div><b>Plano do dia (Matriz)</b><div class="note">${escapeHtml(matrixDay.weekday)} ‚Äî ${escapeHtml(matrixDay.dateISO)}</div></div>
            <span class="pill">${escapeHtml(matrixDay.blocks[0].phase||"")}</span>
          </div>
          <div style="margin-top:8px">
            <div><b>Bloco 1:</b> ${escapeHtml(matrixDay.blocks[0].disc)} ‚Äî ${escapeHtml(matrixDay.blocks[0].topic)}</div>
            <div><b>Bloco 2:</b> ${escapeHtml(matrixDay.blocks[1].disc)} ‚Äî ${escapeHtml(matrixDay.blocks[1].topic)}</div>
          </div>
          <div class="btnbar" style="margin-top:10px">
            <button class="btn" id="applyMatrixToTodayBtn">Aplicar ao Cronograma</button>
            <button class="btn" id="openMatrixTabBtn">Abrir Matriz</button>
          <button class="btn" id="openNotebookFromMatrixDayBtn">Abrir Caderno (Bloco 1)</button>
           </div>
        </div>` : ``}
</div>
    `;
    return;
  }

  function mkBar(canvasId, title, dataset, cacheKey){
    const ctx = document.getElementById(canvasId);
    if(!ctx) return;

    const existing = mlChartsCache[cacheKey];
    const cfg = {
      type:"bar",
      data:{ labels: dataset.labels, datasets:[{ label:title, data: dataset.values }]},
      options:{ responsive:true, animation:false, plugins:{ legend:{ display:false } }, scales:{ y:{ beginAtZero:true } } }
    };

    if(!existing){
      mlChartsCache[cacheKey] = new Chart(ctx, cfg);
    }else{
      existing.data.labels = dataset.labels;
      existing.data.datasets[0].data = dataset.values;
      existing.update();
    }
  }

  mkBar("mlChartErro","Erro (%) por Cansa√ßo", data.erroCansaco, "erro");
  mkBar("mlChartTempo","Tempo (s) por Emo√ß√£o", data.tempoEmocao, "tempo");
  mkBar("mlChartFoco","Precis√£o (%) por Foco", data.focoPrecisao, "foco");
  mkBar("mlChartFase","Precis√£o (%) por fase do bloco", data.faseBloco, "fase");

  // insights simples
  const maxErr = Math.max(...data.erroCansaco.values);
  const idxMax = data.erroCansaco.values.indexOf(maxErr);
  const emoSlow = data.tempoEmocao.labels.length ? data.tempoEmocao.labels[data.tempoEmocao.values.indexOf(Math.max(...data.tempoEmocao.values))] : "";
  const faseMin = Math.min(...data.faseBloco.values);
  const faseLabel = data.faseBloco.labels[data.faseBloco.values.indexOf(faseMin)];

  const insightEl = document.getElementById("cognitiveInsights");
  if(insightEl){
    insightEl.innerHTML = `
      <div class="card">
        <div class="section-title">
          <h3>Leitura autom√°tica</h3>
          <span class="pill">Hist√≥rico completo ‚Ä¢ Decay ativo</span>
        </div>
        <div class="hr"></div>
        <div class="note">
          <b>Erro √ó Cansa√ßo:</b> maior erro em cansa√ßo <b>${idxMax+1}</b> (${maxErr}%).
          <br/><b>Tempo √ó Emo√ß√£o:</b> maior tempo quando <b>${escapeHTML(emoSlow||"(sem)")}</b>.
          <br/><b>Fadiga no bloco:</b> pior fase <b>${faseLabel}</b> (${faseMin}%).
        </div>
      </div>
    `;
  }

  // marca como limpo
  const a = (st.mlAnalytics && typeof st.mlAnalytics==="object") ? st.mlAnalytics : {};
  const u = (a[userId] && typeof a[userId]==="object") ? a[userId] : {};
  if(u.dirty){
    const next = { ...st, mlAnalytics: { ...a, [userId]: { ...u, dirty:false } } };
    store.dispatch({ type: A.STATE_IMPORT, payload: next });
  }
}

function mountCognitive(){
  const st = store.getState();
  const userId = mlGetActiveUserId(st);
  app.innerHTML = `
    <div class="card">
      <div class="section-title">
        <h2>üß† Performance Cognitiva</h2>
        <span class="pill">Intelig√™ncia Visual</span>
      </div>
      <div class="note">Aqui voc√™ acompanha sua <b>evolu√ß√£o de acertos</b> e o <b>desempenho por disciplina</b> (baseado no seu hist√≥rico de quest√µes).</div>
      <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:10px;">
  <span class="tiny muted">Janela:</span>
  <button class="btn ghost" id="perfRangeAll">Tudo</button>
  <button class="btn ghost" id="perfRange30">√öltimos 30 dias</button>
  <button class="btn ghost" id="perfRange7">√öltimos 7 dias</button>
<div class="row" style="gap:10px;flex-wrap:wrap;margin-top:10px;">
  <label class="tiny muted" style="display:flex;align-items:center;gap:8px;cursor:pointer;">
    <input type="checkbox" id="perfUseConsistency" style="width:16px;height:16px;">
    Usar <b>Consist√™ncia</b> para sugerir prioridade no <b>Modelo C</b> (beta)
  </label>
  <button class="btn" id="perfRecalibrate">Recalibrar Matriz agora</button>
</div>
</div>
    </div>

    <div class="grid" style="margin-top:14px;grid-template-columns:1fr 1fr;gap:16px;align-items:stretch;">
      <div class="card">
        <div class="section-title"><h3>‚úÖ Evolu√ß√£o geral (acertos)</h3></div>
        <div id="mlDonutOverall" style="min-height:240px;"></div>
      </div>
      <div class="card">
        <div class="section-title"><h3>üìö Por disciplina</h3></div>
        <div id="mlDonutDisc" style="min-height:240px;"></div>
      </div>
    </div>

    
<div class="card" style="margin-top:14px;">
  <div class="section-title"><h3>üìà Evolu√ß√£o (linha bruta + m√©dia m√≥vel)</h3><span class="pill">canvas</span></div>
  <div class="tiny muted">A linha clara mostra o dia a dia. A linha forte mostra a tend√™ncia real (m√©dia m√≥vel 7 dias).</div>
  <div style="margin-top:10px;">
    <canvas id="mlChartEvolucao" height="160"></canvas>
  </div>
  <div id="mlMomentum" class="note" style="margin-top:10px;"></div>
</div>


<div class="card" style="margin-top:14px;">
  <div class="section-title"><h3>üîé Consist√™ncia por disciplina</h3><span class="pill">estabilidade</span></div>
  <div class="tiny muted">Mais importante que ‚Äúm√©dia alta‚Äù √© <b>const√¢ncia</b>. Aqui voc√™ v√™ quais disciplinas est√£o est√°veis vs oscilando.</div>
  <div id="mlConsistency" style="margin-top:10px;"></div>
</div>

<div id="cognitiveGrid" class="grid" style="margin-top:14px;grid-template-columns:1fr 1fr;gap:16px;">
      <div class="card"><div class="section-title"><h3>üìä Erro √ó Cansa√ßo</h3></div><canvas id="mlChartErro" height="130"></canvas></div>
      <div class="card"><div class="section-title"><h3>‚è± Tempo √ó Emo√ß√£o</h3></div><canvas id="mlChartTempo" height="130"></canvas></div>
      <div class="card"><div class="section-title"><h3>üéØ Foco √ó Precis√£o</h3></div><canvas id="mlChartFoco" height="130"></canvas></div>
      <div class="card"><div class="section-title"><h3>üîª Fase do Bloco</h3></div><canvas id="mlChartFase" height="130"></canvas></div>
    </div>

    <div id="cognitiveInsights" style="margin-top:16px;"></div>
  `;

  // Sem usu√°rio ativo: ainda mostramos donuts (por prova), mas avisamos sobre logs cognitivos
  if(!userId){
    const el = document.getElementById("cognitiveInsights");
    if(el) el.innerHTML = `<div class="card"><div class="note">Dica: selecione um usu√°rio no Perfil para ativar totalmente os indicadores de Performance Cognitiva (emo√ß√£o/foco/cansa√ßo). Os donuts acima funcionam com o hist√≥rico de quest√µes.</div></div>`;
  }

  try{ mlRenderDonuts(st); }catch(e){}
  try{ mlRenderConsistency(st); }catch(e){}

// Range toggle (7/30/all)
try{
  const r = mlGetPerfRange();
  const setActive = ()=>{
    const map = {all:"perfRangeAll", "30":"perfRange30", "7":"perfRange7"};
    Object.values(map).forEach(id=>{
      const b = document.getElementById(id);
      if(b){ b.classList.remove("primary"); }
    });
    const activeId = map[r];
    const b = document.getElementById(activeId);
    if(b){ b.classList.add("primary"); }
  };
  const wire = (id, val)=>{
    const b = document.getElementById(id);
    if(!b) return;
    b.onclick = ()=>{
      mlSetPerfRange(val);
      toast(`Janela: ${val==="all"?"Tudo":(val==="30"?"30 dias":"7 dias")} ‚úì`);
      // re-render donuts+insights
      const st2 = store.getState();
      mlRenderDonuts(st2);
        try{ mlRenderConsistency(st2); }catch(e){}
    };
  };
  wire("perfRangeAll","all");
  wire("perfRange30","30");
  wire("perfRange7","7");
  setActive();
// Modelo C (beta): usar consist√™ncia como sinal auxiliar (n√£o autom√°tico)
const cb = document.getElementById("perfUseConsistency");
if(cb){
  cb.checked = mlGetUseConsistency();
  cb.onchange = ()=>{
    mlSetUseConsistency(cb.checked);
    toast(cb.checked ? "Consist√™ncia ativada (beta) ‚úì" : "Consist√™ncia desativada ‚úì");
  };
}
const btn = document.getElementById("perfRecalibrate");
if(btn){
  btn.onclick = ()=>{
    mlApplyLightModelCIntegration();
    toast("Matriz recalibrada ‚úì (abra a Matriz/Cronograma para ver o novo plano)");
  };
}
}catch(e){}
  try{ mlRenderCognitiveCharts(st, userId); }catch(e){}
}

/* =========================
   UI Router + Views
========================= */

const store = createStore({ initialState: loadState(), reducer: rootReducer });
const app = document.getElementById("app");

const fatalBanner = document.getElementById("fatalBanner");
function showFatal(err, context){
  try{
    const msg = (err && err.message) ? err.message : String(err || "Erro desconhecido");
    const stack = (err && err.stack) ? err.stack : "";
    fatalBanner.style.display = "block";
    fatalBanner.innerHTML = `
      <div>‚ö†Ô∏è O SAPE encontrou um erro e interrompeu esta tela.</div>
      <div class="tiny">Contexto: ${escapeHtml(context||"-")}</div>
      <code>${escapeHtml(msg + (stack ? "\n\n" + stack : ""))}</code>
      <div class="actions">
        <button class="btn" id="fatalReload">Recarregar</button>
        <button class="btn" id="fatalExport">Backup (exportar)</button>
      </div>
      <div class="tiny">Dica: se ocorrer de novo, me envie um print do console + esta mensagem.</div>
    `;
    const r = document.getElementById("fatalReload");
    if(r) r.onclick = ()=> toast('Concurso ativo: ' + (EXAMS[sel.value]?.name || sel.value)); go('dashboard');
    const e = document.getElementById("fatalExport");
    if(e) e.onclick = ()=>{
      try{
        const data = JSON.stringify(store.getState(), null, 2);
        const blob = new Blob([data], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "SAPE_backup.json";
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 3000);
      }catch(ex){ alert("N√£o foi poss√≠vel exportar: " + ex); }
    };
  }catch(_){}
}
window.addEventListener("error", (ev)=>{
  // avoid infinite loop
  if(ev && ev.error) showFatal(ev.error, "window.error");
});
window.addEventListener("unhandledrejection", (ev)=>{
  const reason = ev && ev.reason ? ev.reason : new Error("Promise rejeitada sem reason");
  showFatal(reason, "unhandledrejection");
});


function safeCall(fn, context){
  try{ return fn(); }
  catch(err){ showFatal(err, context); return ()=>{}; }
}

function safeJSONParse(str, fallback=null){
  try{ return JSON.parse(str); }catch(e){ return fallback; }
}
/* =========================================================
   MODULE: core/debug
   ========================================================= */
function isDebug(){
  try{ return localStorage.getItem(DEBUG_KEY) === "1"; }catch{ return false; }
}
function setDebug(v){
  try{ localStorage.setItem(DEBUG_KEY, v ? "1" : "0"); }catch{}
}

function getAggro(){
  try{
    const v = Number(localStorage.getItem(AGGRO_KEY));
    if(!Number.isFinite(v)) return 1.0;
    return Math.max(0.5, Math.min(1.5, v));
  }catch{ return 1.0; }
}
function setAggro(v){
  try{ localStorage.setItem(AGGRO_KEY, String(v)); }catch{}
}
function dlog(...args){ if(isDebug()) console.log("[SAPE]", ...args); }
function dwarn(...args){ if(isDebug()) console.warn("[SAPE]", ...args); }
function invariant(cond, msg){
  if(!cond) throw new Error("Invariant failed: " + (msg || "(no message)"));
}

let currentTab = "dashboard";
let currentUnmount = null;

document.querySelectorAll(".tab").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    go(btn.dataset.tab);
  }, { passive:true });
});

function go(tab){
  // aba Pegadinhas foi unificada no Caderno (Registrar Erro)
  if(tab==="traps") tab="notebook";

try{
  const p = loadProfile() || {};
  const gateOk = isGateComplete(p);
  if(!gateOk && route!=="onboarding"){
    route = "onboarding";
  }
}catch(e){}
// Gate: antes de usar o sistema, o usu√°rio precisa cadastrar Nome + Concurso + Data de in√≠cio
  const p = loadProfile();
  if(tab !== "profile" && !isProfileComplete(p)){
    toast("Complete o Perfil: Nome + Concurso + Data de in√≠cio para liberar as demais abas.");
    tab = "profile";
    // ativa visualmente a aba Perfil
    document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
    const profBtn = document.querySelector('.tab[data-tab="profile"]');
    if(profBtn) profBtn.classList.add("active");
  }
  currentTab = tab;
  if(typeof currentUnmount === "function") currentUnmount();
  if(tab === "dashboard") currentUnmount = safeCall(()=>mountDashboard(), "mountDashboard");
  else if(tab === "schedule") currentUnmount = safeCall(()=>mountSchedule(), "mountSchedule");
  else if(tab === "matrix") currentUnmount = safeCall(()=>mountMatrix(), "mountMatrix");
  else if(tab === "sim") currentUnmount = safeCall(()=>mountSim(), "mountSim");
  else if(tab === "compare") currentUnmount = safeCall(()=>mountCompare(), "mountCompare");
  else if(tab === "radar") currentUnmount = safeCall(()=>mountRadar(), "mountRadar");
  else if(tab === "profile") currentUnmount = safeCall(()=>mountProfile(), "mountProfile");
  else if(tab === "questions") currentUnmount = safeCall(()=>mountQuestions(), "mountQuestions");
  else if(tab === "cognitive") currentUnmount = safeCall(()=>mountCognitive(), "mountCognitive");
  else if(tab === "notebook") currentUnmount = safeCall(()=>mountNotebook(), "mountNotebook");
  else if(tab === "settings") currentUnmount = safeCall(()=>mountSettings(), "mountSettings");
  else currentUnmount = safeCall(()=>mountDashboard(), "mountDashboard");
}

/* =========================================================
   MODULE: engine/recommendations
   ========================================================= */
function recommendNextActions(state, disc){
  const ex = explainDisciplineWeight(state, disc);
  const actions = [];

  // Suggested questions volume
  if(ex.planInfo){
    const remaining = Math.max(0, (ex.planInfo.goal||0) - (ex.planInfo.done||0));
    if(remaining > 0){
      const q = Math.min(20, Math.max(6, Math.round(remaining * 0.6)));
      actions.push({ title: `Fazer ${q} quest√µes`, detail: `Para reduzir o atraso da meta (${ex.planInfo.done}/${ex.planInfo.goal}).` });
    }else{
      actions.push({ title: "Manter com 6 quest√µes", detail: "Meta batida ‚Äî s√≥ manuten√ß√£o para n√£o esfriar." });
    }
    if(ex.planInfo.trend < 0){
      actions.push({ title: "Revisar o assunto que mais erra", detail: "Tend√™ncia negativa: refazer 1 bloco de teoria + 5 quest√µes." });
    }
  }else{
    actions.push({ title: "Fazer 10 quest√µes", detail: "Disciplina fora do top 4 ‚Äî use para alimentar dados e detectar risco." });
  }

  // Suggested error reviews (based on overdue/errors)
  const overdue = ex.metrics.overdue || 0;
  const errs = ex.metrics.errors || 0;
  if(overdue > 0){
    actions.push({ title: `Revisar ${Math.min(3, overdue)} erros atrasados`, detail: "Prioridade alta: atraso vira perda de ponto." });
  }else if(errs > 0){
    actions.push({ title: "Revisar 1‚Äì2 erros recentes", detail: "Consolida acerto antes de acumular." });
  }

  // Traps
  if((ex.metrics.traps||0) < 3){
    actions.push({ title: "Salvar 2 pegadinhas", detail: "Aumenta seu ‚Äúradar‚Äù e melhora o treino." });
  }else{
    actions.push({ title: "Rodar 1 treino de pegadinhas", detail: "10 itens r√°pidos para ganhar seguran√ßa." });
  }

  return { ex, actions: actions.slice(0,3) };
}
function mountDashboard(){
  let focusIdx = 0;

  function render(){
    const state = store.getState();
    const activeExam = state.activeExam || getActiveExam();
    const mc = computeApprovalModeloC(state, activeExam);
    const decisions = computeDecisionOfDay(state, activeExam);
    const k = selectKpis(state);
    const questions = filterByExam(state.questions || []);
    const errors = filterByExam(state.errors || []);
    const traps = filterByExam(state.traps || []);
    const queue = selectReviewQueue(state, 12);

    if(focusIdx >= queue.length) focusIdx = 0;

    // --- tend√™ncia simples (√∫ltimas 10 vs anteriores 10 quest√µes respondidas)
    const answered = (questions||[]).filter(q=> q.isCorrect !== null);
    const last10 = answered.slice(0,10);
    const prev10 = answered.slice(10,20);

    function acc(list){
      if(!list.length) return 0;
      const right = list.filter(q=> q.isCorrect).length;
      return Math.round((right/list.length)*100);
    }
    const accLast = acc(last10);
    const accPrev = acc(prev10);
    const trend = accLast - accPrev;

    // --- tempo m√©dio por quest√£o
    const withTime = answered.filter(q=> q.timeMin);
    const avgTime = withTime.length 
      ? Math.round(withTime.reduce((a,b)=>a + Number(b.timeMin||0),0)/withTime.length)
      : 0;

    // --- meta semanal autom√°tica
    const weekGoal = Math.max(20, Math.round(answered.length * 0.15));
    const weekProgress = Math.min(answered.length, weekGoal);

    // heatmap per discipline (from questions + errors + traps)
    const discMap = new Map();
    function discKey(d){ return (d||"(sem disciplina)").trim() || "(sem disciplina)"; }
    function ensureDisc(d){
      const key = discKey(d);
      if(!discMap.has(key)) discMap.set(key, { disc:key, qAns:0, qRight:0, qWrong:0, errors:0, overdue:0, traps:0 });
      return discMap.get(key);
    }
    for(const q of questions){
      const row = ensureDisc(q.disc);
      if(q.isCorrect === null) continue;
      row.qAns++;
      if(q.isCorrect) row.qRight++; else row.qWrong++;
    }
    const today0 = startOfDay(new Date());
    for(const e of errors){
      const row = ensureDisc(e.disc);
      row.errors++;
      if(e.nextReviewAt){
        const d = new Date(e.nextReviewAt);
        if(!Number.isNaN(d.getTime()) && d < today0) row.overdue++;
      }
    }
    for(const t of traps){
      const row = ensureDisc(t.disc);
      row.traps++;
    }

    const heatRows = Array.from(discMap.values()).map(r=>{
      const a = r.qAns ? Math.round((r.qRight/r.qAns)*100) : 0;
      const risk = (r.overdue*3) + (r.qWrong*2) + (r.errors) + Math.round(r.traps*1.2);
      return { ...r, acc:a, risk };
    }).sort((a,b)=> (b.risk - a.risk) || (a.acc - b.acc));

    // --- metas adaptativas por disciplina (distribui a meta semanal pelo risco/baixa acur√°cia)
    const goalRows = (()=>{
      const total = weekGoal;
      const rows = heatRows
        .filter(r=> r.disc && r.disc !== "(sem disciplina)")
        .slice(0, 12);

      if(!rows.length){
        return { total, items: [], critical:null, stable:null, ok:null };
      }

      // peso = risco (m√≠n.1) + penalidade por baixa acur√°cia
      const weights = rows.map(r=>{
        const risk = Math.max(1, Number(r.risk||0));
        const accPenalty = Math.max(0, 100 - Number(r.acc||0)); // 0..100
        const baseW = risk + Math.round(accPenalty * 0.5); // acur√°cia pesa 50%
        const w = baseW * getDiscWeight(activeExam, r.disc);
        return { disc:r.disc, risk, acc:r.acc, w, baseW };
      });

      const sumW = weights.reduce((a,b)=>a+b.w,0) || 1;

      // aloca√ß√£o inicial arredondada
      let items = weights.map(x=>{
        const raw = (x.w / sumW) * total;
        return { ...x, goal: Math.max(0, Math.round(raw)) };
      });

      // ajuste para bater exatamente total (corrige erros de arredondamento)
      let diff = total - items.reduce((a,b)=>a+b.goal,0);
      // ordenar por maior peso para distribuir diff
      items.sort((a,b)=> b.w - a.w);
      let idx2 = 0;
      while(diff !== 0 && items.length){
        if(diff > 0){
          items[idx2 % items.length].goal += 1;
          diff -= 1;
        }else if(diff < 0){
          // tirar de quem tem mais meta, sem zerar
          const j = idx2 % items.length;
          if(items[j].goal > 0){
            items[j].goal -= 1;
            diff += 1;
          }
        }
        idx2++;
        if(idx2 > 5000) break; // safety
      }

      // classificar "cr√≠tica / est√°vel / sob controle"
      const sortedRisk = [...items].sort((a,b)=> (b.risk - a.risk) || (a.acc - b.acc));
      const critical = sortedRisk[0] || null;
      const ok = [...items].sort((a,b)=> (b.acc - a.acc) || (a.risk - b.risk))[0] || null;
      const stable = sortedRisk[Math.min(sortedRisk.length-1, Math.floor(sortedRisk.length/2))] || null;

      // voltar para exibi√ß√£o por risco
      items = sortedRisk;

      return { total, items, critical, stable, ok };
    })();


    const focusItem = queue[focusIdx] || null;

    app.innerHTML = `
      <div class="card">
        
        <div class="statcard" style="margin-bottom:16px;">
          <div class="h">Concurso ativo</div>
          <div style="display:flex;align-items:center;gap:12px;margin-top:8px;flex-wrap:wrap;">
            <select id="examSelector" class="input">
              ${Object.entries(EXAMS).map(([id,ex]) =>
                `<option value="${id}" ${getActiveExam()===id?'selected':''}>${ex.name}</option>`
              ).join("")}
            </select>
            <span class="badge">üéØ ${EXAMS[getActiveExam()].name}</span>
          </div>
        </div>
    
        <div class="section-title">
          <h2>Dashboard Estrat√©gico</h2>
          <span class="pill">Estado: <b>V${state.version}</b></span>
        </div>

        <div class="kpis">
          <div class="kpi lav"><div class="n">${k.totalErrors}</div><div class="t">Erros</div></div>
          <div class="kpi pink"><div class="n">${k.overdue}</div><div class="t">Atrasadas</div></div>
          <div class="kpi yellow"><div class="n">${avgTime || 0}m</div><div class="t">Tempo m√©dio</div></div>
          <div class="kpi blue"><div class="n">${k.acc || 0}%</div><div class="t">Acur√°cia</div></div>
          <div class="kpi"><div class="n">${trend>0?"+":""}${trend}%</div><div class="t">Tend√™ncia</div></div>
        </div>


<div class="statcard" style="margin-top:12px;background:linear-gradient(135deg,#dbeafe,#ede9fe);border-color:rgba(99,102,241,.15);">
  <div class="h">Camada de Intelig√™ncia de Aprova√ß√£o (Modelo C)</div>
  <div class="v">${mc.prob}% ‚Ä¢ Previsto ${mc.predicted}% (meta ${mc.target}%)</div>
  <div class="note">Gap: <b>${mc.delta}</b> pts ‚Ä¢ Amostra: ${mc.sample} ‚Ä¢ Conf.: ${mc.conf}% ‚Ä¢ Corte ref: ${mc.cutoff}% ‚Ä¢ Estrutura +${mc.structureAdj} ‚Ä¢ Risco -${Math.round(mc.risk.pen)}</div>
  <div class="actions" style="margin-top:8px;">
    <button class="btn" id="goCompareFromDash">Ajustar no Comparativo</button>
  </div>
</div>

<div class="statcard" style="margin-top:12px;">
  <div class="h">Decis√£o do Dia</div>
  <div class="tiny muted" style="margin-top:8px;">
    ${(decisions||[]).map(d=>`<div>‚Ä¢ ${escapeHtml(d.text)}</div>`).join("")}
  </div>
</div>

        <div class="hr"></div>

        <div class="statcard">
          <div class="h">Meta semanal autom√°tica</div>
          <div class="v">${weekProgress}/${weekGoal} quest√µes</div>
          <div class="bar" style="margin-top:8px;">
            <div style="width:${Math.min(100,Math.round((weekProgress/weekGoal)*100))}%;"></div>
          </div>
          <div class="tiny muted" style="margin-top:8px;">
            Meta baseada em ~15% do seu volume total atual (m√≠nimo 20).
          </div>
        </div>

        <div class="hr"></div>


        <details open class="compact">
          <summary><span>Metas adaptativas por disciplina (semana)</span><span class="chev">‚åÑ</span></summary>
          <div style="margin-top:10px;">
            ${goalRows.items.length ? `
              <div class="note">
                <div class="tiny muted"><b>Cr√≠tica:</b> ${escapeHtml(goalRows.critical?.disc || "-")} ‚Ä¢ <b>Est√°vel:</b> ${escapeHtml(goalRows.stable?.disc || "-")} ‚Ä¢ <b>Sob controle:</b> ${escapeHtml(goalRows.ok?.disc || "-")}</div>
                <div class="tiny muted">Distribui√ß√£o baseada em risco + baixa acur√°cia. (Ajusta automaticamente conforme voc√™ registra quest√µes/erros.)</div>
              </div>

              <table style="margin-top:10px;">
                <thead><tr><th>Disciplina</th><th>Meta</th><th>Risco</th><th>Acur√°cia</th></tr></thead>
                <tbody>
                  ${goalRows.items.map(r=>`
                    <tr>
                      <td><b>${escapeHtml(r.disc)}</b></td>
                      <td><span class="badge overdue">${r.goal}</span></td>
                      <td><span class="badge">${r.risk}</span></td>
                      <td>
                        <span class="badge">${r.acc}%</span>
                        <div class="bar" style="margin-top:6px;"><div style="width:${r.acc}%;"></div></div>
                      </td>
                    </tr>
                  `).join("")}
                </tbody>
              </table>
            ` : `<div class="note">Registre quest√µes/erros para o sistema calcular metas por disciplina.</div>`}
          </div>
        </details>

        <div class="hr"></div>

        <div class="section-title">
          <h3>Revisar agora</h3>
          <span class="pill">Fila: <b>${queue.length}</b></span>
        </div>
        <div class="note">Prioridade inteligente: atrasos/hoje + reincid√™ncia + baixa acur√°cia + perigo.</div>

        <details open class="compact">
          <summary><span>Modo foco (1 por vez)</span><span class="chev">‚åÑ</span></summary>
          <div style="margin-top:10px;">
            ${focusItem ? `
              <div class="statcard" style="background:var(--card);">
                <div class="h">Item ${focusIdx+1}/${queue.length}</div>
                <div class="v" style="font-size:16px;margin-top:8px;">
                  ${focusItem.kind === "error" ? `<span class="badge overdue">erro</span>` : `<span class="badge">trap</span>`}
                  <span style="margin-left:8px;"><b>${escapeHtml(focusItem.disc || "(sem disciplina)")}</b></span>
                </div>
                <div class="tiny muted" style="margin-top:6px;">${escapeHtml(focusItem.topic || "(sem assunto)")}</div>
                <div class="tiny muted">banca: ${escapeHtml(focusItem.bank || "-")} ‚Ä¢ score: ${Math.round(focusItem.score)}</div>

                ${focusItem.kind === "error" && focusItem.meta ? `
                  <div class="note" style="margin-top:10px;">
                    <div class="tiny muted"><b>Causa:</b> ${escapeHtml(focusItem.meta.cause || "-")}</div>
                    ${focusItem.meta.notes ? `<div class="tiny muted" style="margin-top:6px;"><b>Notas:</b><br>${escapeHtml(focusItem.meta.notes)}</div>` : ""}
                  </div>
                ` : ""}

                ${focusItem.kind === "error" ? (()=>{
                  const qs = (state.questions||[]).filter(q=> 
                    (q.disc||"").trim() === (focusItem.disc||"").trim() &&
                    (q.topic||"").trim() === (focusItem.topic||"").trim()
                  );
                  if(!qs.length) return "";
                  const last = qs.slice(0,3);
                  return `<div class="note" style="margin-top:10px;">
                    <div class="tiny muted"><b>Quest√µes recentes do mesmo assunto:</b></div>
                    ${last.map(q=>`
                      <div class="tiny muted" style="margin-top:4px;">
                        ${q.isCorrect===true?"‚úì":q.isCorrect===false?"‚úó":"‚Ä¢"} 
                        ${escapeHtml(q.source||"sem fonte")}
                      </div>
                    `).join("")}
                  </div>`;
                
// Concurso ativo (Dashboard) ‚Äî persistir automaticamente
try{
  const examSel = document.getElementById("examSelector");
  if(examSel){
    examSel.value = getActiveExam();
    examSel.onchange = ()=>{
      const id = examSel.value;
      setActiveExamAndSyncProfile(id);
      toast("Concurso ativo: " + (EXAMS[id]?.name || id));
      // re-render para atualizar badge e KPIs por concurso
      go("dashboard");
    };
  }
}catch(e){}
})() : ""}

                <div class="btnbar" style="margin-top:12px;">
                  ${focusItem.kind === "error" ? `
                    <button class="btn primary" data-act="focusReviewed" data-id="${focusItem.id}">Marcar revisado ‚úì</button>
                    <button class="btn" data-act="focusToSchedule">Abrir cronograma</button>
                  ` : `
                    <button class="btn primary" data-act="focusOpenTrap" data-id="${focusItem.id}">Abrir pegadinha</button>
                    <button class="btn" data-act="focusStartSim">Treino (10)</button>
                  `}
                  <button class="btn" data-act="focusNext">Pr√≥ximo ‚Üí</button>
                </div>
              </div>
            ` : `<div class="note">Sem itens suficientes ainda.</div>`}
          </div>
        </details>

        <div class="hr"></div>

        <details class="compact">
          <summary><span>Fila completa (top 12)</span><span class="chev">‚åÑ</span></summary>
          <div style="margin-top:10px;">
            ${queue.length ? `
              <table>
                <thead><tr><th>Tipo</th><th>Item</th><th>Score</th><th>A√ß√µes</th></tr></thead>
                <tbody>
                  ${queue.map(it=>`
                    <tr>
                      <td>${it.kind === "error" ? `<span class="badge overdue">erro</span>` : `<span class="badge">trap</span>`}</td>
                      <td>
                        <div><b>${escapeHtml(it.disc || "(sem disciplina)")}</b></div>
                        <div class="tiny muted">${escapeHtml(it.topic || "(sem assunto)")}</div>
                      </td>
                      <td><span class="badge">${Math.round(it.score)}</span></td>
                      <td>
                        <div class="actions">
                          ${it.kind === "error" ? `
                            <button class="btn" data-act="revNow" data-id="${it.id}">Revisado</button>
                            <button class="btn" data-act="goSchedule">Cronograma</button>
                          ` : `
                            <button class="btn" data-act="goTraps" data-id="${it.id}">Abrir</button>
                            <button class="btn" data-act="startSim">Treino</button>
                          `}
                        </div>
                      </td>
                    </tr>
                  `).join("")}
                </tbody>
              </table>
            ` : `<div class="note">Sem itens suficientes ainda.</div>`}
          </div>
        </details>

        <div class="hr"></div>

        <details open class="compact">
          <summary><span>Heatmap por disciplina (risco)</span><span class="chev">‚åÑ</span></summary>
          <div style="margin-top:10px;">
            ${heatRows.length ? `
              <table>
                <thead><tr><th>Disciplina</th><th>Risco</th><th>Acur√°cia</th><th>Erros</th><th>Pegadinhas</th></tr></thead>
                <tbody>
                  ${heatRows.slice(0,12).map(r=>`
                    <tr>
                      <td><b>${escapeHtml(r.disc)}</b></td>
                      <td><span class="badge overdue">${r.risk}</span><div class="tiny muted">atraso:${r.overdue} ‚Ä¢ errados:${r.qWrong}</div></td>
                      <td>
                        <span class="badge">${r.acc}%</span>
                        <div class="bar" style="margin-top:6px;"><div style="width:${r.acc}%;"></div></div>
                      </td>
                      <td><span class="badge">${r.errors}</span></td>
                      <td><span class="badge">${r.traps}</span></td>
                    </tr>
                  `).join("")}
                </tbody>
              </table>
              <div class="tiny muted" style="margin-top:8px;">Ordenado por risco (perda de pontos).</div>
            ` : `<div class="note">Registre quest√µes/erros para ver o heatmap.</div>`}
          </div>
        </details>

      </div>
    `;

    // actions
    const ag = app.querySelector('#aggro');
    if(ag){
      const val = app.querySelector('#aggroVal');
      ag.oninput = ()=>{ if(val) val.textContent = Number(ag.value).toFixed(2) + 'x'; };
      ag.onchange = ()=>{ setAggro(Number(ag.value)); toast('Agressividade: ' + Number(ag.value).toFixed(2) + 'x'); 
function migrateExamIds(){
  try{
    const raw = localStorage.getItem("SAPE_STATE");
    if(!raw) return;
    const state = JSON.parse(raw);

    let changed = false;

    function ensure(list){
      if(!Array.isArray(list)) return;
      for(const item of list){
        if(!item.examId){
          item.examId = "TRT_AJ";
          changed = true;
        }
      }
    }

    ensure(state.questions);
    ensure(state.errors);
    ensure(state.traps);

    if(changed){
      localStorage.setItem("SAPE_STATE", JSON.stringify(state));
    }
  }catch{}
}

migrateExamIds();


  const sel = document.getElementById('examSelector');
  if(sel){
    sel.onchange = ()=>{
      setActiveExamAndSyncProfile(sel.value);
      toast('Concurso ativo: ' + (EXAMS[sel.value]?.name || sel.value)); go('dashboard');
    };

}
const gc = document.getElementById('goCompareFromDash');
if(gc){
  gc.onclick = ()=>{
    document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
    const tb = document.querySelector('.tab[data-tab="compare"]');
    if(tb) tb.classList.add('active');
    go('compare');
  };
}
    // ---- Bloco 0: disciplinas do dia ----
    try{
      const allDiscs = uniqueDisciplinesForDayPicker(state);
      const pref = loadTodayDisciplines();
      const selects = [document.getElementById("dayDisc1"), document.getElementById("dayDisc2"), document.getElementById("dayDisc3")].filter(Boolean);
      const makeOptions = (sel, val)=>{
        sel.innerHTML = `<option value="">${allDiscs.length? "(nenhuma)" : "(sem lista ‚Äî selecione um concurso no Perfil)"}</option>` + allDiscs.map(d=>`<option value="${escapeHtml(d)}">${escapeHtml(d)}</option>`).join("");
        sel.value = val || "";
      };
      makeOptions(selects[0], pref[0]);
      makeOptions(selects[1], pref[1]);
      makeOptions(selects[2], pref[2]);

      
      const autoBtn = document.getElementById("autoSuggestDayDiscsBtn");
      if(autoBtn){
        autoBtn.onclick = ()=>{
          const suggested = suggestDisciplinesFromHistory(10, 3);
          // fallback: se n√£o tiver hist√≥rico, sugere as 3 primeiras existentes
          const base = (suggested && suggested.length) ? suggested : allDiscs.slice(0,3);
          selects.forEach((s,idx)=>{ if(s) s.value = base[idx] || ""; });
          toast("Sugest√£o aplicada ‚úì");
          // n√£o salva automaticamente ‚Äî voc√™ confirma clicando em salvar
          renderBlocoZero();
        };
      }

      

// Integra√ß√£o Matriz -> Cronograma (fix v3.0):
// - Bot√£o "Aplicar ao Cronograma" funciona SEM depender do Auto-sugerir
// - Salva as 2 disciplinas do dia vindas da Matriz
// - Preenche os dropdowns Disciplina 1/2
// - Dispara recalculo do Bloco 0 (renderBlocoZero)
// - Prepara o Caderno para abrir j√° no t√≥pico do Bloco 1
try{
  const DRAFT_KEY = "SAPE_NB_DRAFT";
  function setNotebookDraftFromMatrix(){
    if(!matrixDay || !matrixDay.blocks || !matrixDay.blocks[0]) return;
    const draft = {
      disc: matrixDay.blocks[0].disc || "",
      topic: matrixDay.blocks[0].topic || "",
      mode: "normal",
      from: "matrixDay",
      createdAt: new Date().toISOString()
    };
    try{ sessionStorage.setItem(DRAFT_KEY, JSON.stringify(draft)); }catch(e){}
  }

  // Auto-aplica SOMENTE se n√£o houver nada salvo hoje (n√£o sobrescreve escolhas do usu√°rio)
  const todayKey = dayKeyISO(new Date());
  const already = loadDayDisciplinesByKey(todayKey) || [];
  if((!already || !already.length) && matrixDay && matrixDay.blocks){
    const dsAuto = [matrixDay.blocks[0].disc, matrixDay.blocks[1].disc].filter(Boolean);
    if(dsAuto.length){
      saveTodayDisciplines(dsAuto);
          try{ saveTodayPlan({ source:"matrix", blocks: (matrixDay.blocks||[]).slice(0,2).map(b=>({disc:b.disc||"", topic:b.topic||""})), updatedAt:new Date().toISOString() }); }catch(e){}
          const selsAuto = app.querySelectorAll('select[data-day-disc]');
      if(selsAuto && selsAuto.length){
        dsAuto.forEach((d,i)=>{ if(selsAuto[i]) selsAuto[i].value = d; });
      }
      // Draft para o Caderno no Bloco 1 (n√£o navega)
      setNotebookDraftFromMatrix();
    }
  }

  const btnApply = document.getElementById("applyMatrixToTodayBtn");
  if(btnApply){
    btnApply.onclick = ()=>{
      if(!matrixDay || !matrixDay.blocks){ toast("Sem Matriz para hoje."); return; }
      const ds = [matrixDay.blocks[0].disc, matrixDay.blocks[1].disc].filter(Boolean);
      saveTodayDisciplines(ds);
          try{ saveTodayPlan({ source:"matrix", blocks: (matrixDay.blocks||[]).slice(0,2).map(b=>({disc:b.disc||"", topic:b.topic||""})), updatedAt:new Date().toISOString() }); }catch(e){}
          const sels = app.querySelectorAll('select[data-day-disc]');
      if(sels && sels.length){
        ds.forEach((d,i)=>{ if(sels[i]) sels[i].value = d; });
      }
      // prepara o Caderno para abrir em Bloco 1 (disc + t√≥pico)
      setNotebookDraftFromMatrix();
      toast("Cronograma alinhado com a Matriz ‚úì");
      renderBlocoZero();
    };
  }

  const btnOpen = document.getElementById("openMatrixTabBtn");
  if(btnOpen){
    btnOpen.onclick = ()=>{ go("matrix"); };
  }

  const btnOpenNb = document.getElementById("openNotebookFromMatrixDayBtn");
  if(btnOpenNb){
    btnOpenNb.onclick = ()=>{
      setNotebookDraftFromMatrix();
      go("notebook");
    };
  }
}catch(e){}
const saveBtn = document.getElementById("saveDayDiscsBtn");
      const clearBtn = document.getElementById("clearDayDiscsBtn");
      if(saveBtn){
        saveBtn.onclick = ()=>{
          const vals = selects.map(s=>s.value).filter(Boolean);
          // dedup preserve order
          const seen = new Set();
          const out = [];
          vals.forEach(v=>{ if(!seen.has(v)){ seen.add(v); out.push(v); } });
          saveTodayDisciplines(out);
          toast("Disciplinas de hoje salvas ‚úì");
          renderBlocoZero();
        };
      }
      if(clearBtn){
        clearBtn.onclick = ()=>{
          saveTodayDisciplines([]);
          selects.forEach(s=>{ if(s) s.value=""; });
          toast("Disciplinas de hoje limpas");
          renderBlocoZero();
        };
      }
    }catch(e){}

render();
 };
    }
    // presets
    app.querySelectorAll('button[data-agg]').forEach(b=>{
      b.onclick = ()=>{
        const v = Number(b.getAttribute('data-agg'));
        setAggro(v);
        const ag = app.querySelector('#aggro');
        const val = app.querySelector('#aggroVal');
        if(ag) ag.value = String(v);
        if(val) val.textContent = v.toFixed(2) + 'x';
        toast('Agressividade: ' + v.toFixed(2) + 'x');
        render();
      };
    });

    // why-weight explain
    const whyBox = app.querySelector('#whyBox');
    function renderWhy(disc){
      const { ex, actions } = recommendNextActions(store.getState(), disc);
      if(!whyBox) return;
      whyBox.style.display = 'block';
      const lines = (ex.lines||[]).map(l=>{
        const sign = (l.value>=0?'+':'');
        const v = (typeof l.value==='number') ? (sign + l.value.toFixed(2)) : String(l.value);
        return `<div class="tiny muted" style="margin-top:6px;"><b>${escapeHtml(l.label)}:</b> ${escapeHtml(v)} <span class="tiny muted">(${escapeHtml(l.detail||'')})</span></div>`;
      }).join('');
      const acts = (actions||[]).map(a=>{
        const t = (a.title||"").toLowerCase();
        let act = "questions";
        if(t.includes("erro")) act = "errors";
        else if(t.includes("cronograma")) act = "schedule";
        else if(t.includes("pegad")) act = "traps";
        else if(t.includes("quest")) act = "questions";
        return `
          <div class="note" style="margin-top:10px;">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
              <div>
                <div class="tiny muted"><b>${escapeHtml(a.title)}</b></div>
                <div class="tiny muted">${escapeHtml(a.detail||"")}</div>
              </div>
              <button class="btn primary" data-plan-act="${act}" data-plan-disc="${escapeHtml(ex.disc)}">Fazer agora</button>
            </div>
          </div>
        `;
      }).join('');

      whyBox.innerHTML = `
        <div class="h">${escapeHtml(ex.disc)} ‚Ä¢ peso final <span class="badge">${Number(ex.weight||1).toFixed(2)}x</span></div>
        <div class="tiny muted">agressividade: ${Number(ex.aggro||1).toFixed(2)}x ‚Ä¢ risco:${ex.metrics.risk} ‚Ä¢ acur√°cia:${ex.metrics.acc}%</div>
        ${lines}
        <div class="hr"></div>
        <div class="tiny muted"><b>O que fazer agora (pr√≥ximos 20‚Äì30 min):</b></div>
        ${acts || '<div class="tiny muted" style="margin-top:6px;">Sem recomenda√ß√µes ainda.</div>'}
      `;
    }

    // initial render (persisted selection)
    let initialDisc = null;
    try{ initialDisc = localStorage.getItem(WHY_DISC_KEY); }catch{ initialDisc = null; }
    if(!initialDisc){
      const first = app.querySelector('button[data-why]');
      if(first) initialDisc = first.getAttribute('data-why');
    }
    if(initialDisc) renderWhy(initialDisc);

    app.querySelectorAll('button[data-why]').forEach(b=>{
      b.onclick = ()=>{
        const disc = b.getAttribute('data-why');
        try{ localStorage.setItem(WHY_DISC_KEY, disc); }catch{}
        renderWhy(disc);
      };
    });
    // plan buttons (from recommendations)
    app.querySelectorAll('button[data-plan-act]').forEach(b=>{
      b.onclick = ()=>{
        const act = b.getAttribute('data-plan-act') || 'questions';
        const disc = b.getAttribute('data-plan-disc') || '';
        try{ localStorage.setItem(WHY_DISC_KEY, disc); }catch{}
        if(act === 'errors'){
          const t = document.querySelector('.tab[data-tab="errors"]'); if(t) t.click();
          return;
        }
        if(act === 'schedule'){
          const t = document.querySelector('.tab[data-tab="schedule"]'); if(t) t.click();
          return;
        }
        if(act === 'traps'){
          const t = document.querySelector('.tab[data-tab="notebook"]'); if(t) t.click();
          return;
        }
        // default questions
        const t = document.querySelector('.tab[data-tab="questions"]'); if(t) t.click();
      };
    });



    app.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.onclick = ()=>{
        const act = btn.getAttribute("data-act");
        const id = btn.getAttribute("data-id");

        if(act === "focusNext"){
          if(queue.length){ focusIdx = (focusIdx + 1) % queue.length; render(); }
          return;
        }
        if(act === "focusReviewed"){
          store.dispatch({ type: A.ERROR_MARK_REVIEWED, id });
          toast("Revis√£o marcada ‚úì");
          if(queue.length){ focusIdx = (focusIdx + 1) % queue.length; }
          render();
          return;
        }
        if(act === "focusToSchedule"){
          document.querySelector('.tab[data-tab="schedule"]').click();
          return;
        }
        if(act === "focusOpenTrap"){
          try{ localStorage.setItem("SAPE_TRAP_FOCUS_ID", id); }catch{}
          sessionStorage.setItem('SAPE_NB_MODE','error'); document.querySelector('.tab[data-tab="notebook"]').click();
          return;
        }
        if(act === "focusStartSim"){
          sessionStorage.setItem('SAPE_NB_MODE','error'); document.querySelector('.tab[data-tab="notebook"]').click();
          setTimeout(()=>{
            const pool = (store.getState().traps || []);
            if(pool.length < 3){ toast("Salve pelo menos 3 pegadinhas para iniciar."); return; }
            store.dispatch({ type: A.TRAP_SIM_START });
          }, 50);
          return;
        }

        if(act === "revNow"){
          store.dispatch({ type: A.ERROR_MARK_REVIEWED, id });
          toast("Revis√£o marcada ‚úì");
          return;
        }
        if(act === "goSchedule"){
          document.querySelector('.tab[data-tab="schedule"]').click();
          return;
        }
        if(act === "goTraps"){
          try{ localStorage.setItem("SAPE_TRAP_FOCUS_ID", id); }catch{}
          sessionStorage.setItem('SAPE_NB_MODE','error'); document.querySelector('.tab[data-tab="notebook"]').click();
          return;
        }
        if(act === "startSim"){
          sessionStorage.setItem('SAPE_NB_MODE','error'); document.querySelector('.tab[data-tab="notebook"]').click();
          setTimeout(()=>{
            const pool = (store.getState().traps || []);
            if(pool.length < 3){ toast("Salve pelo menos 3 pegadinhas para iniciar."); return; }
            store.dispatch({ type: A.TRAP_SIM_START });
          }, 50);
          return;
        }
      };
    });
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="dashboard") render(); });
  return ()=> unsub();
}


function mountErrors(){
  function render(){
    const state = store.getState();
    const k = selectKpis(state);

    app.innerHTML = `
      <div class="grid">
        <div class="card">
          <div class="section-title">
            <h2>Caderno de Erros</h2>
            <span class="pill">Sem agenda: <b>${k.noSchedule}</b></span>
          </div>

          

<div class="row" style="margin-top:10px;">
  <div>
    <label>Disciplina</label>
    <select id="nbDisc">
      ${discs.map(d=>`<option ${d===defaultDisc?'selected':''}>${escapeHtml(d)}</option>`).join("")}
    </select>
  </div>
  <div>
    <label>T√≥pico</label>
    <select id="nbTopic">
      ${topics.map(t=>`<option ${t===defaultTopic?'selected':''}>${escapeHtml(t)}</option>`).join("")}
    </select>
  </div>
</div>

<div class="hr"></div>
<div class="note">Depois, revise no <b>Cronograma</b> (ou marque ‚ÄúRevisado‚Äù na lista).</div>
        </div>

        <div class="card">
          <div class="section-title">
            <h2>Lista</h2>
            <span class="pill">Atrasadas: <b>${k.overdue}</b> ‚Ä¢ Hoje: <b>${k.dueToday}</b></span>
          </div>

          <details open class="compact">
            <summary>
              <span>Lista + filtros</span>
              <span class="chev">‚åÑ</span>
            </summary>
            <div style="margin-top:10px;">
              <div class="row">
                <div><label>Filtro disciplina</label><input id="filterDisc" placeholder="(vazio = tudo)" /></div>
                <div><label>Filtro banca</label><input id="filterBank" placeholder="(vazio = tudo)" /></div>
              </div>
              <div id="tableWrap" class="compact"></div>
            </div>
          </details>
        </div>
      </div>
    `;

    const tableWrap = document.getElementById("tableWrap");
    const filterDisc = document.getElementById("filterDisc");
    const filterBank = document.getElementById("filterBank");

    function renderTable(){
      const fd = safeString(filterDisc.value).trim().toLowerCase();
      const fb = safeString(filterBank.value).trim().toLowerCase();

      const rows = (state.errors || []).filter(e=>{
        const okD = !fd || e.disc.toLowerCase().includes(fd);
        const okB = !fb || e.bank.toLowerCase().includes(fb);
        return okD && okB;
      }).sort((a,b)=> new Date(b.createdAt) - new Date(a.createdAt));

      if(rows.length === 0){
        tableWrap.innerHTML = `<div class="note">Nenhum erro ainda. Cadastre o primeiro √† esquerda.</div>`;
        return;
      }

      const today0 = startOfDay(new Date());
      const tomorrow0 = addDays(today0, 1);

      tableWrap.innerHTML = `
        <table>
          <thead>
            <tr><th>Disciplina / Assunto</th><th>Banca</th><th>Pr√≥x revis√£o</th><th>A√ß√µes</th></tr>
          </thead>
          <tbody>
            ${rows.map(e=>{
              const d = e.nextReviewAt ? new Date(e.nextReviewAt) : null;
              let badge = `<span class="badge">sem agenda</span>`;
              if(d && !Number.isNaN(d.getTime())){
                if(d < today0) badge = `<span class="badge overdue">atrasado</span>`;
                else if(d >= today0 && d < tomorrow0) badge = `<span class="badge today">hoje</span>`;
                else badge = `<span class="badge soon">agendado</span>`;
              }
              return `
                <tr>
                  <td>
                    <div><b>${escapeHtml(e.disc || "(sem disciplina)")}</b></div>
                    <div class="muted tiny">${escapeHtml(e.topic || "(sem assunto)")}</div>
                  </td>
                  <td>${escapeHtml(e.bank || "-")}</td>
                  <td>
                    ${badge}
                    <div class="tiny muted" style="margin-top:6px">${fmtDate(e.nextReviewAt)}</div>
                    <div class="tiny muted">revis√µes: ${Array.isArray(e.reviewHistory)? e.reviewHistory.length : 0}</div>
                  </td>
                  <td>
                    <div class="actions">
                      <button class="btn" data-act="review" data-id="${e.id}">Revisado</button>
                      <button class="btn" data-act="postpone" data-id="${e.id}">+1 dia</button>
                      <button class="btn danger" data-act="del" data-id="${e.id}">Excluir</button>
                    </div>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      tableWrap.querySelectorAll("button[data-act]").forEach(b=>{
        b.onclick = ()=>{
          const id = b.getAttribute("data-id");
          const act = b.getAttribute("data-act");
          if(act==="review"){
            store.dispatch({ type: A.ERROR_MARK_REVIEWED, id });
            toast("Revis√£o marcada ‚úì");
          } else if(act==="postpone"){
            store.dispatch({ type: A.ERROR_POSTPONE, id, days: 1 });
            toast("Adiado +1 dia");
          } else if(act==="del"){
            if(confirm("Excluir este erro?")){
              store.dispatch({ type: A.ERROR_DELETE, id });
              toast("Exclu√≠do");
            }
          }
        };
      });
    }

    filterDisc.oninput = renderTable;
    filterBank.oninput = renderTable;

    document.getElementById("add").onclick = ()=>{
      const disc = safeString(document.getElementById("disc").value).trim();
      const topic = safeString(document.getElementById("topic").value).trim();
      const bank = safeString(document.getElementById("bank").value).trim();
      const cause = safeString(document.getElementById("cause").value).trim();
      const notes = safeString(document.getElementById("notes").value).trim();
      const first = document.getElementById("firstReview").value;

      if(!disc && !topic){ toast("Preencha ao menos Disciplina ou Assunto."); return; }

      const now = new Date();
      let nextReviewAt = null;

      if(first === "today") nextReviewAt = startOfDay(now).toISOString();
      else if(first === "tomorrow") nextReviewAt = addDays(startOfDay(now), 1).toISOString();
      else if(first === "none") nextReviewAt = null;
      else {
        const days = Number(first);
        nextReviewAt = addDays(startOfDay(now), Number.isFinite(days) ? days : 3).toISOString();
      }

      store.dispatch({ type: A.ERROR_ADD, payload: {
        id: uid(), createdAt: now.toISOString(), disc, topic, bank, cause, notes,
        mistakeType:"", nextReviewAt, reviewHistory:[]
      }});
      toast("Erro adicionado ‚úì");
      clearForm();
    };

    function clearForm(){
      ["disc","topic","bank","cause","notes"].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
      document.getElementById("firstReview").value = "tomorrow";
    }
    document.getElementById("clearForm").onclick = ()=> clearForm();

    renderTable();
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="errors") render(); });
  return ()=> unsub();
}


function updateNotebookErrorById(state, id, patchFn){
  const nb = state.notebook || {};
  const examId = (typeof loadProfile === 'function' ? (loadProfile()||{}).mainExamId : '') || '';
  const scopedExamIds = examId ? [examId] : Object.keys(nb||{});

  for(const ex of scopedExamIds){
    const byDisc = nb[ex] || {};
    for(const disc of Object.keys(byDisc)){
      const byTopic = byDisc[disc] || {};
      for(const topic of Object.keys(byTopic)){
        const entry = byTopic[topic] || {};
        const errs = Array.isArray(entry.errors) ? entry.errors : [];
        let changed = false;
        const nextErrs = errs.map(er=>{
          if(!er || String(er.id) !== String(id)) return er;
          changed = true;
          return patchFn({ ...er });
        });
        if(changed){
          // use reducer to keep sanitize/merge rules
          const nextNotebook = notebookReducer(nb, { type: A.NB_SAVE, payload: { examId: ex, disc, topic, data: { errors: nextErrs } } });
          return { ...state, notebook: nextNotebook };
        }
      }
    }
  }
  return state;
}

function scheduleMarkReviewedNotebook(id){
  const st0 = store.getState();
  const nextState = updateNotebookErrorById(st0, id, (er)=>{
    er.reviewed = true;
    // set nextReviewAt forward (3‚Üí7‚Üí14) as fallback, but reviewed hides it anyway
    const base = new Date();
    er.nextReviewAt = addDays(startOfDay(base), 7).toISOString();
    return er;
  });
  store.dispatch({ type: A.STATE_IMPORT, payload: nextState });
      // invalida cache da Matriz para recalcular pesos com novos dados
      try{
        const ex = getActiveExam();
        if(typeof normalizeExamKey === "function") localStorage.removeItem(mlKey("ML_MATRIX_" + normalizeExamKey(ex)));
      }catch(e){}
}

function scheduleSetNextReviewNotebook(id, whenDate){
  const st0 = store.getState();
  const whenIso = new Date(whenDate).toISOString();
  const nextState = updateNotebookErrorById(st0, id, (er)=>{
    er.nextReviewAt = whenIso;
    er.reviewed = false;
    return er;
  });
  store.dispatch({ type: A.STATE_IMPORT, payload: nextState });
      // invalida cache da Matriz para recalcular pesos com novos dados
      try{
        const ex = getActiveExam();
        if(typeof normalizeExamKey === "function") localStorage.removeItem(mlKey("ML_MATRIX_" + normalizeExamKey(ex)));
      }catch(e){}
}

function scheduleDeleteNotebook(id){
  const st0 = store.getState();
  const nb = st0.notebook || {};
  const examId = getActiveExamId(st0);
  const scopedExamIds = examId ? [examId] : Object.keys(nb||{});

  for(const ex of scopedExamIds){
    const byDisc = nb[ex] || {};
    for(const disc of Object.keys(byDisc)){
      const byTopic = byDisc[disc] || {};
      for(const topic of Object.keys(byTopic)){
        const entry = byTopic[topic] || {};
        const errs = Array.isArray(entry.errors) ? entry.errors : [];
        const nextErrs = errs.filter(er=> String(er?.id) !== String(id));
        if(nextErrs.length !== errs.length){
          const nextNotebook = notebookReducer(nb, { type: A.NB_SAVE, payload: { examId: ex, disc, topic, data: { errors: nextErrs } } });
          store.dispatch({ type: A.STATE_IMPORT, payload: { ...st0, notebook: nextNotebook } });
          return;
        }
      }
    }
  }
}


function mountSchedule(){
  function render(){
    const state = store.getState();
    const p = loadProfile();
    
// Matriz do dia (2 disciplinas/dia) ‚Äî cache (v3.0)
let matrixDay = null;
let matrix = null;
try{
  if(p && isProfileComplete(p) && typeof ensureMatrix === "function"){
    matrix = ensureMatrix(p);
    const todayKey = (new Date()).toISOString().slice(0,10);
    matrixDay = (typeof ensureMatrixDay==="function") ? ensureMatrixDay(p, todayKey) : null;
  }
}catch(e){}

    const b = selectScheduleBuckets(state);
    const weekKeys = Object.keys(b.week).sort((a,b)=> new Date(a) - new Date(b));

    app.innerHTML = `
      <div class="card">
        <div class="section-title">
          <h2>Cronograma</h2>
          <span class="pill">Hoje: <b>${b.today.length}</b> ‚Ä¢ Atrasadas: <b>${b.overdue.length}</b></span>
        </div>

        <div class="note">Revis√µes do <b>Caderno Inteligente</b> por data. Use ‚ÄúRevisado‚Äù para reagendar (3 ‚Üí 7 ‚Üí 14 dias).</div>
        <div class="hr"></div>

        ${matrixDay ? `
        <div class="card" style="box-shadow:none;border-style:dashed;margin:10px 0;">
          <div class="section-title">
            <div><b>Plano do dia (Matriz)</b></div>
            <span class="pill">${escapeHtml((matrix && matrix.horizonMonths ? matrix.horizonMonths : ""))} meses</span>
          </div>
          <div class="note">Blocos do dia gerados automaticamente. Use ‚ÄúAplicar ao Cronograma‚Äù para preencher as disciplinas de hoje.</div>
          <div style="margin-top:8px">
            <div><b>Bloco 1:</b> ${escapeHtml(matrixDay.blocks[0].disc)} ‚Äî ${escapeHtml(matrixDay.blocks[0].topic)}</div>
            <div><b>Bloco 2:</b> ${escapeHtml(matrixDay.blocks[1].disc)} ‚Äî ${escapeHtml(matrixDay.blocks[1].topic)}</div>
          </div>
          <div class="btnbar" style="margin-top:10px">
            <button class="btn primary" id="applyMatrixToTodayBtn">Aplicar ao Cronograma</button>
            <button class="btn" id="openMatrixTabBtn">Abrir Matriz</button>
          <button class="btn" id="openNotebookFromMatrixDayBtn">Abrir Caderno (Bloco 1)</button>
           </div>
        </div>` : ``}

        <div class="card" style="box-shadow:none;border-style:dashed;margin:10px 0;">
          <div class="section-title">
            <div><b>Disciplinas de hoje (para priorizar o Bloco 0)</b></div>
            <span class="pill">at√© 3</span>
          </div>
          <div class="note">Escolha 1‚Äì3 disciplinas do seu dia. O Bloco 0 trar√° primeiro as revis√µes dessas disciplinas.</div>
          <div class="row">
            <div>
              <label>Disciplina 1</label>
              <select data-day-disc="1" id="dayDisc1"></select>
            </div>
            <div>
              <label>Disciplina 2</label>
              <select data-day-disc="2" id="dayDisc2"></select>
            </div>
            <div>
              <label>Disciplina 3</label>
              <select data-day-disc="3" id="dayDisc3"></select>
            </div>
          </div>
          <div class="btnbar">
            <button class="btn" id="autoSuggestDayDiscsBtn">Auto‚Äësugerir</button>
            <button class="btn primary" id="saveDayDiscsBtn">Salvar disciplinas de hoje</button>
            <button class="btn" id="clearDayDiscsBtn">Limpar</button>
          </div>
        </div>

<div class="card" style="box-shadow:none;border-style:dashed;margin:10px 0;">
  <div class="section-title">
    <div><b>Bloco 0 ‚Äî Revis√µes Autom√°ticas</b></div>
    <span class="pill">din√¢mico</span>
  </div>
  <div class="note">Gerado pelo Caderno Inteligente (atrasadas + hoje), priorizando as disciplinas escolhidas acima.</div>
  <div id="scheduleBlocoZero" style="margin-top:10px"></div>
</div>

${renderBucket("Revis√µes atrasadas", b.overdue, "overdue")}
        ${renderBucket("Revis√µes para hoje", b.today, "today")}

        <div class="hr"></div>

        <details open class="compact">
          <summary>
            <span>Pr√≥ximos 7 dias</span>
            <span class="chev">‚åÑ</span>
          </summary>
          <div style="margin-top:10px;">
            <div class="note">Organizado por dia.</div>
            ${weekKeys.length ? weekKeys.map(k => `
          <div class="card" style="box-shadow:none;border-style:dashed;margin:10px 0;">
            <div class="section-title">
              <div><b>${fmtDate(k)}</b></div>
              <span class="pill">${b.week[k].length} itens</span>
            </div>
            ${renderList(b.week[k])}
          </div>
        `).join("") : `<div class="note">Nada agendado para os pr√≥ximos 7 dias.</div>`}
          </div>
        </details>

        <div class="hr"></div>

        <details class="compact">
          <summary>
            <span>Sem agenda</span>
            <span class="chev">‚åÑ</span>
          </summary>
          <div style="margin-top:10px;">
            <div class="section-title" style="margin-top:0;">
              <h3 style="margin:0;">Itens sem agenda</h3>
              <span class="pill"><b>${b.backlog.length}</b></span>
            </div>
          <span class="pill"><b>${b.backlog.length}</b></span>
        </div>

        ${b.backlog.length ? `
          <div class="note">Esses erros est√£o sem revis√£o definida. Voc√™ pode agendar com ‚ÄúHoje/Amanh√£/+7‚Äù.</div>
          ${renderList(b.backlog, true)}
        ` : `<div class="note">Nenhum item sem agenda.</div>`}
          </div>
        </details>
      </div>
    `;

    const ag = app.querySelector('#aggro');
    if(ag){
      const val = app.querySelector('#aggroVal');
      ag.oninput = ()=>{ if(val) val.textContent = Number(ag.value).toFixed(2) + 'x'; };
      ag.onchange = ()=>{ setAggro(Number(ag.value)); toast('Agressividade: ' + Number(ag.value).toFixed(2) + 'x'); render(); };
    }

// ===== Cronograma: bindings "Disciplinas de hoje" + Matriz -> Cronograma (v3.0.5d) =====
try{
  const examId = (state.activeExam || getActiveExam());
  const allDiscs = (typeof getDisciplines==="function") ? getDisciplines(examId) : [];
  const selects = app.querySelectorAll('select[data-day-disc]');
  const opt = ['<option value="">‚Äî</option>'].concat(allDiscs.map(d=>`<option value="${escapeHtml(d)}">${escapeHtml(d)}</option>`)).join("");
  selects.forEach(s=>{ if(s) s.innerHTML = opt; });

  // restaura o que j√° estava salvo hoje
  const todayKey = (typeof dayKeyISO==="function") ? dayKeyISO(new Date()) : (new Date().toISOString().slice(0,10));
  const saved = (typeof loadDayDisciplinesByKey==="function") ? (loadDayDisciplinesByKey(todayKey) || []) : [];
  if(saved && saved.length){
    saved.forEach((d,i)=>{ if(selects[i]) selects[i].value = d; });
  }

  // Bot√µes do bloco "Disciplinas de hoje"
  const btnAuto = document.getElementById("autoSuggestDayDiscsBtn");
  const btnSave = document.getElementById("saveDayDiscsBtn");
  const btnClear = document.getElementById("clearDayDiscsBtn");

  if(btnAuto){
    btnAuto.onclick = ()=>{
      const suggested = (typeof suggestDisciplinesFromHistory==="function") ? suggestDisciplinesFromHistory(10,3) : [];
      const base = (suggested && suggested.length) ? suggested : allDiscs.slice(0,3);
      selects.forEach((s,idx)=>{ if(s) s.value = base[idx] || ""; });
      toast("Sugest√£o aplicada ‚úì");
      try{ renderBlocoZero(); }catch(e){}

  // Render inicial do Bloco 0
  try{ renderBlocoZero(); }catch(e){}

    };
  }
  if(btnSave){
    btnSave.onclick = ()=>{
      const arr = Array.from(selects).map(s=> (s && s.value) ? s.value : "").filter(Boolean);
      try{ saveTodayDisciplines(arr); }catch(e){}
      toast("Disciplinas de hoje salvas ‚úì");
      try{ renderBlocoZero(); }catch(e){}
    };
  }
  if(btnClear){
    btnClear.onclick = ()=>{
      try{ saveTodayDisciplines([]); }catch(e){}
      selects.forEach(s=>{ if(s) s.value=""; });
      toast("Limpo ‚úì");
      try{ renderBlocoZero(); }catch(e){}
    };
  }

  // Integra√ß√£o Matriz -> Cronograma
  function setNotebookDraftFromMatrixDay(md){
    try{
      if(!md || !md.blocks || !md.blocks[0]) return;
      const draft = {
        disc: md.blocks[0].disc || "",
        topic: md.blocks[0].topic || "",
        mode: "normal",
        from: "matrixDay",
        createdAt: new Date().toISOString()
      };
      sessionStorage.setItem("SAPE_NB_DRAFT", JSON.stringify(draft));
    }catch(e){}
  }

  const btnApply = document.getElementById("applyMatrixToTodayBtn");
  if(btnApply){
    btnApply.onclick = ()=>{
      if(!matrixDay || !matrixDay.blocks){ toast("Sem Matriz para hoje."); return; }
      const ds = [matrixDay.blocks[0].disc, matrixDay.blocks[1].disc].filter(Boolean);
      try{ saveTodayDisciplines(ds); }catch(e){}
      ds.forEach((d,i)=>{ if(selects[i]) selects[i].value = d; });

      // salva tamb√©m o plano do dia (disc + t√≥pico) se dispon√≠vel
      try{
        if(typeof saveTodayPlan==="function"){
          saveTodayPlan({ source:"matrix", blocks: (matrixDay.blocks||[]).slice(0,2).map(b=>({disc:b.disc||"", topic:b.topic||""})), updatedAt:new Date().toISOString() });
        }
      }catch(e){}
      setNotebookDraftFromMatrixDay(matrixDay);
      toast("Cronograma alinhado com a Matriz ‚úì");
      try{ renderBlocoZero(); }catch(e){}
    };
  }

  const btnOpenMatrix = document.getElementById("openMatrixTabBtn");
  if(btnOpenMatrix){ btnOpenMatrix.onclick = ()=>{ go("matrix"); }; }

  const btnOpenNb = document.getElementById("openNotebookFromMatrixDayBtn");
  if(btnOpenNb){
    btnOpenNb.onclick = ()=>{
      setNotebookDraftFromMatrixDay(matrixDay);
      go("notebook");
    };
  }
}catch(e){}
// ===============================================================================


    app.querySelectorAll("button[data-act]").forEach(btn=>{
      btn.onclick = ()=>{
        const id = btn.getAttribute("data-id");
        const act = btn.getAttribute("data-act");
        if(act === "review"){
          scheduleMarkReviewedNotebook(id); toast("Revis√£o marcada ‚úì");
        } else if(act === "postpone"){
          scheduleSetNextReviewNotebook(id, addDays(startOfDay(new Date()), 1)); toast("Adiado +1 dia");
        } else if(act === "setToday"){
          scheduleSetNextReviewNotebook(id, startOfDay(new Date())); toast("Agendado para hoje");
        } else if(act === "setTomorrow"){
          scheduleSetNextReviewNotebook(id, addDays(startOfDay(new Date()), 1)); toast("Agendado para amanh√£");
        } else if(act === "set7"){
          scheduleSetNextReviewNotebook(id, addDays(startOfDay(new Date()), 7)); toast("Agendado +7 dias");
        } else if(act === "del"){
          if(confirm("Excluir este item?")){ scheduleDeleteNotebook(id); toast("Exclu√≠do"); }
        }
      };
    });
  }

  function renderBucket(title, items, badgeKind){
    const badgeClass = badgeKind === "overdue" ? "overdue" : (badgeKind === "today" ? "today" : "soon");
    return `
      <div class="section-title" style="margin-top:10px;">
        <h3>${title}</h3>
        <span class="pill"><span class="badge ${badgeClass}">${items.length}</span></span>
      </div>
      ${items.length ? renderList(items) : `<div class="note">Nada aqui.</div>`}
    `;
  }

  function renderList(items, isBacklog=false){
    return `
      <table>
        <thead><tr><th>Item</th><th>Pr√≥x revis√£o</th><th>A√ß√µes</th></tr></thead>
        <tbody>
          ${items.map(e => `
            <tr>
              <td>
                <div><b>${escapeHtml(e.disc || "(sem disciplina)")}</b> <span class="muted">‚Äî</span> ${escapeHtml(e.topic || "(sem assunto)")}</div>
                <div class="tiny muted">banca: ${escapeHtml(e.bank || "-")} ‚Ä¢ revis√µes: ${Array.isArray(e.reviewHistory)? e.reviewHistory.length : 0}</div>
              </td>
              <td><div>${fmtDate(e.nextReviewAt)}</div><div class="tiny muted">${(e.nextReviewAt ? "" : "sem agenda")}</div></td>
              <td>
                <div class="actions">
                  <button class="btn" data-act="review" data-id="${e.id}">Revisado</button>
                  <button class="btn" data-act="postpone" data-id="${e.id}">+1 dia</button>
                  ${isBacklog ? `
                    <button class="btn" data-act="setToday" data-id="${e.id}">Hoje</button>
                    <button class="btn" data-act="setTomorrow" data-id="${e.id}">Amanh√£</button>
                    <button class="btn" data-act="set7" data-id="${e.id}">+7</button>
                  ` : ``}
                  <button class="btn danger" data-act="del" data-id="${e.id}">Excluir</button>
                </div>
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="schedule") render(); });
  return ()=> unsub();
}

function mountTraps(){
  let lastAnalysis = null;

  function render(){
    const state = store.getState();
    const traps = Array.isArray(state.traps) ? state.traps : [];
    const sim = state.advSim;

    app.innerHTML = `
      <div class="grid">
        <div class="card">
          <div class="section-title">
            <h2>Pegadinhas (DPA)</h2>
            <span class="pill">Salvas: <b>${traps.length}</b></span>
          </div>

          <div class="row">
            <div><label>Disciplina</label><input id="trapDisc" placeholder="Ex.: Proc. do Trabalho" /></div>
            <div><label>T√≥pico</label><input id="trapTopic" placeholder="Ex.: Compet√™ncia" /></div>
          </div>

          <div class="row">
            <div><label>Banca</label><input id="trapBank" placeholder="Ex.: FCC / FGV / CEBRASPE / AUTO" /></div>
            <div>
              <label>Tipo</label>
              <select id="trapType">
                <option>Amb√≠gua/dupla interpreta√ß√£o</option>
                <option>Nega√ß√£o/EXCETO</option>
                <option>Absolutismo (sempre/nunca)</option>
                <option>Conceitual (distin√ß√µes finas)</option>
                <option>Processual (prazo/cabimento/efeitos)</option>
                <option>Exce√ß√£o/regra</option>
                <option>Literalidade x contexto</option>
              </select>
            </div>
          </div>

          <label>Texto da pegadinha (cole a quest√£o/trecho)</label>
          <textarea id="trapText" placeholder="Cole aqui o trecho pegadinha..."></textarea>

          <label>Corre√ß√£o (opcional, mas recomendado)</label>
          <textarea id="trapFix" placeholder="O que faria essa assertiva ficar correta? Qual detalhe muda o gabarito?"></textarea>

          <div class="btnbar">
            <button class="btn primary" id="btnTrapAnalyze">Analisar</button>
            <button class="btn" id="btnTrapSave">Salvar</button>
            <button class="btn" id="btnTrapClear">Limpar</button>
            <button class="btn" id="btnStartAdvSim">Treino (10)</button>
          </div>

          <div class="hr"></div>

          <details open class="compact">
            <summary>
              <span>An√°lise + Treino</span>
              <span class="chev">‚åÑ</span>
            </summary>
            <div style="margin-top:10px;">
              <div id="trapAnalysis" class="note">Cole uma pegadinha e clique em <b>Analisar</b>.</div>
              ${sim ? `
                <div class="hr"></div>
                ${renderSim(sim)}
              ` : ``}
            </div>
          </details>
        </div>

        <div class="card">
          <div class="section-title">
            <h2>Mapa</h2>
            <span class="pill">Top perigo: <b>${topDanger(traps)}</b></span>
          </div>
          <details open class="compact">
            <summary>
              <span>Lista de pegadinhas</span>
              <span class="chev">‚åÑ</span>
            </summary>
            <div style="margin-top:10px;">
              <div id="trapTable" class="compact"></div>
            </div>
          </details>
        </div>
      </div>
    `;

    // bindings
    const btnAnalyze = document.getElementById("btnTrapAnalyze");
    const btnSave = document.getElementById("btnTrapSave");
    const btnClear = document.getElementById("btnTrapClear");
    const btnStart = document.getElementById("btnStartAdvSim");

    btnAnalyze.onclick = ()=>{
      const payload = collectTrapForm();
      if(!payload.text.trim()){ toast("Cole ou descreva a pegadinha."); return; }
      lastAnalysis = analyzeTrapPayload(payload);
      renderAnalysis(lastAnalysis);
    };

    btnSave.onclick = ()=>{
      const payload = collectTrapForm();
      if(!payload.text.trim()){ toast("Cole ou descreva a pegadinha antes de salvar."); return; }
      const item = analyzeTrapPayload(payload);
      store.dispatch({ type: A.TRAP_ADD, payload: item });
      lastAnalysis = item;
      renderAnalysis(item);
      toast("Pegadinha salva ‚úì");
      renderTrapTable();
    };

    btnClear.onclick = ()=>{
      ["trapDisc","trapTopic","trapBank","trapText","trapFix"].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
      document.getElementById("trapType").selectedIndex = 0;
      lastAnalysis = null;
      renderAnalysis(null);
    };

    btnStart.onclick = ()=>{
      const pool = (store.getState().traps || []);
      if(pool.length < 3){ toast("Salve pelo menos 3 pegadinhas para iniciar."); return; }
      store.dispatch({ type: A.TRAP_SIM_START });
      toast("Treino iniciado");
    };

    // bind sim buttons if exists
    const simWrap = document.getElementById("simWrap");
    if(simWrap){
      simWrap.querySelectorAll("button[data-sim]").forEach(b=>{
        b.onclick = ()=>{
          const act = b.getAttribute("data-sim");
          if(act==="right") store.dispatch({ type: A.TRAP_SIM_ANSWER, correct: true });
          if(act==="wrong") store.dispatch({ type: A.TRAP_SIM_ANSWER, correct: false });
          if(act==="end") store.dispatch({ type: A.TRAP_SIM_END });
        };
      });
    }

    function renderAnalysis(a){
      const box = document.getElementById("trapAnalysis");
      if(!box) return;
      if(!a){
        box.innerHTML = `Cole uma pegadinha e clique em <b>Analisar</b>.`;
        return;
      }
      box.innerHTML = `
        <div class="section-title" style="margin:0;">
          <div><b>Perigo:</b> ${a.danger}/100</div>
          <span class="pill">Tipo: <b>${escapeHtml(a.type)}</b></span>
        </div>
        <div class="hr"></div>
        <div><b>Erros t√≠picos:</b> ${(a.typical||[]).map(t=>`<span class="badge">${escapeHtml(t)}</span>`).join(" ")}</div>
        <div style="margin-top:10px;"><b>Treino recomendado:</b><ul class="note" style="margin:8px 0 0 18px;">
          ${(a.trainPlan||[]).map(x=>`<li>${escapeHtml(x)}</li>`).join("")}
        </ul></div>
      `;
    }

    function renderTrapTable(){
      const state2 = store.getState();
      const rows = (state2.traps || []).slice().sort((a,b)=> new Date(b.createdAt) - new Date(a.createdAt));
      const wrap = document.getElementById("trapTable");
      if(!wrap) return;

      if(rows.length === 0){
        wrap.innerHTML = `<div class="note">Nenhuma pegadinha ainda. Salve as que voc√™ cair durante as quest√µes.</div>`;
        return;
      }

      wrap.innerHTML = `
        <table>
          <thead><tr><th>Disc / T√≥pico</th><th>Perigo</th><th>Tipo</th><th>A√ß√µes</th></tr></thead>
          <tbody>
            ${rows.map(t=>`
              <tr>
                <td>
                  <div><b>${escapeHtml(t.disc || "(sem disciplina)")}</b></div>
                  <div class="tiny muted">${escapeHtml(t.topic || "(sem t√≥pico)")}</div>
                  <div class="tiny muted">banca: ${escapeHtml(t.bank || "-")}</div>
                </td>
                <td><span class="badge">${t.danger}/100</span><div class="tiny muted">${fmtDate(t.createdAt)}</div></td>
                <td>${escapeHtml(t.type || "-")}</td>
                <td>
                  <div class="actions">
                    <button class="btn" data-act="open" data-id="${t.id}">Ver</button>
                    <button class="btn danger" data-act="del" data-id="${t.id}">Excluir</button>
                  </div>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;

      wrap.querySelectorAll("button[data-act]").forEach(b=>{
        b.onclick = ()=>{
          const act = b.getAttribute("data-act");
          const id = b.getAttribute("data-id");
          const trap = (store.getState().traps || []).find(x=>x.id===id);
          if(act==="open" && trap){
            lastAnalysis = trap;
            // preencher form com o item
            document.getElementById("trapDisc").value = trap.disc || "";
            document.getElementById("trapTopic").value = trap.topic || "";
            document.getElementById("trapBank").value = trap.bank || "";
            document.getElementById("trapText").value = trap.text || "";
            document.getElementById("trapFix").value = trap.fix || "";
            // tentar selecionar tipo
            const sel = document.getElementById("trapType");
            const idx = Array.from(sel.options).findIndex(o=>o.textContent===trap.type);
            sel.selectedIndex = idx >= 0 ? idx : 0;
            renderAnalysis(trap);
            toast("Pegadinha carregada");
          }
          if(act==="del"){
            if(confirm("Excluir esta pegadinha?")){
              store.dispatch({ type: A.TRAP_DELETE, id });
              toast("Exclu√≠da");
              renderTrapTable();
            }
          }
        };
      });
    }

    function collectTrapForm(){
      return {
        disc: (document.getElementById("trapDisc")||{}).value || "",
        topic: (document.getElementById("trapTopic")||{}).value || "",
        bank: (document.getElementById("trapBank")||{}).value || "AUTO",
        type: (document.getElementById("trapType")||{}).value || "Amb√≠gua/dupla interpreta√ß√£o",
        text: (document.getElementById("trapText")||{}).value || "",
        fix: (document.getElementById("trapFix")||{}).value || ""
      };
    }

    renderAnalysis(lastAnalysis);
    renderTrapTable();

    // Auto-focus trap if requested by dashboard
    try{
      const focusId = localStorage.getItem("SAPE_TRAP_FOCUS_ID");
      if(focusId){
        const trap = (store.getState().traps || []).find(x=>x.id===focusId);
        if(trap){
          lastAnalysis = trap;
          document.getElementById("trapDisc").value = trap.disc || "";
          document.getElementById("trapTopic").value = trap.topic || "";
          document.getElementById("trapBank").value = trap.bank || "";
          document.getElementById("trapText").value = trap.text || "";
          document.getElementById("trapFix").value = trap.fix || "";
          const sel = document.getElementById("trapType");
          const idx = Array.from(sel.options).findIndex(o=>o.textContent===trap.type);
          sel.selectedIndex = idx >= 0 ? idx : 0;
          renderAnalysis(trap);
          localStorage.removeItem("SAPE_TRAP_FOCUS_ID");
        }
      }
    }catch{}

  }

  function renderSim(sim){
    if(sim && sim.error==="MIN_3"){
      return `<div class="note">Salve pelo menos 3 pegadinhas para iniciar o treino.</div>`;
    }
    if(!sim || !Array.isArray(sim.items)) return "";
    const idx = Math.min(sim.idx, sim.items.length-1);
    const cur = sim.items[idx] || sim.items[sim.items.length-1];

    return `
      <div id="simWrap">
        <div class="section-title">
          <h3>Treino adversarial</h3>
          <span class="pill">Progresso: <b>${Math.min(sim.idx, sim.items.length)}/${sim.items.length}</b> ‚Ä¢ ‚úì ${sim.right} ‚úó ${sim.wrong}</span>
        </div>

        ${sim.done ? `
          <div class="card" style="box-shadow:none;border-style:dashed;">
            <div><b>Finalizado.</b></div>
            <div class="note">Acertos: ${sim.right} ‚Ä¢ Erros: ${sim.wrong}</div>
            <div class="btnbar" style="margin-top:10px;">
              <button class="btn primary" data-sim="end">Encerrar</button>
            </div>
          </div>
        ` : `
          <div class="card" style="box-shadow:none;border-style:dashed;">
            <div class="tiny muted">Disciplina: ${escapeHtml(cur.disc || "-")} ‚Ä¢ T√≥pico: ${escapeHtml(cur.topic || "-")} ‚Ä¢ Tipo: ${escapeHtml(cur.type || "-")}</div>
            <div style="margin-top:8px;"><b>Texto:</b></div>
            <div class="note" style="white-space:pre-wrap;">${escapeHtml(cur.text || "")}</div>
            ${cur.fix ? `<div style="margin-top:8px;"><b>Corre√ß√£o:</b></div><div class="note" style="white-space:pre-wrap;">${escapeHtml(cur.fix)}</div>` : ``}

            <div class="btnbar" style="margin-top:10px;">
              <button class="btn primary" data-sim="right">Acertei</button>
              <button class="btn" data-sim="wrong">Errei</button>
              <button class="btn danger" data-sim="end">Encerrar</button>
            </div>
          </div>
        `}
      </div>
    `;
  }

  function topDanger(traps){
    if(!traps || !traps.length) return "-";
    const max = traps.reduce((m,t)=> Math.max(m, Number(t.danger||0)), 0);
    return max ? (max + "/100") : "-";
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="traps") render(); });
  return ()=> unsub();
}



function deepMerge(a,b){
  const Aobj = (a && typeof a==="object") ? a : {};
  const Bobj = (b && typeof b==="object") ? b : {};
  const out = Array.isArray(Aobj) ? Aobj.slice() : { ...Aobj };
  for(const k of Object.keys(Bobj)){
    const av = Aobj[k];
    const bv = Bobj[k];
    if(bv && typeof bv==="object" && !Array.isArray(bv) && av && typeof av==="object" && !Array.isArray(av)){
      out[k] = deepMerge(av,bv);
    }else{
      out[k] = bv;
    }
  }
  return out;
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }


/* =========================================================
   MODULE: approval/modeloC (Camada de Intelig√™ncia de Aprova√ß√£o)
   Modelo C = corte hist√≥rico (ref) + ajuste por estrutura/peso + calibra√ß√£o pelo desempenho real
   ========================================================= */

const EXAM_CUTOFF_PREFIX = "SAPE_EXAM_CUTOFF::";
const EXAM_TIME_TARGET_PREFIX = "SAPE_EXAM_TIME_TARGET::"; // min/quest√£o

// Refer√™ncias iniciais (voc√™ ajusta no Comparativo)
const HISTORICAL_CUT_REF = {
  TRT_AJ: 82,
  TRE_AJ: 80,
  INSS_ANALISTA: 78,
  INSS_TEC: 74,
  RFB_AUDITOR: 84,
  AFT: 83,
  PCPR_AGENTE: 76,
};

function getExamCutoffRef(examId){
  const stored = Number(loadJSON(EXAM_CUTOFF_PREFIX + examId, NaN));
  if(Number.isFinite(stored)) return stored;
  const base = HISTORICAL_CUT_REF[examId];
  return Number.isFinite(Number(base)) ? Number(base) : 80;
}
function setExamCutoffRef(examId, val){
  const n = Number(val);
  if(!Number.isFinite(n)) return;
  saveJSON(EXAM_CUTOFF_PREFIX + examId, n);
}
function resetExamCutoffRef(examId){
  try{ localStorage.removeItem(EXAM_CUTOFF_PREFIX + examId); }catch{}
}

function getExamTimeTarget(examId){
  const stored = Number(loadJSON(EXAM_TIME_TARGET_PREFIX + examId, NaN));
  if(Number.isFinite(stored)) return stored;
  return 2.4; // padr√£o
}
function setExamTimeTarget(examId, val){
  const n = Number(val);
  if(!Number.isFinite(n)) return;
  saveJSON(EXAM_TIME_TARGET_PREFIX + examId, n);
}
function resetExamTimeTarget(examId){
  try{ localStorage.removeItem(EXAM_TIME_TARGET_PREFIX + examId); }catch{}
}

function getRecentAnswered(state, examId, n){
  const all = filterByExam(state.questions || [], examId)
    .filter(q => q.isCorrect !== null);
  // j√° vem em ordem recente (novo primeiro) no app; garantimos mesmo assim
  all.sort((a,b)=> new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return all.slice(0, n);
}

function computeWeightedAccuracy(state, examId, sampleN){
  const qs = getRecentAnswered(state, examId, sampleN || 240);
  if(!qs.length) return { acc:0, sample:0, perDisc:{} };

  const weights = getExamWeights(examId) || {};
  const discs = Object.keys(weights).filter(k=>k!=="discWeights");
  const perDisc = {};
  const globalAcc = qs.filter(q=>q.isCorrect===true).length / qs.length;

  let wSum = 0, score = 0;
  for(const d of discs){
    const w = Math.max(0.01, Number(weights[d] || 1));
    const dQs = qs.filter(q => (q.disc||"(sem disciplina)") === d);
    const dAcc = (dQs.length >= 6)
      ? (dQs.filter(q=>q.isCorrect===true).length / dQs.length)
      : globalAcc;

    perDisc[d] = { n:dQs.length, acc: dAcc };
    wSum += w;
    score += w * dAcc;
  }
  const acc = wSum ? (score / wSum) : globalAcc;
  return { acc, sample: qs.length, perDisc };
}

function computeTrendFactor(state, examId){
  const qs = getRecentAnswered(state, examId, 80);
  if(qs.length < 30) return 1;
  const mid = Math.floor(qs.length/2);
  const a = qs.slice(0, mid);
  const b = qs.slice(mid);
  const acc = (arr)=> arr.length ? (arr.filter(q=>q.isCorrect===true).length/arr.length) : 0;
  const delta = acc(a) - acc(b); // recente - antigo (porque a √© mais recente)
  if(delta > 0.05) return 1.03;
  if(delta < -0.05) return 0.97;
  return 1;
}

function computeVolumeFactor(state, examId){
  const total = filterByExam(state.questions || [], examId).length;
  if(total < 200) return 0.94;
  if(total < 700) return 0.98;
  if(total < 2000) return 1.00;
  return 1.02;
}

function computeTimeFactor(state, examId){
  const qs = getRecentAnswered(state, examId, 200).filter(q=>Number.isFinite(Number(q.timeMin)));
  if(!qs.length) return 1;
  const avg = qs.reduce((s,q)=>s + Number(q.timeMin||0),0) / qs.length;
  const target = getExamTimeTarget(examId);
  const diff = avg - target;
  if(diff > 0.8) return 0.97;
  if(diff < -0.5) return 1.02;
  return 1;
}

function computeStructureAdj(examId){
  const weights = getExamWeights(examId) || {};
  const arr = Object.keys(weights)
    .filter(k=>k!=="discWeights")
    .map(k=> Math.max(0.01, Number(weights[k]||1)))
    .sort((a,b)=>b-a);
  const sum = arr.reduce((s,x)=>s+x,0) || 1;
  const top3 = (arr[0]||0)+(arr[1]||0)+(arr[2]||0);
  const concentration = clamp(top3/sum, 0, 1); // 0..1
  const adj = clamp((concentration - 0.30) * 10, 0, 5); // at√© +5 pontos na meta
  return { adj, concentration };
}

function computeRiskPenalty(state, examId){
  const now = Date.now();
  const errors = filterByExam(state.errors || [], examId);
  const traps = filterByExam(state.traps || [], examId);
  const overdue = errors.filter(e=> e.nextReviewAt && new Date(e.nextReviewAt).getTime() < now).length;

  // at√© -6 pontos (leve, mas real)
  const pen = clamp((overdue*0.25) + (errors.length*0.03) + (traps.length*0.02), 0, 6);
  return { pen, overdue, errors: errors.length, traps: traps.length };
}

function sigmoid(z){ return 1/(1+Math.exp(-z)); }

function computeApprovalModeloC(state, examId){
  const cutoff = getExamCutoffRef(examId);
  const aggro = getAggro(); // 0.5..1.5
  const aggroAdj = clamp((aggro - 1) * 4, -2, 4);

  const { acc, sample, perDisc } = computeWeightedAccuracy(state, examId, 240);
  const trend = computeTrendFactor(state, examId);
  const volume = computeVolumeFactor(state, examId);
  const time = computeTimeFactor(state, examId);
  const structure = computeStructureAdj(examId);
  const risk = computeRiskPenalty(state, examId);

  // score previsto em % (0..100)
  let predicted = clamp((acc * 100) * trend * volume * time - risk.pen, 0, 100);

  // meta ajustada
  const target = clamp(cutoff + structure.adj + aggroAdj, 0, 100);
  const delta = predicted - target;

  // probabilidade: incerteza cai com amostra
  const sigma = 10 - clamp(Math.sqrt(sample) * 0.35, 0, 6);
  const prob = clamp(sigmoid(delta / Math.max(2.5, sigma)), 0, 1);

  // confian√ßa (0..100)
  const conf = clamp((Math.sqrt(sample)/16)*100, 5, 95);

  // avgTime (min) nas √∫ltimas 200 quest√µes (se preenchido)
  const _tqs = getRecentAnswered(state, examId, 200).filter(q=>Number.isFinite(Number(q.timeMin)) && Number(q.timeMin)>0);
  const avgTime = _tqs.length ? (_tqs.reduce((s,q)=>s+Number(q.timeMin),0)/_tqs.length) : null;

  // gaps ponderados: onde d√≥i mais (peso x falta de acerto)
  const _weights = getExamWeights(examId) || {};
  const gaps = Object.keys(_weights).filter(k=>k!=="discWeights").map(d=>{
    const w = Math.max(0.01, Number(_weights[d]||1));
    const a = perDisc[d] ? perDisc[d].acc : acc;
    const gap = (1-a)*100*w;
    return { disc:d, w, acc: Math.round(a*100), gap };
  }).sort((a,b)=>b.gap-a.gap).slice(0,6);

  return {
    examId,
    predicted: Math.round(predicted),
    target: Math.round(target),
    delta: Math.round(delta),
    prob: Math.round(prob*100),
    conf: Math.round(conf),
    sample,
    cutoff,
    aggro,
    structureAdj: Math.round(structure.adj*10)/10,
    concentration: Math.round(structure.concentration*100),
    risk,
    perDisc,
    avgTime: (avgTime==null? null : Math.round(avgTime*10)/10),
    gaps,
  };
}

/* =========================================================
   MODULE: Decis√£o do Dia (prioriza√ß√£o autom√°tica)
   ========================================================= */

function getExamTimeTarget(examId){
  // minutos por quest√£o (edit√°vel futuramente; default 1.8)
  const key = "SAPE_TIME_TARGET::" + examId;
  const n = Number(loadJSON(key, 1.8));
  return Number.isFinite(n) && n>0 ? n : 1.8;
}

function computeDecisionOfDay(state, examId){
  const mc = computeApprovalModeloC(state, examId);
  const qsAll = filterByExam(state.questions || [], examId)
    .filter(q => q && typeof q === "object" && q.isCorrect !== null);

  // Disciplina com maior "dor" ponderada (gap * peso)
  const topGap = (mc.gaps && mc.gaps.length) ? mc.gaps[0] : null;

  // Tempo
  const targetTime = getExamTimeTarget(examId);
  const timeMsg = (mc.avgTime != null && mc.avgTime > targetTime)
    ? `Reduzir tempo m√©dio (${mc.avgTime} min > ${targetTime} min)`
    : null;

  // Erros vencidos
  const overdue = mc.risk && Number.isFinite(Number(mc.risk.overdue)) ? mc.risk.overdue : 0;

  // Tend√™ncia (√∫ltimas 20 vs anteriores 20)
  const recent = qsAll.slice(-40);
  let trendMsg = null;
  if(recent.length >= 30){
    const half = Math.floor(recent.length/2);
    const a = recent.slice(0, half);
    const b = recent.slice(half);
    const acc = arr => arr.length ? (arr.filter(x=>x.isCorrect===true).length / arr.length) : 0;
    const delta = acc(b) - acc(a);
    if(delta < -0.05) trendMsg = `Tend√™ncia caiu (‚àí${Math.round(Math.abs(delta)*100)}%). Rever base + fazer bloco f√°cil.`;
    else if(delta > 0.05) trendMsg = `Tend√™ncia subiu (+${Math.round(delta*100)}%). Manter e aumentar dificuldade.`;
  }

  const actions = [];
  if(topGap){
    actions.push({
      key:"gap",
      text:`Priorizar ${topGap.disc} (peso ${Number(topGap.w).toFixed(2)}x, acerto ${topGap.acc}%)`
    });
  }
  if(timeMsg) actions.push({ key:"time", text: timeMsg });
  if(overdue > 0) actions.push({ key:"errors", text:`Revisar ${overdue} erro(s) vencido(s) hoje` });
  if(trendMsg) actions.push({ key:"trend", text: trendMsg });

  if(!actions.length){
    actions.push({ key:"maintain", text:"Manter ritmo: 30‚Äì50 quest√µes + revisar 5 erros." });
  }

  return actions.slice(0,3);
}

function pct(n){ return Math.round(n*100); }

function computeExamStats(state, examId){
  const qs = (state.questions||[]).filter(q=> q.examId === examId);
  const es = (state.errors||[]).filter(e=> e.examId === examId);
  const ts = (state.traps||[]).filter(t=> t.examId === examId);

  const last100 = qs.slice(0,100);
  const acc = last100.length ? (last100.filter(q=>q.isCorrect===true).length / last100.length) : 0;

  const discs = new Set(qs.map(q=> (q.disc||"(sem disciplina)").trim() || "(sem disciplina)"));
  const topics = new Set(qs.map(q=> (q.topic||"").trim()).filter(Boolean));

  // Coverage proxy: more unique disciplines and topics ‚Üí better coverage
  const discScore = clamp(discs.size / 12, 0, 1);         // assume ~12 core disciplines as "full"
  const topicScore = clamp(topics.size / 60, 0, 1);       // assume ~60 topics as "broad"
  const volScore = clamp(Math.log10(qs.length + 1) / 3, 0, 1); // ~1000 qs ‚Üí ~1
  const errPenalty = clamp((es.length + ts.length) / 300, 0, 1); // 300+ items ‚Üí max penalty

  // Maturity: weighted blend (tunable)
  const maturity = clamp((acc*0.45) + (volScore*0.25) + (discScore*0.15) + (topicScore*0.15) - (errPenalty*0.10), 0, 1);

  return {
    examId,
    qTotal: qs.length,
    acc: acc,
    accPct: pct(acc),
    discs: discs.size,
    topics: topics.size,
    errors: es.length,
    traps: ts.length,
    maturity,
    maturityPct: pct(maturity)
  };
}

function mountCompare(){
  const app = document.getElementById("app");
  const state = store.getState();
  const active = getActiveExam();

  const stats = Object.keys(EXAMS).map(id=> computeExamStats(state, id))
    .sort((a,b)=> b.maturity - a.maturity);

  const rows = stats.map(s=>`
    <tr>
      <td><span class="badge">${escapeHtml(s.examId)}</span></td>
      <td><b>${escapeHtml(EXAMS[s.examId]?.name || s.examId)}</b>${s.examId===active?` <span class="pill">ativo</span>`:""}</td>
      <td>${s.maturityPct}%</td>
      <td>${s.accPct}%</td>
      <td>${s.qTotal}</td>
      <td>${s.discs}</td>
      <td>${s.topics}</td>
      <td>${s.errors}</td>
      <td>${s.traps}</td>
      <td><button class="btn" data-set-exam="${escapeHtml(s.examId)}">Ativar</button></td>
    </tr>
  `).join("");

  const best = stats[0];
  const act = stats.find(x=>x.examId===active);

  app.innerHTML = `
    <div class="section-title">
      <h2>Comparativo</h2>
      <div class="tiny muted">Painel de maturidade por concurso (separado do Dashboard).</div>
    </div>

    <div class="statgrid">
      <div class="statcard">
        <div class="h">Mais maduro agora</div>
        <div class="v">${escapeHtml(EXAMS[best?.examId]?.name || best?.examId || "-")}</div>
        <div class="tiny muted">maturidade: ${best?best.maturityPct:0}% ‚Ä¢ acur√°cia: ${best?best.accPct:0}%</div>
      </div>
      <div class="statcard">
        <div class="h">Concurso ativo</div>
        <div class="v">${escapeHtml(EXAMS[active]?.name || active)}</div>
        <div class="tiny muted">maturidade: ${act?act.maturityPct:0}% ‚Ä¢ quest√µes: ${act?act.qTotal:0}</div>
      </div>
      <div class="statcard">
        <div class="h">Como subir r√°pido</div>
        <div class="v">+5‚Äì10 pts</div>
        <div class="tiny muted">aumente volume + corrija erros cr√≠ticos (ver Caderno de erros)</div>
      </div>
    </div>

    <div class="hr"></div>

    <div class="statcard">
      <div class="h">Tabela comparativa</div>
      <div class="tiny muted">Maturidade combina acur√°cia (√∫ltimas 100), volume, cobertura (disciplinas/t√≥picos) e penaliza ac√∫mulo de erros/pegadinhas.</div>
      <table>
        <thead>
          <tr>
            <th>ID</th><th>Concurso</th><th>Maturidade</th><th>Acur√°cia</th><th>Quest√µes</th><th>Disciplinas</th><th>T√≥picos</th><th>Erros</th><th>Pegadinhas</th><th></th>
          </tr>
        </thead>
        <tbody>
          ${rows || `<tr><td colspan="10" class="tiny muted">Sem dados ainda ‚Äî registre quest√µes/erros por concurso.</td></tr>`}
        </tbody>
      </table>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <h3 style="margin:0">Pesos por disciplina (opcional)</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn" id="weightsReset">Resetar</button>
          <button class="btn primary" id="weightsSave">Salvar</button>
        </div>
      </div>
      <div class="muted" style="margin-top:6px">
        Ajuste fino para refletir seu edital/√™nfase. Impacta metas, recomenda√ß√µes e simulados.
      </div>
      <div id="weightsEditor" style="margin-top:10px"></div>
    </div>
  `;

  app.querySelectorAll("button[data-set-exam]").forEach(b=>{
    b.onclick = ()=>{
      const id = b.getAttribute("data-set-exam");
      setActiveExamAndSyncProfile(id);
      toast("Concurso ativo: " + (EXAMS[id]?.name || id));
      go("dashboard");
    };
  });

  // === Editor de pesos por disciplina (opcional) ===
  const weightsEl = app.querySelector("#weightsEditor");
  const btnSave = app.querySelector("#weightsSave");
  const btnReset = app.querySelector("#weightsReset");

  function renderWeights(){
    const active = getActiveExam();
    const discs = listDiscsForExam(state, active);
    const base = (EXAMS[active] && EXAMS[active].weights) ? EXAMS[active].weights : {};
    const custom = loadExamWeights(active);
    const merged = getExamWeights(active);

    if(!weightsEl){ return; }
    if(discs.length===0){
      weightsEl.innerHTML = '<div class="muted">Sem disciplinas registradas ainda. Adicione algumas Quest√µes/Erros para popular a lista.</div>';
      return;
    }

    weightsEl.innerHTML = `
      <div style="overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Disciplina</th>
              <th style="text-align:right">Peso</th>
              <th class="hide-sm" style="text-align:right">Base</th>
              <th class="hide-sm">Obs.</th>
            </tr>
          </thead>
          <tbody>
            ${discs.map((d,i)=>{
              const v = Number(merged[d] ?? 1);
              const b = Number(base[d] ?? 1);
              const isCustom = Object.prototype.hasOwnProperty.call(custom, d);
              const note = isCustom ? "custom" : (Object.prototype.hasOwnProperty.call(base,d) ? "base" : "1.0");
              return `
                <tr>
                  <td>${escapeHTML(d)}</td>
                  <td style="text-align:right">
                    <input class="input" data-w-disc="${escapeHTML(d)}" value="${String(v)}" inputmode="decimal" style="max-width:110px;text-align:right">
                  </td>
                  <td class="hide-sm" style="text-align:right">${String(b)}</td>
                  <td class="hide-sm"><span class="chip">${note}</span></td>
                </tr>`;
            }).join("")}
          </tbody>
        </table>
      </div>
    `;
  }

  function readWeightsFromUI(){
    const active = getActiveExam();
    const inputs = Array.from(app.querySelectorAll("input[data-w-disc]"));
    const out = {};
    inputs.forEach(inp=>{
      const disc = inp.getAttribute("data-w-disc");
      let val = Number(String(inp.value).replace(",", "."));
      if(!Number.isFinite(val) || val<=0) val = 1;
      out[disc] = Math.round(val*100)/100;
    });
    return out;
  }

  if(btnSave){
    btnSave.onclick = ()=>{
      const active = getActiveExam();
      const base = (EXAMS[active] && EXAMS[active].weights) ? EXAMS[active].weights : {};
      const all = readWeightsFromUI();

      // salva apenas diferen√ßas do base para manter storage leve
      const diff = {};
      Object.keys(all).forEach(d=>{
        const v = all[d];
        const b = Number(base[d] ?? 1);
        if(Math.abs(v - b) > 0.001) diff[d] = v;
      });

      saveExamWeights(active, diff);
      toast("Pesos salvos para " + (EXAMS[active]?.name || active));
      renderWeights();
    };
  }
  if(btnReset){
    btnReset.onclick = ()=>{
      const active = getActiveExam();
      resetExamWeights(active);
      toast("Pesos resetados para " + (EXAMS[active]?.name || active));
      renderWeights();
    };
  }

  renderWeights();



  return ()=>{};
}

function mountSim(){

const NB_DRAFT_KEY = "SAPE_NB_DRAFT";
function setNotebookDraftFromQuestion(q, isCorrect){
  try{
    if(!q) return;
    if(isCorrect===false){
      const draft = {
        disc: q.disc || "",
        topic: q.topic || "",
        mode: "error",
        from: "simulado",
        createdAt: new Date().toISOString(),
        err: {
          prompt: (q.qtext||"").slice(0,420),
          why: "",
          fix: "",
          tags: ["simulado"],
          priority: "media",
          nextDays: 3
        }
      };
      try{ sessionStorage.setItem(NB_DRAFT_KEY, JSON.stringify(draft)); }catch(e){}
      try{ sessionStorage.setItem("SAPE_NB_MODE","error"); }catch(e){}
    }
  }catch(e){}
}
  const app = document.getElementById("app");
  const active = getActiveExam();
  const examName = (EXAMS[active] && EXAMS[active].name) ? EXAMS[active].name : active;

  let session = { running:false, idx:0, items:[], startedAt:null, total:20, mode:"risco", timeLimitMin:60, done:false };

  function buildSession(){
    const state = store.getState();
    const pool = filterByExam(state.questions || []).filter(q=> (q.qtext||"").trim().length>0);
    const unseen = pool.filter(q=> q.isCorrect === null);
    const basePool = unseen.length >= 20 ? unseen : pool;

    const N = Math.max(10, Math.min(120, Number(session.total)||20));
    const mode = session.mode;

    const items = [];
    if(basePool.length){
      const used = new Set();
      for(let i=0;i<N;i++){
        let pick = null;
        if(mode === "risco"){
          const targetDisc = sampleWeightedDisc(store.getState());
          const candidates = basePool.filter(q=> (q.disc||"(sem disciplina)") === targetDisc && !used.has(q.id));
          if(candidates.length){
            pick = candidates[Math.floor(Math.random()*candidates.length)];
          }
        }
        if(!pick){
          let tries = 0;
          while(tries<50){
            const q = basePool[Math.floor(Math.random()*basePool.length)];
            if(!used.has(q.id)){ pick = q; break; }
            tries++;
          }
          if(!pick) pick = basePool[Math.floor(Math.random()*basePool.length)];
        }
        used.add(pick.id);
        items.push({ disc: pick.disc || "(sem disciplina)", topic: pick.topic || "", qtext: pick.qtext || "", answerKey: pick.answerKey || "" });
      }
    }else{
      for(let i=0;i<N;i++){
        const d = (mode==="risco") ? sampleWeightedDisc(store.getState()) : "(sem disciplina)";
        items.push({ disc:d, topic:"", qtext:"(registre aqui a quest√£o que voc√™ fez)", answerKey:"" });
      }
    }

    session = { ...session, running:true, idx:0, items, startedAt: Date.now(), done:false };
    render();
  }

  function stopSession(){
    session = { ...session, running:false, done:false };
    render();
  }

  function elapsedMin(){
    if(!session.startedAt) return 0;
    return Math.floor((Date.now() - session.startedAt)/60000);
  }

  function recordAnswer(isCorrect){
    const it = session.items[session.idx];
    if(!it) return;
    const notesEl = document.getElementById("simNotes");
    const ansEl = document.getElementById("simAns");
    const userAnswer = ansEl ? ansEl.value : "";
    const notes = notesEl ? notesEl.value : "";

    // Try to dispatch using existing action types
    const payload = sanitizeQuestion({
      examId: active,
      disc: it.disc,
      topic: it.topic,
      bank: "",
      source: "Simulado",
      qtext: it.qtext,
      answerKey: it.answerKey,
      userAnswer,
      isCorrect: !!isCorrect,
      notes
    });

    try{
      store.dispatch({ type:"ADD_QUESTION", payload });
    }catch{
      // fallback: some builds use ADD_QUESTIONS (batch)
      try{ store.dispatch({ type:"ADD_QUESTIONS", payload: [payload] }); }catch{}
    }

// v3.0: desempenho mudou -> invalida matriz e atualiza revis√µes/bloco0
try{ invalidateMatrixCacheForExam(active); }catch(e){}
emitML("ML:PERF_LOGGED", { source:"simulado", examId: active });
emitML("ML:REVIEWS_UPDATED", { source:"simulado" });

    const nextIdx = session.idx + 1;
    if(nextIdx >= session.items.length){
      session = { ...session, idx: nextIdx, running:false, done:true };
    }else{
      session = { ...session, idx: nextIdx };
    }
    render();
  }

  function render(){
    const s = store.getState();
    const qAll = filterByExam(s.questions || []);
    const last = qAll.slice(0,50);
    const acc = last.length ? Math.round((last.filter(x=>x.isCorrect===true).length/last.length)*100) : 0;

    const running = session.running;
    const idx = session.idx;
    const it = running ? session.items[idx] : null;
    const remaining = running ? (session.items.length - idx) : 0;

    app.innerHTML = `
      <div class="section-title">
        <h2>Simulados</h2>
        <div class="tiny muted">Concurso ativo: <b>${escapeHtml(examName)}</b></div>
      </div>

      <div class="statgrid">
        <div class="statcard"><div class="h">Acur√°cia (√∫ltimas 50)</div><div class="v">${acc}%</div><div class="tiny muted">Baseado no concurso ativo</div></div>
        <div class="statcard"><div class="h">Status</div><div class="v">${running ? "Em andamento" : "Pronto"}</div><div class="tiny muted">${running ? `Quest√£o ${idx+1}/${session.items.length}` : "Monte um simulado"}</div></div>
        <div class="statcard"><div class="h">Tempo</div><div class="v">${running ? `${elapsedMin()} min` : "-"}</div><div class="tiny muted">Limite: ${session.timeLimitMin} min</div></div>
      </div>

      <div class="hr"></div>

      <div class="statcard">
        <div class="h">Simulado Prova Real</div>
        <div class="tiny muted">Modo ‚ÄúRisco‚Äù prioriza disciplinas com peso alto. Se voc√™ ainda n√£o registrou quest√µes, ele gera placeholders por disciplina.</div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:flex-end;">
          <label class="tiny muted">Quest√µes<br>
            <input id="simN" class="input" type="number" min="10" max="120" value="${escapeHtml(String(session.total))}" style="width:120px;">
          </label>
          <label class="tiny muted">Tempo (min)<br>
            <input id="simT" class="input" type="number" min="10" max="240" value="${escapeHtml(String(session.timeLimitMin))}" style="width:140px;">
          </label>
          <label class="tiny muted">Modo<br>
            <select id="simMode" class="input" style="width:220px;">
              <option value="risco" ${session.mode==="risco"?"selected":""}>Risco (adaptativo)</option>
              <option value="aleatorio" ${session.mode==="aleatorio"?"selected":""}>Aleat√≥rio</option>
            </select>
          </label>

          ${running ? `
            <button class="btn" id="simStop">Encerrar</button>
          ` : `
            <button class="btn primary" id="simStart">Come√ßar simulado</button>
          `}
        </div>
      </div>

      ${running && it ? `
        <div class="hr"></div>
        <div class="statcard">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
            <div>
              <div class="h">Quest√£o ${idx+1}/${session.items.length}</div>
              <div class="tiny muted"><b>${escapeHtml(it.disc || "(sem disciplina)")}</b>${it.topic?` ‚Ä¢ ${escapeHtml(it.topic)}`:""}</div>
            </div>
            <div class="badge">${remaining} restantes</div>
          </div>

          <div class="note" style="margin-top:12px;white-space:pre-wrap;">${escapeHtml(it.qtext || "")}</div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
            <input id="simAns" class="input" placeholder="Sua resposta (opcional)" style="flex:1;min-width:240px;">
            <input id="simNotes" class="input" placeholder="Notas r√°pidas (opcional)" style="flex:2;min-width:260px;">
          </div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
            <button class="btn primary" id="simRight">Acertei</button>
            <button class="btn" id="simWrong">Errei</button>
          </div>
        </div>
      ` : ``}

      
      ${(!running && session.done) ? renderReport() : ``}

    `;

    const simN = document.getElementById("simN");
    const simT = document.getElementById("simT");
    const simMode = document.getElementById("simMode");
    const startBtn = document.getElementById("simStart");
    const stopBtn = document.getElementById("simStop");

    if(simN) simN.onchange = ()=>{ session.total = Number(simN.value)||20; };
    if(simT) simT.onchange = ()=>{ session.timeLimitMin = Number(simT.value)||60; };
    if(simMode) simMode.onchange = ()=>{ session.mode = simMode.value; };

    if(startBtn) startBtn.onclick = ()=>{
      session.total = Number(simN.value)||20;
      session.timeLimitMin = Number(simT.value)||60;
      session.mode = simMode.value;
      buildSession();
    };
    if(stopBtn) stopBtn.onclick = ()=> stopSession();

    const rBtn = document.getElementById("simRight");
    const wBtn = document.getElementById("simWrong");
    if(rBtn) rBtn.onclick = ()=> recordAnswer(true);
    if(wBtn) wBtn.onclick = ()=> recordAnswer(false);
  }

  function renderReport(){
    const state = store.getState();
    const active = getActiveExam();
    const examName = (EXAMS[active] && EXAMS[active].name) ? EXAMS[active].name : active;

    const simQuestions = filterByExam(state.questions || []).slice(0, session.total);

    const total = session.items.length;
    const correct = simQuestions.filter(q=>q.isCorrect===true).length;
    const wrong = total - correct;
    const percent = total ? Math.round((correct/total)*100) : 0;

    // discipline breakdown
    const discMap = {};
    for(const q of simQuestions){
      const d = q.disc || "(sem disciplina)";
      if(!discMap[d]) discMap[d] = { total:0, correct:0 };
      discMap[d].total++;
      if(q.isCorrect===true) discMap[d].correct++;
    }

    const rows = Object.entries(discMap).map(([disc,data])=>{
      const err = data.total - data.correct;
      const pct = data.total ? Math.round((data.correct/data.total)*100) : 0;
      return `<tr>
        <td>${escapeHtml(disc)}</td>
        <td>${data.correct}/${data.total}</td>
        <td>${pct}%</td>
        <td>${err}</td>
      </tr>`;
    }).join("");

    return `
      <div class="section-title">
        <h2>Relat√≥rio do Simulado</h2>
        <div class="tiny muted">Concurso: <b>${escapeHtml(examName)}</b></div>
      </div>

      <div class="statgrid">
        <div class="statcard">
          <div class="h">Resultado Geral</div>
          <div class="v">${correct}/${total}</div>
          <div class="tiny muted">${percent}% de acerto</div>
        </div>
        <div class="statcard">
          <div class="h">Erros</div>
          <div class="v">${wrong}</div>
          <div class="tiny muted">Total de quest√µes erradas</div>
        </div>
        <div class="statcard">
          <div class="h">Tempo</div>
          <div class="v">${Math.floor((Date.now()-session.startedAt)/60000)} min</div>
          <div class="tiny muted">Tempo utilizado</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="statcard">
        <div class="h">Desempenho por Disciplina</div>
        <table>
          <thead>
            <tr>
              <th>Disciplina</th>
              <th>Acertos</th>
              <th>%</th>
              <th>Erros</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>

      <div class="hr"></div>

      <div style="display:flex;gap:12px;flex-wrap:wrap;">
        <button class="btn primary" onclick="go('sim')">Novo Simulado</button>
        <button class="btn" onclick="go('dashboard')">Voltar ao Dashboard</button>
      </div>
    `;
  }


  render();
  return ()=>{};
}

function computeFocusScore(mc){
  // score semanal: prob (peso) + delta + confian√ßa - risco
  const prob = Number(mc.prob||0);
  const conf = Number(mc.conf||0);
  const delta = Number(mc.delta||0);
  const risk = mc.risk && Number.isFinite(Number(mc.risk.pen)) ? Number(mc.risk.pen) : 0;
  const confW = 0.6 + 0.4*(conf/100);
  return (prob*confW) + (delta*0.6) - (risk*6);
}

function computeWeeklyFocus(state){
  const ids = Object.keys(EXAMS||{});
  const items = ids.map(id=>{
    const mc = computeApprovalModeloC(state, id);
    const score = computeFocusScore(mc);
    return { id, mc, score };
  }).sort((a,b)=> b.score - a.score);

  const primary = items[0] || null;
  const secondary = items[1] || null;

  // define ‚Äúpausa‚Äù para os bem abaixo (prob < 35 ou confian√ßa muito baixa)
  const paused = items.filter(x=> (x.mc.prob < 35 && x.mc.conf < 45) || x.mc.sample < 60);

  return { items, primary, secondary, paused };
}

function buildWeeklyPlan(state, examId){
  const mc = computeApprovalModeloC(state, examId);
  const discs = (mc.gaps||[]).map(g=>g.disc).filter(Boolean);

  // fallback: pega do template do edital
  const w = getExamWeights(examId) || {};
  if(discs.length < 2){
    Object.keys(w).filter(k=>k!=="discWeights").slice(0,8).forEach(d=> discs.push(d));
  }

  // garante 6 disciplinas no ciclo
  const cycle = Array.from(new Set(discs)).slice(0,6);
  const overdue = mc.risk && Number.isFinite(Number(mc.risk.overdue)) ? mc.risk.overdue : 0;

  const days = ["Seg", "Ter", "Qua", "Qui", "Sex", "S√°b", "Dom"];
  const out = [];
  for(let i=0;i<7;i++){
    const d1 = cycle[i % cycle.length];
    const d2 = cycle[(i+1) % cycle.length];
    const blocks = [];
    blocks.push(`Quest√µes: 40‚Äì60 (foco em ${d1})`);
    blocks.push(`Teoria r√°pida: 30‚Äì45 min (${d2})`);
    if(overdue>0) blocks.push(`Revis√£o: ${Math.min(overdue, 6)} erros vencidos`);
    if(i===2 || i===5) blocks.push("Simulado curto: 20 quest√µes (misto, cronometrado)");
    out.push({ day: days[i], d1, d2, blocks });
  }
  return { cycle, out };
}

function mountRadar(){
  const state = store.getState();
  const active = getActiveExam();
  const focus = computeWeeklyFocus(state);

  const rows = focus.items.map(x=>{
    const mc = x.mc;
    const status =
      mc.prob >= 70 ? "Forte" :
      mc.prob >= 55 ? "Competitivo" :
      mc.prob >= 40 ? "Na briga" : "Constru√ß√£o";
    return `
      <tr>
        <td><b>${escapeHtml(EXAMS[x.id]?.name || x.id)}</b><div class="tiny muted">${escapeHtml(x.id)}</div></td>
        <td><b>${mc.prob}%</b> <span class="badge">${escapeHtml(status)}</span></td>
        <td>${mc.delta}</td>
        <td>${mc.conf}%</td>
        <td>${Math.round((mc.risk?.pen||0)*10)/10}</td>
        <td>${mc.sample}</td>
        <td><button class="btn" data-set-exam="${escapeHtml(x.id)}">Ativar</button></td>
      </tr>
    `;
  }).join("");

  const primaryId = (focus.primary && focus.primary.id) ? focus.primary.id : active;
  const plan = buildWeeklyPlan(state, primaryId);

  const planHtml = plan.out.map(p=>`
    <tr>
      <td><b>${p.day}</b></td>
      <td>${escapeHtml(p.d1)}</td>
      <td>${escapeHtml(p.d2)}</td>
      <td class="tiny">${p.blocks.map(b=>`‚Ä¢ ${escapeHtml(b)}`).join("<br>")}</td>
    </tr>
  `).join("");

  const app = document.getElementById("app");
  app.innerHTML = `
    <div class="grid">
      <div class="card">
        <div class="section-title">
          <h2>Radar Geral</h2>
          <span class="pill">Foco sugerido da semana: <b>${escapeHtml(EXAMS[primaryId]?.name || primaryId)}</b></span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Concurso</th>
              <th>Prob</th>
              <th>Œî</th>
              <th>Conf</th>
              <th>Risco</th>
              <th>Amostra</th>
              <th></th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
        <div class="note" style="margin-top:10px;">
          * ‚ÄúFoco da semana‚Äù prioriza probabilidade + confian√ßa + delta, e desconta risco (erros/pegadinhas). Use como guia, n√£o como pris√£o.
        </div>
      </div>

      <div class="card">
        <div class="section-title">
          <h2>Plano autom√°tico 7 dias</h2>
          <span class="pill">Ciclo: ${plan.cycle.map(d=>escapeHtml(d)).join(" ‚Ä¢ ")}</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>Dia</th>
              <th>Bloco 1</th>
              <th>Bloco 2</th>
              <th>Checklist</th>
            </tr>
          </thead>
          <tbody>${planHtml}</tbody>
        </table>
        <div class="note" style="margin-top:10px;">
          Dica: se voc√™ tiver pouco tempo em um dia, fa√ßa s√≥ o bloco de <b>quest√µes</b> + <b>revis√£o de erros</b>.
        </div>
      </div>
    </div>
  `;

  // bind activate buttons
  app.querySelectorAll('[data-set-exam]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      setActiveExamAndSyncProfile(btn.getAttribute("data-set-exam"));
      toast("Concurso ativo atualizado.");
      // refresh dashboard as well? keep in radar but update pills
      document.querySelector('.tab[data-tab="dashboard"]')?.click();
    });
  });

  return ()=>{};
}


function mountNotebook(){
  const app = document.getElementById("app");
  const DRAFT_KEY = "SAPE_NB_DRAFT";

  function getDisciplines(examId){
    const cur = CURRICULUM[examId] || {};
    return Object.keys(cur);
  }
  function getTopics(examId, disc){
    const cur = CURRICULUM[examId] || {};
    return Array.isArray(cur[disc]) ? cur[disc] : [];
  }
  function getEntry(state, examId, disc, topic){
    const nb = (state.notebook && typeof state.notebook==="object") ? state.notebook : {};
    const ex = nb[examId] || {};
    const d  = ex[disc] || {};
    return (d[topic] && typeof d[topic]==="object") ? d[topic] : {};
  }

  function render(){
    const state = store.getState();
    const examId = getActiveExam();
    const discs = getDisciplines(examId);
    const draftRaw = sessionStorage.getItem(DRAFT_KEY);
    const draft = draftRaw ? safeJSONParse(draftRaw, null) : null;
    const nbMode = sessionStorage.getItem("SAPE_NB_MODE") || (draft && draft.mode) || "normal";

    const defaultDisc = draft?.disc || discs[0] || "";
    const topics = defaultDisc ? getTopics(examId, defaultDisc) : [];
    const defaultTopic = draft?.topic || topics[0] || "";
    const entry = (defaultDisc && defaultTopic) ? getEntry(state, examId, defaultDisc, defaultTopic) : {};

    app.innerHTML = `
      <div class="wrap">
        <div class="card">
          <div class="section-title">
            <h2>Caderno Inteligente</h2>

<div class="row" style="display:grid;grid-template-columns:360px 1fr;gap:14px;align-items:end;">
  <div>
    <label>Modo do Caderno</label>
    <select id="nbMode">
      <option value="normal" ${nbMode==="normal"?"selected":""}>Caderno Normal</option>
      <option value="error" ${nbMode==="error"?"selected":""}>Registrar Erro / Revis√£o</option>
    </select>

    <div id="nbErrorExtras" style="margin-top:10px; ${nbMode==="error"?"":"display:none;"}">
      <label class="tiny muted">Tipo do erro</label>
      <select id="errorType" class="input">
        <option value="conceito">Conceito</option>
        <option value="lei">Lei seca</option>
        <option value="juris">Jurisprud√™ncia</option>
        <option value="pegadinha">Pegadinha (banca)</option>
        <option value="desatencao">Desaten√ß√£o</option>
      </select>
    </div>
  </div>

  <div class="note" style="margin:0;">
    Use <b>Registrar Erro</b> para transformar erros em material de revis√£o e alimentar o <b>Bloco 0</b>.
  </div>
</div>
<span class="pill">${escapeHtml(EXAMS[examId]?.name || examId)}</span>
          </div>

          <div class="row" style="display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:end;">
            <div>
              <div class="tiny muted" style="margin-bottom:6px;">Selecione disciplina e t√≥pico</div>
              <label>Disciplina</label>
              <select id="nbDisc">
                ${discs.map(d=>`<option ${d===defaultDisc?'selected':''}>${escapeHtml(d)}</option>`).join("")}
              </select>
            </div>
            <div>
              <label>T√≥pico</label>
              <select id="nbTopic">
                ${topics.map(t=>`<option ${t===defaultTopic?'selected':''}>${escapeHtml(t)}</option>`).join("")}
              </select>
            </div>
          </div>

          <div class="hr"></div>

          <div id="nbPanelNormal">
          <div class="row">
            <div>
              <label>Conceito (com suas palavras)</label>
              <textarea id="nbConcept" rows="3" placeholder="Explique como se estivesse ensinando...">${escapeHtml(entry.concept||"")}</textarea>
            </div>
            <div>
              <label>Exce√ß√µes importantes</label>
              <textarea id="nbExceptions" rows="3" placeholder="Regra x exce√ß√£o (o que derruba)">${escapeHtml(entry.exceptions||"")}</textarea>
            </div>
          </div>

          <div class="row">
            <div>
              <label>Como a banca cobra</label>
              <textarea id="nbHow" rows="3" placeholder="Pegadinhas, padr√µes, palavras-chave">${escapeHtml(entry.how||"")}</textarea>
            </div>
            <div>
              <label>Base legal</label>
              <textarea id="nbLegal" rows="3" placeholder="Artigos/lei e pontos-chave">${escapeHtml(entry.legal||"")}</textarea>
            </div>
          </div>

          <div class="row">
            <div>
              <label>Jurisprud√™ncia relevante</label>
              <textarea id="nbJuris" rows="3" placeholder="S√∫mulas, OJs, temas, entendimentos">${escapeHtml(entry.juris||"")}</textarea>
            </div>
            <div>
              <label>Erros cometidos (o que voc√™ confundiu)</label>
              <textarea id="nbMistakes" rows="3" placeholder="Liste erros e o porqu√™">${escapeHtml(entry.mistakes||"")}</textarea>
            </div>
          </div>

          <div class="row">
            <div>
              <label>Pegadinhas recorrentes</label>
              <textarea id="nbTraps" rows="3" placeholder="Ex.: troca de conceito, prazo, exce√ß√£o...">${escapeHtml(entry.traps||"")}</textarea>
            </div>
            <div>
              <label>Campo livre</label>
              <textarea id="nbFree" rows="3" placeholder="Esquemas, analogias, compara√ß√µes...">${escapeHtml(entry.free||"")}</textarea>
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <div class="actions">
              <button class="btn" id="nbSave">Salvar</button>
              <button class="btn" id="nbClear">Limpar t√≥pico</button>
            </div>
            <div class="tiny muted" style="align-self:center;">
              ${entry.updatedAt ? "√öltima atualiza√ß√£o: "+escapeHtml(fmtDateTime(entry.updatedAt)) : "Ainda n√£o salvo para este t√≥pico."}
            </div>
          </div>

          
          </div><!-- /nbPanelNormal -->

          <div id="nbPanelError" style="display:none">
            <div class="row">
              <div>
                <label>Tipo de erro</label>
                <select id="nbErrType">
                  <option value="conceito">Conceito</option>
                  <option value="excecao">Exce√ß√£o / detalhe</option>
                  <option value="prazo">Prazo / procedimento</option>
                  <option value="juris">Jurisprud√™ncia</option>
                  <option value="interpretacao">Interpreta√ß√£o</option>
                  <option value="pegadinha">Pegadinha (banca)</option>
                  <option value="atencao">Aten√ß√£o / pressa</option>
                  <option value="outro">Outro</option>
                </select>
              </div>
              <div>
                <label>Prioridade</label>
                <select id="nbErrPriority">
                  <option value="alta">Alta</option>
                  <option value="media" selected>M√©dia</option>
                  <option value="baixa">Baixa</option>
                </select>
              </div>
            </div>

            <label>Enunciado/Resumo do que caiu</label>
            <textarea id="nbErrPrompt" rows="2" placeholder="Resumo curto da quest√£o/situa√ß√£o..."></textarea>

            <label>Por que voc√™ errou (1 frase)</label>
            <textarea id="nbErrWhy" rows="2" placeholder="Ex.: confundi compet√™ncia material x territorial; li r√°pido; peguei pegadinha..."></textarea>

            <label>Regra correta / revis√£o pronta</label>
            <textarea id="nbErrFix" rows="3" placeholder="Escreva a revis√£o que voc√™ quer reler depois (curta, objetiva)."></textarea>

            <div class="row" style="margin-top:10px;">
              <div>
                <label>Tags (separe por v√≠rgula)</label>
                <input id="nbErrTags" class="input" placeholder="Ex.: compet√™ncia, CF, artigo 114, exce√ß√£o..." />
              </div>
              <div>
                <label>Pr√≥xima revis√£o</label>
                <select id="nbErrNext">
                  <option value="1">Amanh√£</option>
                  <option value="3" selected>3 dias</option>
                  <option value="7">7 dias</option>
                  <option value="14">14 dias</option>
                </select>
              </div>
            </div>

            <div class="actions" style="margin-top:10px;">
              <button class="btn primary" id="nbErrSave">Registrar erro ‚úì</button>
              <button class="btn" id="nbErrClear">Limpar</button>
            </div>

            <div class="hr"></div>
            <div class="tiny muted">√öltimos erros deste t√≥pico</div>
            <div id="nbErrList" style="margin-top:8px;"></div>
          </div><!-- /nbPanelError -->
${draft ? `
            <div class="note" style="margin-top:12px;">
              <b>Rascunho vindo de uma quest√£o</b><br>
              Disc.: ${escapeHtml(draft.disc||"")} ‚Ä¢ T√≥pico: ${escapeHtml(draft.topic||"")}<br>
              ${draft.qtext ? `<div class="tiny muted" style="margin-top:6px;">${escapeHtml(draft.qtext).slice(0,220)}${escapeHtml(draft.qtext).length>220?"‚Ä¶":""}</div>`:""}
              <div class="actions" style="margin-top:10px;">
                <button class="btn" id="nbApplyDraft">Aplicar ao campo 'Erros cometidos'</button>
                <button class="btn danger" id="nbDismissDraft">Descartar</button>
              </div>
            </div>
          ` : ``}
        </div>
      </div>
    `;

// Prefill quando vier de quest√£o errada (draft.mode="error" com draft.err)
try{
  if(nbMode==="error" && draft && draft.err && typeof draft.err==="object"){
    const p = document.getElementById("nbErrPrompt");
    const w = document.getElementById("nbErrWhy");
    const f = document.getElementById("nbErrFix");
    const t = document.getElementById("nbErrTags");
    const pr = document.getElementById("nbErrPriority");
    const nx = document.getElementById("nbErrNext");
    if(p && !p.value) p.value = String(draft.err.prompt||"");
    if(w && !w.value) w.value = String(draft.err.why||"");
    if(f && !f.value) f.value = String(draft.err.fix||"");
    if(t && !t.value) t.value = Array.isArray(draft.err.tags)? draft.err.tags.join(", ") : String(draft.err.tags||"");
    if(pr && draft.err.priority) pr.value = String(draft.err.priority);
    if(nx && (draft.err.nextDays!=null)) nx.value = String(draft.err.nextDays);
  }
}catch(e){}

    const nbDisc = document.getElementById("nbDisc");
    const nbTopic = document.getElementById("nbTopic");
    const nbModeSel = document.getElementById("nbMode");
    const panelNormal = document.getElementById("nbPanelNormal");
    const panelError = document.getElementById("nbPanelError");

    function applyMode(mode){
      const m = mode || "normal";
      if(panelNormal) panelNormal.style.display = (m==="normal") ? "block" : "none";
      if(panelError) panelError.style.display = (m==="error") ? "block" : "none";
      const extras = document.getElementById("nbErrorExtras");
      if(extras) extras.style.display = (m==="error") ? "block" : "none";
    }
    if(nbModeSel){
      nbModeSel.value = nbMode;
      applyMode(nbModeSel.value);
      nbModeSel.onchange = ()=>{
        sessionStorage.setItem("SAPE_NB_MODE", nbModeSel.value);
        applyMode(nbModeSel.value);
      };
    }else{
      applyMode(nbMode);
    }

    // render last errors list
    try{
      const errs = Array.isArray(entry.errors) ? entry.errors : [];
      const list = document.getElementById("nbErrList");
      if(list){
        const last = errs.slice(-12).reverse();
        list.innerHTML = last.length ? last.map(er=>`
          <div class="note" style="margin:6px 0;">
            <div style="display:flex;justify-content:space-between;gap:10px;">
              <b>${escapeHtml(er.type||"erro")}</b>
              <span class="tiny muted">${escapeHtml(fmtDate(er.createdAt||""))}</span>
            </div>
            <div class="tiny">${escapeHtml((er.prompt||er.fix||"").slice(0,180))}${(er.prompt||er.fix||"").length>180?"‚Ä¶":""}</div>
          </div>
        `).join("") : `<div class="tiny muted">Nenhum erro registrado ainda.</div>`;
      }
    }catch(e){}

    nbDisc.onchange = ()=>{ sessionStorage.removeItem(DRAFT_KEY); render(); };
    nbTopic.onchange = ()=>{ sessionStorage.removeItem(DRAFT_KEY); render(); };


    const btnErrSave = document.getElementById("nbErrSave");
    const btnErrClear = document.getElementById("nbErrClear");
    if(btnErrClear){
      btnErrClear.onclick = ()=>{
        const ids = ["nbErrPrompt","nbErrWhy","nbErrFix","nbErrTags"];
        ids.forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
      };
    }
    if(btnErrSave){
      btnErrSave.onclick = ()=>{
        const disc = nbDisc.value;
        const topic = nbTopic.value;
        if(!disc || !topic){ toast("Selecione disciplina e t√≥pico"); return; }

        const type = document.getElementById("nbErrType")?.value || "outro";
        const priority = document.getElementById("nbErrPriority")?.value || "media";
        const prompt = (document.getElementById("nbErrPrompt")?.value || "").trim();
        const why = (document.getElementById("nbErrWhy")?.value || "").trim();
        const fix = (document.getElementById("nbErrFix")?.value || "").trim();
        const tagsRaw = (document.getElementById("nbErrTags")?.value || "").trim();
        const tags = tagsRaw ? tagsRaw.split(",").map(x=>x.trim()).filter(Boolean) : [];
        const nextDays = Number(document.getElementById("nbErrNext")?.value || 3);

        if(!prompt && !fix){
          toast("Preencha pelo menos o resumo ou a revis√£o");
          return;
        }

        const nowIso = new Date().toISOString();
        const id = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ("e"+Date.now()+Math.random().toString(16).slice(2));
        const err = {
          id, type, priority, prompt, why, fix, tags,
          createdAt: nowIso,
          nextReviewAt: new Date(Date.now() + nextDays*24*60*60*1000).toISOString(),
          reviewed: false
        };

        const st0 = store.getState();
        const curEntry = getEntry(st0, examId, disc, topic);
        const curErrors = Array.isArray(curEntry.errors) ? curEntry.errors : [];
        const nextErrors = [...curErrors, err];

        const nextNotebook = notebookReducer(st0.notebook, { type: A.NB_SAVE, payload: { examId, disc, topic, data: { errors: nextErrors } } });
        let nextState = { ...st0, notebook: nextNotebook };

// Se o usu√°rio marcou como "Pegadinha", tamb√©m registra no banco de Pegadinhas (sem aba pr√≥pria)
if(type === "pegadinha"){
  try{
    const trapId = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ("t"+Date.now()+Math.random().toString(16).slice(2));
    const trap = {
      id: trapId,
      createdAt: nowIso,
      examId,
      disc,
      topic,
      bank: "AUTO",
      type: "Pegadinha (banca)",
      text: prompt || why || "",
      fix: fix || "",
      danger: 60,
      typical: tags.slice(0,8),
      trainPlan: []
    };
    const nextTraps = trapsReducer(st0.traps, { type: A.TRAP_ADD, payload: trap }, nextState);
    nextState = { ...nextState, traps: nextTraps };
  }catch(e){ console.warn("Falha ao registrar pegadinha automaticamente", e); }
}

        try{
          const userId = mlGetActiveUserId(nextState);
          if(userId){
            const ev = mlCreateEvent(userId, "notebook_error", { examId, disc, topic, mistakeType: type, priority, tags });
            nextState = mlAppendEvent(nextState, ev);
            nextState = mlMarkAnalyticsDirty(nextState, userId);
            const perf = mlCalculateUserPerformance(nextState, userId);
            nextState.mlPerformance = { ...(nextState.mlPerformance||{}), [userId]: perf };
          }
        }catch(e){ console.warn("ML notebook_error falhou", e); }

        store.dispatch({ type: A.STATE_IMPORT, payload: nextState });
      // invalida cache da Matriz para recalcular pesos com novos dados
      try{
        const ex = getActiveExam();
        if(typeof normalizeExamKey === "function") localStorage.removeItem(mlKey("ML_MATRIX_" + normalizeExamKey(ex)));
      }catch(e){}

        toast("Erro registrado ‚úì");
        try{ invalidateMatrixCacheForExam(getActiveExam()); }catch(e){}
        emitML("ML:PERF_LOGGED", { source:"notebook_error" });
        emitML("ML:REVIEWS_UPDATED", { source:"notebook_error" });
        render();
      };
    }

    document.getElementById("nbSave").onclick = ()=>{
      const disc = nbDisc.value;
      const topic = nbTopic.value;
      if(!disc || !topic){ toast("Selecione disciplina e t√≥pico"); return; }
      const data = {
        concept: document.getElementById("nbConcept").value,
        exceptions: document.getElementById("nbExceptions").value,
        how: document.getElementById("nbHow").value,
        legal: document.getElementById("nbLegal").value,
        juris: document.getElementById("nbJuris").value,
        mistakes: document.getElementById("nbMistakes").value,
        traps: document.getElementById("nbTraps").value,
        free: document.getElementById("nbFree").value,
      };
      store.dispatch({ type: A.NB_SAVE, payload: { examId, disc, topic, data }});
      toast("Salvo no Caderno");
      sessionStorage.removeItem(DRAFT_KEY);
      render();
    };

    document.getElementById("nbClear").onclick = ()=>{
      if(!confirm("Limpar os campos deste t√≥pico?")) return;
      document.getElementById("nbConcept").value = "";
      document.getElementById("nbExceptions").value = "";
      document.getElementById("nbHow").value = "";
      document.getElementById("nbLegal").value = "";
      document.getElementById("nbJuris").value = "";
      document.getElementById("nbMistakes").value = "";
      document.getElementById("nbTraps").value = "";
      document.getElementById("nbFree").value = "";
    };

    const btnApply = document.getElementById("nbApplyDraft");
    const btnDismiss = document.getElementById("nbDismissDraft");
    if(btnApply){
      btnApply.onclick = ()=>{
        const cur = document.getElementById("nbMistakes").value || "";
        const add = `\n‚Ä¢ Quest√£o: ${draft.qtext||"(sem enunciado)"}\n  - Minha resposta: ${draft.userAnswer||"-"} | Gabarito: ${draft.answerKey||"-"}\n  - Por que errei: `;
        document.getElementById("nbMistakes").value = (cur ? (cur+"\n") : "") + add;
        sessionStorage.removeItem(DRAFT_KEY);
        toast("Rascunho aplicado ‚Äî agora salve");
      };
    }
    if(btnDismiss){
      btnDismiss.onclick = ()=>{
        sessionStorage.removeItem(DRAFT_KEY);
        toast("Rascunho descartado");
        render();
      };
    }
  }

  render();
  return ()=>{};
}


function mountQuestions(){
  let lastCreated = { errorId:"", trapId:"" };

  function render(){
    const state = store.getState();
    const qs = Array.isArray(state.questions) ? state.questions : [];
    const answered = qs.filter(q=> q.isCorrect !== null).length;
    const correct = qs.filter(q=> q.isCorrect === true).length;
    const acc = answered ? Math.round((correct/answered)*100) : 0;

    function groupKey(disc, topic){ return (disc||"").trim()+"||"+(topic||"").trim(); }

    function renderStats(qs){
      const answered = qs.filter(q=> q.isCorrect !== null).length;
      const correct = qs.filter(q=> q.isCorrect === true).length;
      const acc = answered ? Math.round((correct/answered)*100) : 0;
      const wrong = qs.filter(q=> q.isCorrect === false).length;

      // by discipline
      const byDisc = new Map();
      const byTopic = new Map();
      for(const q of qs){
        const d = (q.disc||"(sem disciplina)").trim() || "(sem disciplina)";
        const t = (q.topic||"(sem assunto)").trim() || "(sem assunto)";
        if(!byDisc.has(d)) byDisc.set(d, { total:0, ans:0, right:0, wrong:0 });
        if(!byTopic.has(groupKey(d,t))) byTopic.set(groupKey(d,t), { disc:d, topic:t, total:0, ans:0, right:0, wrong:0 });
        const dd = byDisc.get(d);
        const tt = byTopic.get(groupKey(d,t));
        dd.total++; tt.total++;
        if(q.isCorrect !== null){
          dd.ans++; tt.ans++;
          if(q.isCorrect){ dd.right++; tt.right++; } else { dd.wrong++; tt.wrong++; }
        }
      }

      const discRows = Array.from(byDisc.entries()).map(([k,v])=>{
        const a = v.ans ? Math.round((v.right/v.ans)*100) : 0;
        return { disc:k, ...v, acc:a };
      }).sort((a,b)=> (b.wrong - a.wrong) || (b.total - a.total)).slice(0,6);

      const topicRows = Array.from(byTopic.values()).map(v=>{
        const a = v.ans ? Math.round((v.right/v.ans)*100) : 0;
        return { ...v, acc:a };
      }).sort((a,b)=> (b.wrong - a.wrong) || (b.total - a.total)).slice(0,8);

      return `
        <div class="statgrid">
          <div class="statcard" style="background:var(--blue);">
            <div class="h">Acur√°cia geral</div>
            <div class="v">${acc}%</div>
            <div class="bar" style="margin-top:10px;"><div style="width:${acc}%;"></div></div>
            <div class="tiny muted" style="margin-top:8px;">Respondidas: ${answered} ‚Ä¢ Acertos: ${correct} ‚Ä¢ Erros: ${wrong}</div>
          </div>
          <div class="statcard" style="background:var(--lav);">
            <div class="h">Top disciplinas com mais erros</div>
            ${discRows.length ? discRows.map(r=>`
              <div style="margin-top:10px;">
                <div class="tiny muted"><b>${escapeHtml(r.disc)}</b> ‚Äî erros: ${r.wrong} ‚Ä¢ acur√°cia: ${r.acc}%</div>
                <div class="bar"><div style="width:${r.acc}%;"></div></div>
              </div>
            `).join("") : `<div class="note" style="margin-top:10px;">Registre quest√µes para ver estat√≠sticas.</div>`}
          </div>
        </div>

        <div class="hr"></div>

        <details open class="compact">
          <summary><span>Top assuntos com mais erros</span><span class="chev">‚åÑ</span></summary>
          <div style="margin-top:10px;">
            ${topicRows.length ? `
              <table>
                <thead><tr><th>Disc / Assunto</th><th>Erros</th><th>Acur√°cia</th></tr></thead>
                <tbody>
                  ${topicRows.map(r=>`
                    <tr>
                      <td><b>${escapeHtml(r.disc)}</b><div class="tiny muted">${escapeHtml(r.topic)}</div></td>
                      <td><span class="badge overdue">${r.wrong}</span><div class="tiny muted">total: ${r.total}</div></td>
                      <td><span class="badge">${r.acc}%</span></td>
                    </tr>
                  `).join("")}
                </tbody>
              </table>
            ` : `<div class="note">Ainda sem dados suficientes.</div>`}
          </div>
        </details>
      `;
    }


    app.innerHTML = `
      <div class="grid">
        <div class="card">
          <div class="section-title">
            <h2>Quest√µes por mat√©ria</h2>
            <span class="pill">Acur√°cia: <b>${acc}%</b> ‚Ä¢ Respondidas: <b>${answered}</b></span>
          </div>

          <div class="note">
            Registre uma quest√£o e marque se acertou/errou. Se <b>errar</b>, voc√™ pode gerar automaticamente um item no <b>Caderno de Erros</b>.
            Se houver ‚Äúpegadinha‚Äù, pode salvar tamb√©m no m√≥dulo <b>Pegadinhas</b>.
          </div>

          <div class="hr"></div>

          <details open class="compact">
            <summary><span>Novo registro</span><span class="chev">‚åÑ</span></summary>
            <div style="margin-top:10px;">
              <div class="row">
                <div><label>Disciplina</label><input id="qDisc" placeholder="Ex.: Constitucional" /></div>
                <div><label>Assunto</label><input id="qTopic" placeholder="Ex.: Direitos fundamentais" /></div>
              </div>

              <div class="row">
                <div><label>Banca</label><input id="qBank" placeholder="Ex.: FCC" /></div>
                <div><label>Fonte (opcional)</label><input id="qSource" placeholder="PDF / Curso / Site / Prova X" /></div>
              </div>

              <div class="row">
                <div>
                  <label>Dificuldade</label>
                  <select id="qDiff">
                    <option value="">(n√£o informar)</option>
                    <option>F√°cil</option><option>M√©dia</option><option>Dif√≠cil</option>
                  </select>
                </div>
                <div><label>Tempo (min, opcional)</label><input id="qTime" type="number" min="0" step="1" placeholder="Ex.: 3" /></div>
              </div>
<div class="row">
  <div>
    <label>Emo√ß√£o (opcional)</label>
    <select id="qEmotion">
      <option value="">(n√£o informar)</option>
      <option>Calma</option>
      <option>Ansiosa</option>
      <option>Cansada</option>
      <option>Com pressa</option>
      <option>Confiante</option>
      <option>Distra√≠da</option>
    </select>
  </div>
  <div>
    <label>Foco (1‚Äì5) ‚Ä¢ Cansa√ßo (1‚Äì5)</label>
    <div class="row" style="grid-template-columns:1fr 1fr;gap:8px;">
      <select id="qFocus">
        <option value="">Foco‚Ä¶</option>
        <option value="1">1 (muito baixo)</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5 (muito alto)</option>
      </select>
      <select id="qFatigue">
        <option value="">Cansa√ßo‚Ä¶</option>
        <option value="1">1 (zero)</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5 (muito alto)</option>
      </select>
    </div>
  </div>
</div>

<div class="row">
  <div>
    <label>Modo Bloco (opcional)</label>
    <select id="qBlockMode">
      <option value="">(avulso)</option>
      <option value="BLOCO_10">Bloco de 10</option>
      <option value="BLOCO_15">Bloco de 15</option>
      <option value="BLOCO_20">Bloco de 20</option>
    </select>
  </div>
  <div><label>√çndice no bloco (opcional)</label><input id="qBlockIndex" type="number" min="1" step="1" placeholder="Ex.: 7" /></div>
</div>

              <label>Enunciado / trecho (cole aqui)</label>
              <textarea id="qText" placeholder="Cole o enunciado ou o ponto chave da quest√£o..."></textarea>

              <div class="row">
                <div><label>Gabarito (opcional)</label><input id="qKey" placeholder="Ex.: C" /></div>
                <div><label>Sua resposta (opcional)</label><input id="qAns" placeholder="Ex.: D" /></div>
              </div>

              <div class="row">
                <div>
                  <label>Resultado (r√°pido)</label>
                  <div class="seg">
                    <button class="btn" type="button" id="qBtnRight">Acertei ‚úì</button>
                    <button class="btn" type="button" id="qBtnWrong">Errei ‚úó</button>
                    <button class="btn" type="button" id="qBtnClearRes">Limpar</button>
                  </div>
                  <div style="margin-top:8px;">
                    <select id="qRes">
                      <option value="">(n√£o marcar)</option>
                      <option value="true">Acertei</option>
                      <option value="false">Errei</option>
                    </select>
                  </div>
                </div>
                <div>
                  <label>Tags (r√°pido)</label>
                  <input id="qTags" placeholder="Ex.: pegadinha, exce√ß√£o, compet√™ncia" />
                  <div class="chips" style="margin-top:8px;">
                    <button class="chip" type="button" data-tag="pegadinha">pegadinha</button>
                    <button class="chip" type="button" data-tag="exce√ß√£o">exce√ß√£o</button>
                    <button class="chip" type="button" data-tag="compet√™ncia">compet√™ncia</button>
                    <button class="chip" type="button" data-tag="prazo">prazo</button>
                    <button class="chip" type="button" data-tag="recurso">recurso</button>
                    <button class="chip" type="button" data-tag="conceito">conceito</button>
                  </div>
                </div>
              </div>

              <label>Notas (opcional)</label>
              <textarea id="qNotes" placeholder="Por que errou? qual regra? qual macete?"></textarea>

              <div class="row">
                <div>
                  <label><input id="mkError" type="checkbox" checked /> Se errei, criar no Caderno de Erros</label>
                  <div class="tiny muted">Agenda inicial: Amanh√£ (voc√™ ajusta depois).</div>
                </div>
                <div>
                  <label><input id="mkTrap" type="checkbox" /> Se houver pegadinha, salvar em Pegadinhas</label>
                  <div class="tiny muted">Usa o texto + notas como corre√ß√£o.</div>
                </div>
              </div>

              <div class="btnbar">
                <button class="btn primary" id="qSave">Salvar registro</button>
                <button class="btn" id="qClear">Limpar</button>
              </div>

              ${lastCreated.errorId || lastCreated.trapId ? `
                <div class="hr"></div>
                <div class="note">
                  Criado agora:
                  ${lastCreated.errorId ? `<span class="badge">Erro ‚úì</span>` : ``}
                  ${lastCreated.trapId ? `<span class="badge">Pegadinha ‚úì</span>` : ``}
                </div>
              ` : ``}
            </div>
          </details>

        </div>

        <div class="card">
          <div class="section-title">
            <h2>Estat√≠sticas</h2>
            <span class="pill">Total: <b>${qs.length}</b></span>
          </div>

          ${renderStats(qs)}

          <div class="hr"></div>

          <div class="section-title">
            <h2>Hist√≥rico</h2>
            <span class="pill">Total: <b>${qs.length}</b></span>
          </div>

          <details open class="compact">
            <summary><span>Lista + filtros</span><span class="chev">‚åÑ</span></summary>
            <div style="margin-top:10px;">
              <div class="row">
                <div><label>Filtro disciplina</label><input id="qFilterDisc" placeholder="(vazio = tudo)" /></div>
                <div><label>Filtro banca</label><input id="qFilterBank" placeholder="(vazio = tudo)" /></div>
              </div>
              <div class="row">
                <div><label>Mostrar</label>
                  <select id="qFilterRes">
                    <option value="">Tudo</option>
                    <option value="true">S√≥ acertos</option>
                    <option value="false">S√≥ erros</option>
                    <option value="null">Sem marcar</option>
                  </select>
                </div>
                <div><label>Ordenar</label>
                  <select id="qSort">
                    <option value="new">Mais recentes</option>
                    <option value="old">Mais antigas</option>
                  </select>
                </div>
              </div>

              <div id="qTable" class="compact"></div>
            </div>
          </details>

        </div>
      </div>
    `;

    // bind
    const qTable = document.getElementById("qTable");
    const fDisc = document.getElementById("qFilterDisc");
    const fBank = document.getElementById("qFilterBank");
    const fRes  = document.getElementById("qFilterRes");
    const fSort = document.getElementById("qSort");

    function renderTable(){
      const s = store.getState();
      let rows = (s.questions || []).slice();
      const fd = safeString(fDisc.value).trim().toLowerCase();
      const fb = safeString(fBank.value).trim().toLowerCase();
      const fr = fRes.value;

      rows = rows.filter(q=>{
        const okD = !fd || (q.disc||"").toLowerCase().includes(fd);
        const okB = !fb || (q.bank||"").toLowerCase().includes(fb);
        let okR = true;
        if(fr === "true") okR = q.isCorrect === true;
        else if(fr === "false") okR = q.isCorrect === false;
        else if(fr === "null") okR = q.isCorrect === null;
        return okD && okB && okR;
      });

      rows.sort((a,b)=>{
        const da = new Date(a.createdAt).getTime();
        const db = new Date(b.createdAt).getTime();
        return (fSort.value === "old") ? (da - db) : (db - da);
      });

      if(rows.length === 0){
        qTable.innerHTML = `<div class="note">Nenhum registro ainda.</div>`;
        return;
      }

      qTable.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Disc / Assunto</th>
              <th>Resultado</th>
              <th>Data</th>
              <th>A√ß√µes</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(q=>{
              const badge = (q.isCorrect === true) ? `<span class="badge" style="background: var(--green);">acerto</span>`
                          : (q.isCorrect === false) ? `<span class="badge overdue">erro</span>`
                          : `<span class="badge">‚Äî</span>`;
              const links = [
                q.createdErrorId ? `<span class="badge">erro‚úì</span>` : ``,
                q.createdTrapId ? `<span class="badge">trap‚úì</span>` : ``,
              ].join(" ");
              return `
                <tr>
                  <td>
                    <div><b>${escapeHtml(q.disc || "(sem disciplina)")}</b></div>
                    <div class="tiny muted">${escapeHtml(q.topic || "(sem assunto)")}</div>
                    <div class="tiny muted">banca: ${escapeHtml(q.bank || "-")} ${q.source ? "‚Ä¢ fonte: "+escapeHtml(q.source) : ""}</div>
                    ${q.tags && q.tags.length ? `<div class="tiny muted">tags: ${q.tags.map(t=>escapeHtml(t)).join(", ")}</div>` : ``}
                    ${links ? `<div class="tiny muted" style="margin-top:4px;">${links}</div>` : ``}
                  </td>
                  <td>
                    ${badge}
                    <div class="tiny muted" style="margin-top:6px;">${q.userAnswer ? "resp: "+escapeHtml(q.userAnswer) : ""} ${q.answerKey ? "‚Ä¢ gab: "+escapeHtml(q.answerKey) : ""}</div>
                  </td>
                  <td>
                    <div>${fmtDate(q.createdAt)}</div>
                    <div class="tiny muted">${q.timeMin != null ? q.timeMin+" min" : ""} ${q.difficulty ? "‚Ä¢ "+escapeHtml(q.difficulty) : ""}</div>
                  </td>
                  <td>
                    <div class="actions">
                      <button class="btn" data-act="open" data-id="${q.id}">Ver</button>
                                            <button class="btn" data-act="note" data-id="${q.id}">üìì</button>
<button class="btn danger" data-act="del" data-id="${q.id}">Excluir</button>
                    </div>
                  </td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;

      qTable.querySelectorAll("button[data-act]").forEach(b=>{
        b.onclick = ()=>{
          const act = b.getAttribute("data-act");
          const id  = b.getAttribute("data-id");
          const item = (store.getState().questions || []).find(x=>x.id===id);
          if(!item) return;
          if(act==="del"){
            if(confirm("Excluir este registro de quest√£o?")){
              store.dispatch({ type: A.Q_DELETE, id });
              toast("Exclu√≠do");
            }
            return;
          }
          if(act==="note"){
            try{
              sessionStorage.setItem("SAPE_NB_DRAFT", JSON.stringify({
                disc: item.disc || "",
                topic: item.topic || "",
                qtext: item.qtext || "",
                userAnswer: item.userAnswer || "",
                answerKey: item.answerKey || ""
              }));
            }catch{}
            // abre o caderno j√° no t√≥pico
            document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
            const tbtn = Array.from(document.querySelectorAll(".tab")).find(x=>x.dataset && x.dataset.tab==="notebook");
            if(tbtn){ tbtn.classList.add("active"); }
            go("notebook");
            return;
          }
          if(act==="open"){
            // Preenche o form (modo edi√ß√£o leve: voc√™ pode salvar como novo registro)
            document.getElementById("qDisc").value = item.disc || "";
            document.getElementById("qTopic").value = item.topic || "";
            document.getElementById("qBank").value = item.bank || "";
            document.getElementById("qSource").value = item.source || "";
            document.getElementById("qDiff").value = item.difficulty || "";
            document.getElementById("qTime").value = (item.timeMin != null) ? item.timeMin : "";
            document.getElementById("qText").value = item.qtext || "";
            document.getElementById("qKey").value = item.answerKey || "";
            document.getElementById("qAns").value = item.userAnswer || "";
            document.getElementById("qRes").value = (item.isCorrect === true) ? "true" : (item.isCorrect === false) ? "false" : "";
            document.getElementById("qTags").value = (item.tags||[]).join(", ");
            document.getElementById("qNotes").value = item.notes || "";
            toast("Carregado no formul√°rio");
          }
        };
      });
    }

    if(fDisc) fDisc.oninput = renderTable;
    if(fBank) fBank.oninput = renderTable;
    if(fRes)  fRes.onchange = renderTable;
    if(fSort) fSort.onchange = renderTable;

    renderTable();

    // Quick result buttons
    const qResSel = document.getElementById("qRes");
    const btnR = document.getElementById("qBtnRight");
    const btnW = document.getElementById("qBtnWrong");
    const btnC = document.getElementById("qBtnClearRes");
    if(btnR) btnR.onclick = ()=>{ qResSel.value = "true"; toast("Marcado: acerto"); };
    if(btnW) btnW.onclick = ()=>{ qResSel.value = "false"; toast("Marcado: erro"); };
    if(btnC) btnC.onclick = ()=>{ qResSel.value = ""; toast("Resultado limpo"); };

    // Tag chips
    const tagInput = document.getElementById("qTags");
    document.querySelectorAll("button.chip[data-tag]").forEach(ch=>{
      ch.onclick = ()=>{
        const t = ch.getAttribute("data-tag");
        const cur = (tagInput.value||"").split(",").map(x=>x.trim()).filter(Boolean);
        if(!cur.includes(t)) cur.push(t);
        tagInput.value = cur.join(", ");
      };
    });

    document.getElementById("qClear").onclick = ()=>{
      ["qDisc","qTopic","qBank","qSource","qText","qKey","qAns","qTags","qNotes","qTime","qEmotion","qFocus","qFatigue","qBlockMode","qBlockIndex"].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
      document.getElementById("qDiff").value = "";
      document.getElementById("qRes").value = "";
      document.getElementById("mkError").checked = true;
      document.getElementById("mkTrap").checked = false;
      lastCreated = { errorId:"", trapId:"" };
      toast("Limpo");
    };

    document.getElementById("qSave").onclick = ()=>{
      const now = new Date();
      const disc = safeString(document.getElementById("qDisc").value).trim();
      const topic = safeString(document.getElementById("qTopic").value).trim();
      const bank = safeString(document.getElementById("qBank").value).trim();
      const source = safeString(document.getElementById("qSource").value).trim();
      const difficulty = safeString(document.getElementById("qDiff").value).trim();
      const timeMinRaw = safeString(document.getElementById("qTime").value).trim();
      const qtext = safeString(document.getElementById("qText").value).trim();
      const answerKey = safeString(document.getElementById("qKey").value).trim();
      const userAnswer = safeString(document.getElementById("qAns").value).trim();
      const res = safeString(document.getElementById("qRes").value);
      const tags = safeString(document.getElementById("qTags").value).split(",").map(x=>x.trim()).filter(Boolean).slice(0,10);
      const notes = safeString(document.getElementById("qNotes").value).trim();
const emotion = safeString(document.getElementById("qEmotion").value).trim();
const focusRaw = safeString(document.getElementById("qFocus").value).trim();
const fatigueRaw = safeString(document.getElementById("qFatigue").value).trim();
const blockMode = safeString(document.getElementById("qBlockMode").value).trim();
const blockIndexRaw = safeString(document.getElementById("qBlockIndex").value).trim();

const focus = focusRaw ? Math.max(1, Math.min(5, Number(focusRaw))) : null;
const fatigue = fatigueRaw ? Math.max(1, Math.min(5, Number(fatigueRaw))) : null;
const qIndexInBlock = blockIndexRaw ? Math.max(1, Number(blockIndexRaw)) : null;

// Heur√≠stica simples de tipo de erro (para o m√≥dulo cognitivo)
const tagsLower = tags.map(t=>t.toLowerCase());
const mistakeType = tagsLower.includes("prazo") ? "prazo" :
                    (tagsLower.includes("exce√ß√£o") || tagsLower.includes("excecao")) ? "excecao" :
                    tagsLower.includes("conceito") ? "conceito" :
                    tagsLower.includes("compet√™ncia") || tagsLower.includes("competencia") ? "conceito" :
                    "";

      const isCorrect = (res === "true") ? true : (res === "false") ? false : null;
      const timeMin = timeMinRaw ? Math.max(0, Number(timeMinRaw)) : null;

      if(!disc && !topic && !qtext){
        toast("Preencha ao menos Disciplina/Assunto ou cole o texto.");
        return;
      }

      let createdErrorId = "";
      let createdTrapId = "";

      const shouldMakeError = document.getElementById("mkError").checked;
      const shouldMakeTrap = document.getElementById("mkTrap").checked;

      // Create Error if wrong + checked
      if(isCorrect === false && shouldMakeError){
        const errId = uid();
        const cause = notes || "Errei a quest√£o (registrado via m√≥dulo Quest√µes).";
        const nextReviewAt = addDays(startOfDay(now), 1).toISOString(); // Amanh√£
        store.dispatch({ type: A.ERROR_ADD, payload: {
          id: errId, createdAt: now.toISOString(),
          disc, topic, bank,
          cause,
          notes: qtext ? ("Quest√£o/trecho:\n" + qtext + (answerKey||userAnswer ? `\n\nGab: ${answerKey || "-"} | Resp: ${userAnswer || "-"}` : "")) : "",
          mistakeType:"", nextReviewAt, reviewHistory:[]
        }});
        createdErrorId = errId;
      }

      // Create Trap if checked
      if(shouldMakeTrap){
        const payload = {
          disc, topic, bank: bank || "AUTO",
          type: "Amb√≠gua/dupla interpreta√ß√£o",
          text: qtext || (disc + " ‚Äî " + topic),
          fix: notes || ""
        };
        const trap = analyzeTrapPayload(payload);
        store.dispatch({ type: A.TRAP_ADD, payload: trap });
        createdTrapId = trap.id;
      }

      const qId = uid();
      store.dispatch({ type: A.Q_ADD, payload: {
        id: qId, createdAt: now.toISOString(),
        disc, topic, bank, source,
        qtext, answerKey, userAnswer, isCorrect,
        difficulty, timeMin, notes, tags,
        createdErrorId, createdTrapId,
        emotion, focus, fatigue, blockMode, qIndexInBlock, mistakeType
      }});

// ===== MattarLeister: log evento para Performance Cognitiva/IPA
try{
  const st0 = store.getState();
  const userId = mlGetActiveUserId(st0);
  if(userId){
    const timeSec = (timeMin != null && Number.isFinite(timeMin)) ? Math.round(timeMin*60) : null;
    // S√≥ registra se houver ao menos um dado relevante (resultado ou tempo)
    if(isCorrect !== null || timeSec != null || focus != null || fatigue != null || emotion){
      const ev = mlCreateEvent({
        userId,
        type: "question_done",
        payload: {
          examId: getActiveExam(),
          disc, topic,
          correct: isCorrect === true,
          hasResult: isCorrect !== null,
          timeSec: timeSec,
          emotion: emotion || "",
          focus: focus,
          fatigue: fatigue,
          mistakeType: mistakeType,
          blockMode: blockMode || "",
          qIndexInBlock: qIndexInBlock
        }
      });

      // aplica no state via import (mant√©m a store simples)
      let nextState = mlAppendEvent(st0, ev);
      nextState = mlMarkAnalyticsDirty(nextState, userId);

      // atualiza performance agregada
      const perf = mlCalculateUserPerformance(nextState, userId);
      nextState.mlPerformance = { ...(nextState.mlPerformance||{}), [userId]: perf };

      store.dispatch({ type: A.STATE_IMPORT, payload: nextState });
      // invalida cache da Matriz para recalcular pesos com novos dados
      try{
        const ex = getActiveExam();
        if(typeof normalizeExamKey === "function") localStorage.removeItem(mlKey("ML_MATRIX_" + normalizeExamKey(ex)));
      }catch(e){}
    }
  }
}catch(e){ dwarn("ML event append falhou", e); }


      lastCreated = { errorId: createdErrorId, trapId: createdTrapId };
      toast("Registro salvo ‚úì");
      render(); // re-render to update stats & show created badges
    };
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="questions") render(); });
  return ()=> unsub();
}

function mountProfile(){
  function render(){
    const p = loadProfile();
    const current = getActiveExam();
    const exams = Object.keys(EXAMS).map(id=>{
      const name = EXAMS[id]?.name || id;
      return `<option value="${escapeHtml(id)}" ${((p&&p.mainExamId)||current)===id?'selected':''}>${escapeHtml(name)}</option>`;
    }).join("");

    app.innerHTML = `
      <div class="card">
        <div class="section-title">
          <h2>Perfil</h2>
          <span class="pill">Configura√ß√£o deste computador</span>
        </div>

        <div class="note">Defina seu concurso principal. Isso ajusta o foco do Radar, Plano 7 dias e Modelo C.</div>

        <div class="hr"></div>

        <div class="row">
          <div>
            <label>Seu nome (opcional)</label>
            <input id="pName" placeholder="Ex.: Carolina" value="${escapeHtml(p?.name||"")}">
          </div>
          <div>
            <label>Concurso principal</label>
            <select id="pExam">${exams}</select>
          </div>
        </div>

        
        <div class="hr"></div>

        <div class="section-title" style="margin-top:6px;">
          <h3>Bloco 0 ‚Äî Revis√µes Autom√°ticas</h3>
          <span class="pill">Din√¢mico</span>
        </div>
        <div class="note">O Bloco 0 se ajusta automaticamente pelo seu tempo do dia e pela reta final do edital (Auto‚ÄëIntensivo &lt; 30 dias).</div>

        <div class="row">
          <div>
            <label>Horas de estudo por dia</label>
            <input id="pHours" type="number" step="0.5" min="0.5" max="16" value="${escapeHtml(String(p?.studyHoursPerDay ?? 6))}">
          </div>
          <div>
            <label>Carga de revis√£o (manual)</label>
            <select id="pReviewLoad">
              <option value="leve" ${p?.reviewLoadManual==="leve"?"selected":""}>Leve (15%)</option>
              <option value="padrao" ${(!p?.reviewLoadManual || p?.reviewLoadManual==="padrao")?"selected":""}>Padr√£o (20%)</option>
              <option value="intensivo" ${p?.reviewLoadManual==="intensivo"?"selected":""}>Intensivo (25%)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Data de in√≠cio (seu s√°bado de come√ßo) <span class="pill">obrigat√≥rio</span></label>
            <input id="pStartDate" type="date" value="${escapeHtml((p?.startDateISO||"").slice(0,10))}">
          </div>
          <div>
            <label>Data do edital (opcional)</label>
            <input id="pExamDate" type="date" value="${escapeHtml((p?.examDateISO||"").slice(0,10))}">
          </div>
          <div style="display:flex; align-items:end; gap:10px;">
            <label style="display:flex; align-items:center; gap:10px; user-select:none;">
              <input id="pAutoIntensive" type="checkbox" ${p?.autoIntensiveEnabled===false?"":"checked"}>
              Auto‚ÄëIntensivo quando faltar ‚â§ 30 dias
            </label>
          </div>
        </div>

        <div class="btnbar" style="margin-top:10px;">
          <button class="btn primary" id="pSave">Salvar</button>
          <button class="btn" id="pGoDash">Ir para Dashboard</button>
          <button class="btn danger" id="pClear">Apagar Perfil</button>
        </div>

        <div class="hr"></div>
        <div class="note">
          Dica: o progresso (quest√µes/erros/pegadinhas) fica salvo no seu navegador. Use a aba Backup para exportar/importar.
        </div>
      </div>
    `;

    
// Concurso principal: aplicar imediatamente (sem precisar clicar em "Salvar")
try{
  const sel = document.getElementById("pExam");
  if(sel){
    sel.onchange = ()=>{
      const id = sel.value;
      if(!id) return;
      // salva mantendo os outros campos atuais do formul√°rio
      const next = {
        name: document.getElementById("pName")?.value || (p?.name||""),
        mainExamId: id,
        studyHoursPerDay: Number(document.getElementById("pHours")?.value || (p?.studyHoursPerDay||6)),
        reviewLoadManual: document.getElementById("pReviewLoad")?.value || (p?.reviewLoadManual||"padrao"),
        startDateISO: (document.getElementById("pStartDate")?.value || (p?.startDateISO||"")).trim(),
        examDateISO: (document.getElementById("pExamDate")?.value || (p?.examDateISO||"")).trim(),
        autoIntensiveEnabled: !!document.getElementById("pAutoIntensive")?.checked,
        createdAt: p?.createdAt
      };
      saveProfile(next);
      setActiveExamAndSyncProfile(id);
      try{ invalidateMatrixCacheForExam(id); }catch(e){}
      emitML("ML:EXAM_CHANGED", { examId:id, source:"profile_select" });
      toast("Concurso ajustado ‚úì");
    };
  }
}catch(e){}
document.getElementById("pSave").onclick = ()=>{
      const name = document.getElementById("pName").value;
      const mainExamId = document.getElementById("pExam").value;
      const studyHoursPerDay = Number(document.getElementById("pHours")?.value || 6);
      const reviewLoadManual = document.getElementById("pReviewLoad")?.value || "padrao";
      const startDateISO = (document.getElementById("pStartDate")?.value || "").trim();
      const examDateISO = (document.getElementById("pExamDate")?.value || "").trim();
      const autoIntensiveEnabled = !!document.getElementById("pAutoIntensive")?.checked;
      if(!mainExamId){ toast("Escolha o concurso/cargo."); return; }
      if(!startDateISO){ toast("Escolha a data de in√≠cio (seu s√°bado de come√ßo)."); return; }
      const saved = saveProfile({ name, mainExamId, studyHoursPerDay, reviewLoadManual, startDateISO, autoIntensiveEnabled, examDateISO, createdAt: p?.createdAt });
      setActiveExam(mainExamId);
      toast("Perfil salvo ‚úì");

      // aplica configura√ß√µes do concurso: gera/atualiza matriz e reseta disciplinas do dia (para evitar lixo de outro cargo)
      try{
        if(typeof ensureMatrix === "function") ensureMatrix(loadProfile());
      }catch(e){}
      try{ saveTodayDisciplines([]); }catch(e){}
      go("dashboard");
    };
    document.getElementById("pGoDash").onclick = ()=> go("dashboard");
    document.getElementById("pClear").onclick = ()=>{
      if(confirm("Apagar o perfil deste computador? (n√£o apaga seu progresso)")){
        clearProfile();
        toast("Perfil apagado.");
        render();
      }
    };
  }
  render();
  return ()=>{};
}

function mountSettings(){
  function render(){
    const state = store.getState();
    const profile = loadProfile();
    const payload = { profile: profile, state: state, exportedAt: new Date().toISOString(), appVersion: STATE_VERSION, userId: (profile && (profile.userId||profile.uid)) ? (profile.userId||profile.uid) : (localStorage.getItem("ML_USER_ID")||"") };
    const json = JSON.stringify(payload, null, 2);

    
    const metaRaw = localStorage.getItem(STORAGE_META_KEY);
    let meta = null;
    try{ meta = metaRaw ? JSON.parse(metaRaw) : null; }catch{ meta = null; }
    const savedAt = meta && meta.savedAt ? new Date(meta.savedAt) : null;
    const restoredAt = meta && meta.restoredAt ? new Date(meta.restoredAt) : null;

// Multiusu√°rio (toggle) - v3.0.5
try{
  const tgl = document.getElementById("multiUserToggle");
  if(tgl){
    tgl.checked = isMultiUser();
    tgl.onchange = ()=>{
      try{
        localStorage.setItem(ML_MULTIUSER_FLAG, tgl.checked ? "1" : "0");
        if(tgl.checked){
          migrateToMultiUser();
          toast("Multiusu√°rio ativado ‚úì");
        }else{
          toast("Multiusu√°rio desativado ‚úì (legado mantido)");
        }
        // Re-render para refletir leitura das chaves com/sem prefixo
        try{ render(); }catch(e){}
        try{ renderBlocoZero(); }catch(e){}
      }catch(e){}
    };
  }
}catch(e){}
app.innerHTML = `
      <div class="card">
        <div class="section-title">
          <h2>Backup / Importa√ß√£o</h2>
          <span class="pill">Chave: <b>${STORAGE_KEY}</b></span>
        </div>

        <div class="note">Fa√ßa backup em JSON e restaure quando quiser.</div>

        <div class="hr"></div>

        <div class="btnbar">
          <button class="btn primary" id="export">Exportar JSON</button>
          <button class="btn" id="copy">Copiar JSON</button>
          <button class="btn" id="profileBtn">Perfil</button>
          <button class="btn danger" id="reset">Resetar (apagar tudo)</button>
        </div>

        <div class="hr"></div>

        <label>Importar JSON</label>
        <div class="row" style="gap:10px;align-items:flex-end;margin:6px 0 10px 0;">
          <div style="flex:1;">
            <div class="tiny muted" style="margin-bottom:4px;">Modo de importa√ß√£o</div>
            <select id="importMode">
              <option value="all">Tudo (perfil + dados)</option>
              <option value="profile">Somente Perfil</option>
              <option value="data">Somente Dados (mant√©m perfil atual)</option>
            </select>
          </div>
        </div>
        <textarea id="importBox" placeholder="Cole aqui o JSON exportado..."></textarea>
        <div class="btnbar"><button class="btn primary" id="import">Importar</button></div>

        
<div class="hr"></div>

<div class="section-title">
  <h2>Snapshots (v3.0)</h2>
  <div class="tiny muted">Salvos automaticamente antes de Importar/Resetar. Mant√©m at√© 8 vers√µes.</div>
</div>

<div id="snapList" class="card" style="box-shadow:none;border:1px solid var(--border);"></div>

        <label>Estado atual (somente leitura)</label>
        <textarea readonly>${escapeHtml(json)}</textarea>
      </div>
    `;

    document.getElementById("export").onclick = ()=>{
      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const ex = getActiveExam();
      a.download = `SAPE_backup_${STATE_VERSION}_${ex}_${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      toast("Backup exportado");
    };

    document.getElementById("copy").onclick = async ()=>{
      try{ await navigator.clipboard.writeText(json); toast("JSON copiado"); }
      catch{ toast("N√£o deu para copiar (permiss√£o do navegador)."); }
    };

    document.getElementById("import").onclick = ()=>{
      const txt = document.getElementById("importBox").value;
      try{
        // snapshot do estado atual antes de sobrescrever
        try{
          const profileNow = loadProfile();
          pushSnapshot("pre_import", { profile: profileNow, state: store.getState(), exportedAt: new Date().toISOString(), appVersion: STATE_VERSION });
        }catch(e){}
        const parsed = JSON.parse(txt);

        const mode = (document.getElementById("importMode")?.value || "all");

        // compat: aceita tanto {profile, state, ...} quanto state puro
        const wrapped = (parsed && typeof parsed === "object" && (parsed.state || parsed.profile));
        const incomingProfile = wrapped ? (parsed.profile || null) : null;
        const incomingState   = wrapped ? (parsed.state || null) : parsed;

        if(mode==="profile"){
          if(incomingProfile){
            saveProfile(incomingProfile);
            if(incomingProfile.mainExamId) setActiveExam(incomingProfile.mainExamId);
            toast("Perfil importado ‚úì");
          }else{
            toast("Este JSON n√£o cont√©m Perfil.");
          }
          document.getElementById("importBox").value = "";
          return;
        }

        if(mode==="data"){
          if(incomingState){
            store.dispatch({ type: A.STATE_IMPORT, payload: incomingState });
            toast("Dados importados ‚úì");
            try{ invalidateMatrixCacheForExam(getActiveExam()); }catch(e){}
            emitML("ML:STATE_IMPORTED", { mode:"data" });
            emitML("ML:REVIEWS_UPDATED", { source:"import_data" });
          }else{
            toast("Este JSON n√£o cont√©m Dados.");
          }
          document.getElementById("importBox").value = "";
          return;
        }

        // mode=all (default)
        if(wrapped){
          if(incomingProfile) saveProfile(incomingProfile);
          if(incomingState) store.dispatch({ type: A.STATE_IMPORT, payload: incomingState });
          if(incomingProfile && incomingProfile.mainExamId) setActiveExam(incomingProfile.mainExamId);
        }else{
          store.dispatch({ type: A.STATE_IMPORT, payload: incomingState });
        }
toast("Importado ‚úì");
        try{ localStorage.setItem(STORAGE_META_KEY, JSON.stringify({ restoredAt: Date.now(), reason: "manual_import", version: STATE_VERSION })); }catch(e){}
        try{ invalidateMatrixCacheForExam(getActiveExam()); }catch(e){}
        emitML("ML:STATE_IMPORTED", { });
        emitML("ML:REVIEWS_UPDATED", { source:"import" });
        document.getElementById("importBox").value = "";
      }catch{ toast("JSON inv√°lido."); }
    };

    document.getElementById("profileBtn").onclick = ()=> go("profile");

    document.getElementById("reset").onclick = ()=>{
      if(confirm("Tem certeza? Isso apaga todo o progresso desta vers√£o V7.")){
        try{ const profileNow = loadProfile(); pushSnapshot("pre_reset", { profile: profileNow, state: store.getState(), exportedAt: new Date().toISOString(), appVersion: STATE_VERSION }); }catch(e){}
        store.dispatch({ type: A.STATE_RESET });
        try{ invalidateMatrixCacheForExam(getActiveExam()); }catch(e){}
        emitML("ML:STATE_RESET", {});
        toast("Resetado.");
      }
    };


// Snapshots UI (v3.0)
try{
  const list = listSnapshots();
  const box = document.getElementById("snapList");
  if(box){
    if(!list.length){
      box.innerHTML = `<div class="tiny muted">Nenhum snapshot ainda.</div>`;
    }else{
      box.innerHTML = list.map(s=>`
        <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 6px;border-bottom:1px solid var(--border);">
          <div>
            <div style="font-weight:800;">${escapeHtml(s.reason||"snapshot")} <span class="pill" style="margin-left:8px;">${escapeHtml((s.examId||"").toString())}</span></div>
            <div class="tiny muted">${escapeHtml(fmtDateTime(s.at))} ‚Ä¢ ${escapeHtml(String(s.appVersion||""))}</div>
          </div>
          <div class="actions">
            <button class="btn" data-snap-download="${escapeHtml(s.id)}">Baixar</button>
            <button class="btn primary" data-snap-restore="${escapeHtml(s.id)}">Restaurar</button>
          </div>
        </div>
      `).join("");
    }
  }
  // download
  document.querySelectorAll("[data-snap-download]").forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute("data-snap-download");
      const found = list.find(x=>x.id===id);
      if(!found) return;
      const jsonS = JSON.stringify(found.payload || {}, null, 2);
      const blob = new Blob([jsonS], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `SAPE_snapshot_${(found.reason||"snapshot")}_${new Date(found.at).toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      toast("Snapshot baixado");
    };
  });
  // restore
  document.querySelectorAll("[data-snap-restore]").forEach(btn=>{
    btn.onclick = ()=>{
      const id = btn.getAttribute("data-snap-restore");
      const found = list.find(x=>x.id===id);
      if(!found || !found.payload) return;
      if(!confirm("Restaurar este snapshot? Isso sobrescreve o estado atual.")) return;
      try{
        // snapshot do estado atual antes de restaurar
        try{ const profileNow = loadProfile(); pushSnapshot("pre_restore", { profile: profileNow, state: store.getState(), exportedAt: new Date().toISOString(), appVersion: STATE_VERSION }); }catch(e){}
        const pld = found.payload;
        if(pld.profile) saveProfile(pld.profile);
        if(pld.state) store.dispatch({ type: A.STATE_IMPORT, payload: pld.state });
        if(pld.profile && pld.profile.mainExamId) setActiveExam(pld.profile.mainExamId);
        try{ localStorage.setItem(STORAGE_META_KEY, JSON.stringify({ restoredAt: Date.now(), reason: "snapshot_restore", version: STATE_VERSION })); }catch(e){}
        try{ invalidateMatrixCacheForExam(getActiveExam()); }catch(e){}
        emitML("ML:STATE_IMPORTED", { source:"snapshot" });
        emitML("ML:REVIEWS_UPDATED", { source:"snapshot" });
        toast("Snapshot restaurado ‚úì");
      }catch(e){
        toast("Falha ao restaurar snapshot.");
      }
    };
  });
}catch(e){}
  }

  render();
  const unsub = store.subscribe(()=>{ if(currentTab==="settings") render(); });
  return ()=> unsub();
}

/* =========================
   BOOT
========================= */
safeCall(()=>{

// v3.0: listeners globais (n√£o acopla m√≥dulos)
try{
  window.addEventListener("ML:REVIEWS_UPDATED", ()=>{
    if(currentTab==="schedule" && typeof renderBlocoZero==="function") renderBlocoZero();
  });
  window.addEventListener("ML:PERF_LOGGED", ()=>{
    // ao mudar desempenho, tamb√©m pode afetar Matriz; evita stale cache
    try{
      const p = loadProfile();
      if(p && isProfileComplete(p)) ensureMatrix(p);
    }catch(e){}
    if(currentTab==="schedule" && typeof renderBlocoZero==="function") renderBlocoZero();
  });
  window.addEventListener("ML:STATE_IMPORTED", ()=>{
    if(currentTab==="schedule" && typeof renderBlocoZero==="function") renderBlocoZero();
  });
}catch(e){}
  const p = loadProfile();
  if(!p){
    go("profile");
  }else{
    if(p.mainExamId) setActiveExam(p.mainExamId);
    go("dashboard");
  }
}, "boot(profile)");

// ---- PCPR Fixed Weight Multiplier ----
if (typeof computeDisciplineWeightMap === "function") {
  const _baseCompute = computeDisciplineWeightMap;
  computeDisciplineWeightMap = function(state){
    const map = _baseCompute(state);
    const exam = EXAMS[getActiveExam()];
    if(exam && exam.weights){
      Object.entries(exam.weights).forEach(([disc, fixedWeight])=>{
        const current = map.get(disc) || 1;
        map.set(disc, current * fixedWeight);
      });
    }
    return map;
  };
}
// ---- End PCPR Multiplier ----

</script>


<script>
// ====== REVIS√ïES AUTOM√ÅTICAS ======

function calculateNextReview(date, level=1){
  const days = [1,3,7,15,30]; // spaced repetition simples
  const next = new Date(date);
  next.setDate(next.getDate() + (days[level-1] || 7));
  return next.getTime();
}

function mountRevisoes(){
  const container = document.getElementById("app");
  const userId = state?.userState?.activeUserId;
  if(!userId){
    container.innerHTML = "<div style='padding:20px'>Selecione um usu√°rio.</div>";
    return;
  }

  let listHTML = "";
  const notebook = state.notebookState || {};
  Object.keys(notebook).forEach(exam=>{
    Object.keys(notebook[exam]||{}).forEach(disc=>{
      Object.keys(notebook[exam][disc]||{}).forEach(topic=>{
        const topicObj = notebook[exam][disc][topic];
        (topicObj.errors||[]).forEach(err=>{
          if(!err.nextReviewAt){
            err.nextReviewAt = calculateNextReview(err.date || Date.now(),1);
          }
          if(Date.now() >= err.nextReviewAt){
            listHTML += `
              <div class="card">
                <b>${disc}</b> ‚Äî ${topic}<br>
                ${err.content}<br>
                <button onclick="markReviewed('${exam}','${disc}','${topic}',${err.date})">Marcar como Revisado</button>
              </div>
            `;
          }
        });
      });
    });
  });

  container.innerHTML = `
    <h2>üìö Revis√µes Autom√°ticas</h2>
    ${listHTML || "<div class='card'>Nenhuma revis√£o pendente üéØ</div>"}
  `;
}

function markReviewed(exam,disc,topic,date){
  const topicObj = state.notebookState[exam][disc][topic];
  topicObj.errors.forEach(err=>{
    if(err.date === date){
      err.level = (err.level||1)+1;
      err.nextReviewAt = calculateNextReview(Date.now(), err.level);
    }
  });
  alert("Revis√£o atualizada!");
  mountRevisoes();
}
</script>


<script>
// ===== BLOCO 0 - REVIS√ÉO AUTOM√ÅTICA NO IN√çCIO DO DIA =====


function daysUntilExam(examDateISO){
  if(!examDateISO) return Infinity;
  const now = new Date();
  const ex = new Date(examDateISO);
  if(isNaN(ex.getTime())) return Infinity;
  return Math.ceil((ex.getTime() - now.getTime()) / (1000*60*60*24));
}

function getEffectiveReviewPercentage(){
  const p = loadProfile() || {};
  const manual = (p.reviewLoadManual || "padrao");
  const autoOn = (p.autoIntensiveEnabled !== false);
  const d = daysUntilExam(p.examDateISO);

  const effective = (autoOn && d <= 30) ? "intensivo" : manual;

  if(effective === "leve") return 0.15;
  if(effective === "intensivo") return 0.25;
  return 0.20;
}


function clampNum(v, min, max, dft){
  const n = Number(v);
  if(!isFinite(n)) return dft;
  return Math.max(min, Math.min(max, n));
}

function getDynamicReviewLimit(){
  const p = loadProfile() || {};
  const horas = clampNum(p.studyHoursPerDay, 0.5, 16, 6);
  const pct = getEffectiveReviewPercentage();
  const minutosRevisao = horas * 60 * pct;
  const qtd = Math.floor(minutosRevisao / 6); // 6 min por revis√£o
  return Math.max(3, Math.min(25, qtd)); // trava seguran√ßa
}

function getTodayReviewBuckets(){
  const st = store.getState();
  const buckets = selectScheduleBuckets(st);
  return buckets;
}


function dayKeyISO(d){
  const z = new Date(d);
  z.setHours(0,0,0,0);
  return z.toISOString().slice(0,10);
}
function loadTodayDisciplines(){
  try{
    const k = mlKey("ML_DAY_DISCS_" + dayKeyISO(new Date()));
    const raw = localStorage.getItem(k);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr.filter(Boolean) : [];
  }catch{ return []; }
}
function saveTodayDisciplines(arr){
  try{
    const k = mlKey("ML_DAY_DISCS_" + dayKeyISO(new Date()));
    localStorage.setItem(k, JSON.stringify((arr||[]).filter(Boolean).slice(0,3)));
  
try{
  window.dispatchEvent(new CustomEvent("ML:DAY_DISCS_SAVED", { detail: { dateKey: dayKeyISO(new Date()), discs: Array.isArray(arr)?arr:[] } }));
}catch(e){}
}catch{}
}



function saveTodayPlan(plan){
  try{
    const k = mlKey("ML_DAY_PLAN_" + dayKeyISO(new Date()));
    localStorage.setItem(k, JSON.stringify(plan||{}));
    try{
      window.dispatchEvent(new CustomEvent("ML:DAY_PLAN_SAVED", { detail: { dateKey: dayKeyISO(new Date()), plan: plan||{} } }));
    }catch(e){}
  }catch(e){}
}
function loadDayPlanByKey(dayKey){
  try{
    const k = mlKey("ML_DAY_PLAN_" + dayKey);
    const raw = localStorage.getItem(k);
    const obj = raw ? JSON.parse(raw) : null;
    return (obj && typeof obj==="object") ? obj : null;
  }catch(e){ return null; }
}
function loadDayDisciplinesByKey(dayKey){
  try{
    const k = mlKey("ML_DAY_DISCS_" + dayKey);
    const raw = localStorage.getItem(k);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr.filter(Boolean) : [];
  }catch{ return []; }
}
function isoDayKeyNDaysAgo(n){
  const d = new Date();
  d.setHours(0,0,0,0);
  d.setDate(d.getDate() - n);
  return d.toISOString().slice(0,10);
}
function suggestDisciplinesFromHistory(windowDays=10, max=3){
  // conta frequ√™ncia + rec√™ncia
  const score = new Map(); // disc -> score
  for(let i=1;i<=windowDays;i++){
    const key = isoDayKeyNDaysAgo(i);
    const discs = loadDayDisciplinesByKey(key);
    const recencyWeight = (windowDays - i + 1) / windowDays; // mais recente pesa mais
    discs.forEach(d=>{
      const s = score.get(d) || 0;
      score.set(d, s + 1.0 + recencyWeight);
    });
  }
  const arr = Array.from(score.entries())
    .sort((a,b)=> b[1]-a[1] || String(a[0]).localeCompare(String(b[0])))
    .map(([d])=>d);
  return arr.slice(0, max);
}


function collectDisciplinesFromExamStruct(state){
  // tenta extrair disciplinas do edital/matriz do concurso ativo (mais robusto que depender de erros j√° registrados)
  const discs = new Set();
  const examId = (typeof loadProfile==="function" ? (loadProfile()||{}).mainExamId : "") || "";

  const pushArr = (arr)=>{
    if(Array.isArray(arr)) arr.forEach(x=>{ if(x) discs.add(String(x)); });
  };
  const pushKeys = (obj)=>{
    if(obj && typeof obj==="object" && !Array.isArray(obj)){
      Object.keys(obj).forEach(k=>{ if(k) discs.add(String(k)); });
    }
  };

  // caminhos comuns
  try{
    const exams = state.exams || state.contests || state.concursos || {};
    const ex = examId && exams[examId] ? exams[examId] : null;
    if(ex){
      pushArr(ex.disciplines); pushArr(ex.disciplinas); pushArr(ex.subjects); pushArr(ex.materias);
      pushKeys(ex.topicsByDiscipline); pushKeys(ex.topicosPorDisciplina);
      pushKeys(ex.syllabus); pushKeys(ex.edital); pushKeys(ex.programa);
    }
  }catch(e){}

  try{
    const cur = state.curriculum || state.matriz || state.program || state.programa || {};
    const exCur = examId && cur[examId] ? cur[examId] : null;
    if(exCur){
      pushArr(exCur.disciplines); pushArr(exCur.disciplinas); pushArr(exCur.subjects); pushArr(exCur.materias);
      pushKeys(exCur.topicsByDiscipline); pushKeys(exCur.topicosPorDisciplina);
      pushKeys(exCur.syllabus); pushKeys(exCur.edital); pushKeys(exCur.programa);
    }
  }catch(e){}

  // fallback: varre o plano semanal do cronograma (se existir)
  try{
    const sch = state.schedule || state.cronograma || {};
    const exSch = examId && sch[examId] ? sch[examId] : sch;
    if(exSch){
      const days = exSch.days || exSch.dias || exSch.week || exSch.semana;
      if(Array.isArray(days)){
        days.forEach(d=>{
          pushArr(d.disciplines || d.disciplinas);
          pushArr(d.subjects || d.materias);
        });
      }
    }
  }catch(e){}

  return Array.from(discs);
}


function normalizeExamKey(examId){
  const s = String(examId||"").toLowerCase();
  if(s.includes("trt")) return "trt_aj";
  if(s.includes("tre")) return "tre_aj";
  if(s.includes("inss")) return "inss";
  if(s.includes("rfb") || s.includes("receita") || s.includes("auditor")) return "rfb_auditor";
  if(s.includes("aft") || s.includes("trabalho") && s.includes("fiscal")) return "aft";
  if(s.includes("pcpr") || s.includes("policia civil") || s.includes("agente")) return "pcpr_agente";
  return s.replace(/\s+/g,"_");
}

function uniqueDisciplinesForDayPicker(state){
  // 1) tenta pegar do edital/matriz
  let all = collectDisciplinesFromExamStruct(state);
  // 2) fallback: usa erros j√° existentes no caderno
  if(!all || !all.length){
    const items = (typeof flattenNotebookErrors==="function") ? flattenNotebookErrors(state) : [];
    const set = new Set();
    items.forEach(x=>{ if(x && x.disc) set.add(String(x.disc)); });
    all = Array.from(set);
  }
  // 3) fallback final: lista base por concurso (m√≠nima) para n√£o ficar vazio
  if(!all || !all.length){
    const examId = (typeof loadProfile==="function" ? (loadProfile()||{}).mainExamId : "") || "";
    const base = {
      "trt_aj": ["Direito Constitucional","Direito Administrativo","Direito do Trabalho","Processo do Trabalho","Direito Civil","Processo Civil","Direito Penal","Processo Penal","Legisla√ß√£o/Regimento"],
      "tre_aj": ["Direito Constitucional","Direito Administrativo","Direito Eleitoral","Processo Eleitoral","Direito Penal","Processo Penal","Portugu√™s","Inform√°tica","Legisla√ß√£o"],
      "inss": ["Portugu√™s","Racioc√≠nio L√≥gico","No√ß√µes de Direito Constitucional","No√ß√µes de Direito Administrativo","Seguridade Social","Direito Previdenci√°rio","Inform√°tica"],
      "rfb_auditor": ["Portugu√™s","Racioc√≠nio L√≥gico","Direito Constitucional","Direito Administrativo","Direito Tribut√°rio","Legisla√ß√£o Tribut√°ria","Contabilidade","Auditoria","Com√©rcio Internacional"],
      "aft": ["Portugu√™s","Racioc√≠nio L√≥gico","Direito do Trabalho","Processo do Trabalho","Seguran√ßa e Sa√∫de no Trabalho","Legisla√ß√£o Trabalhista","Direito Constitucional","Direito Administrativo"],
      "pcpr_agente": ["Portugu√™s","Racioc√≠nio L√≥gico","Direito Constitucional","Direito Administrativo","Direito Penal","Processo Penal","Legisla√ß√£o Especial","Inform√°tica"]
    };
    all = base[normalizeExamKey(examId)] || base[examId] || [];
  }

  return (all||[]).filter(Boolean).sort((a,b)=>String(a).localeCompare(String(b)));
}

function prioritizeByDisc(list, preferredDiscs){
  const pref = new Set((preferredDiscs||[]).map(String));
  const a = [], b = [];
  (list||[]).forEach(it=>{
    if(pref.has(String(it.disc))) a.push(it);
    else b.push(it);
  });
  return a.concat(b);
}

function renderBlocoZero(){
  const container = document.getElementById("scheduleBlocoZero");
  if(!container) return;

  const { overdue, today } = getTodayReviewBuckets();

  const preferredDiscs = loadTodayDisciplines();
  const overdueP = prioritizeByDisc(overdue, preferredDiscs);
  const todayP = prioritizeByDisc(today, preferredDiscs);

  const limite = getDynamicReviewLimit();
  

  let html = "";

  if(overdue.length > 0){
    html += `
      <div class="card" style="border-left:4px solid #e74c3c">
        <h3>üü† Bloco 0 ‚Äì Revis√µes Atrasadas (${overdue.length})</h3>
        ${overdueP.slice(0, limite).map(e=>`
          <div style="margin-bottom:8px">
            <b>${e.disc}</b> ‚Äì ${e.topic}<br>
            ${e.prompt || ""}
            <div style="margin-top:4px">
              <button onclick="scheduleMarkReviewedNotebook('${e.id}')">Revisado</button>
              <button onclick="scheduleSetNextReviewNotebook('${e.id}', addDays(startOfDay(new Date()),1))">+1 dia</button>
            </div>
          </div>
        `).join("")}
      </div>
    `;
  }

  if(today.length > 0){
    html += `
      <div class="card" style="border-left:4px solid #3498db">
        <h3>üîµ Bloco 0 ‚Äì Revis√µes de Hoje (${today.length})</h3>
        ${todayP.slice(0, limite).map(e=>`
          <div style="margin-bottom:8px">
            <b>${e.disc}</b> ‚Äì ${e.topic}<br>
            ${e.prompt || ""}
            <div style="margin-top:4px">
              <button onclick="scheduleMarkReviewedNotebook('${e.id}')">Revisado</button>
              <button onclick="scheduleSetNextReviewNotebook('${e.id}', addDays(startOfDay(new Date()),1))">+1 dia</button>
            </div>
          </div>
        `).join("")}
      </div>
    `;
  }

  container.innerHTML = html || "";
}

// Hook dentro do mountSchedule existente
const originalMountSchedule = mountSchedule;
mountSchedule = function(){
  originalMountSchedule();
  const app = document.getElementById("app");
  if(app){
    const blocoZeroDiv = document.createElement("div");
    blocoZeroDiv.id = "scheduleBlocoZero";
    app.prepend(blocoZeroDiv);
    renderBlocoZero();
  }
};
</script>


<script>
// =========================
// MATRIZ CURRICULAR (Modelo C - h√≠brido)
// - Base fixa por cargo + ajustes por desempenho real
// - Usa data de in√≠cio (perfil) + horizonte (INSS=8m, demais=12m)
// - Gera matriz semanal (7 dias) com 2 disciplinas/dia + t√≥picos em ordem pedag√≥gica
// =========================

function getHorizonMonthsByExam(examId){
  const k = String(examId||"").toLowerCase();
  // INSS em ~8 meses (pedido)
  if(k.includes("inss")) return 8;
  return 12;
}

function normalizeExamKey(examId){
  const s = String(examId||"").toLowerCase();
  if(s.includes("trt")) return "trt_aj";
  if(s.includes("tre")) return "tre_aj";
  if(s.includes("inss")) return "inss";
  if(s.includes("rfb") || s.includes("receita") || s.includes("auditor")) return "rfb_auditor";
  if(s.includes("aft") || (s.includes("fiscal") && s.includes("trabalho"))) return "aft";
  if(s.includes("pcpr") || s.includes("policia civil") || s.includes("agente")) return "pcpr_agente";
  return s.replace(/\s+/g,"_");
}

function getExamBlueprint(examIdRaw){
  const examId = normalizeExamKey(examIdRaw);
  // OBS: lista "n√≠vel alto" (com t√≥picos bem distribu√≠dos). O sistema pode ser refinado depois com editais espec√≠ficos.
  const blueprints = {
    trt_aj: {
      name: "TRT ‚Äì Analista Judici√°rio (√Årea Judici√°ria)",
      disciplines: [
        { name:"Direito Constitucional", weight: 0.14, topics:[
          "Constitui√ß√£o: conceito, classifica√ß√µes, supremacia",
          "Aplicabilidade/efic√°cia das normas; interpreta√ß√£o constitucional",
          "Princ√≠pios fundamentais",
          "Direitos e garantias fundamentais (geral)",
          "Rem√©dios constitucionais (HC, MS, MI, HD, AP, ACP)",
          "Controle de constitucionalidade (difuso/concentrado; ADI/ADC/ADPF)",
          "Organiza√ß√£o do Estado; compet√™ncias",
          "Administra√ß√£o P√∫blica na CF; princ√≠pios",
          "Poder Legislativo/Executivo/Judici√°rio ‚Äì no√ß√µes",
          "Jurisprud√™ncia STF (t√≥picos quentes)"
        ]},
        { name:"Direito Administrativo", weight: 0.14, topics:[
          "Regime jur√≠dico-administrativo; princ√≠pios",
          "Organiza√ß√£o administrativa (direta/indireta; entidades)",
          "√ìrg√£os p√∫blicos (conceito/classifica√ß√£o)",
          "Agentes p√∫blicos (esp√©cies; provimento; responsabilidades)",
          "Poderes administrativos (hier√°rquico, disciplinar, regulamentar, pol√≠cia)",
          "Atos administrativos (elementos, atributos, invalida√ß√£o, convalida√ß√£o)",
          "Responsabilidade civil do Estado",
          "Servi√ßos p√∫blicos (no√ß√µes)",
          "Licita√ß√µes e contratos (no√ß√µes/lei aplic√°vel)",
          "Improbidade/abuso de autoridade (no√ß√µes)"
        ]},
        { name:"Direito do Trabalho", weight: 0.18, topics:[
          "Princ√≠pios; fontes; interpreta√ß√£o",
          "Rela√ß√£o de trabalho x rela√ß√£o de emprego; sujeitos",
          "Contrato de trabalho (forma√ß√£o, altera√ß√µes, suspens√£o/interrup√ß√£o)",
          "Jornada/descanso; horas extras; banco de horas",
          "Sal√°rio e remunera√ß√£o; adicionais",
          "FGTS; estabilidade/garantias provis√≥rias",
          "Rescis√£o; verbas rescis√≥rias; aviso-pr√©vio",
          "Terceiriza√ß√£o; grupos econ√¥micos; responsabilidade",
          "Direito coletivo (sindicatos, negocia√ß√£o, greve)",
          "Prescri√ß√£o/decad√™ncia; jurisprud√™ncia TST (t√≥picos quentes)"
        ]},
        { name:"Processo do Trabalho", weight: 0.16, topics:[
          "Princ√≠pios; fontes; aplica√ß√£o CPC",
          "Compet√™ncia material/territorial; rito",
          "Peti√ß√£o inicial; audi√™ncias; provas",
          "Defesas (contesta√ß√£o, exce√ß√µes); revelia",
          "Recursos (ordin√°rio, revista, agravos; embargos)",
          "Execu√ß√£o trabalhista (t√≠tulos; liquida√ß√£o; embargos)",
          "Execu√ß√£o contra a Fazenda; precat√≥rios/RPV (no√ß√µes)",
          "Tutelas provis√≥rias; procedimentos especiais (no√ß√µes)",
          "Jurisprud√™ncia TST (S√∫mulas/OJs)",
          "Prazos/contagem/atos processuais"
        ]},
        { name:"Direito Civil + Processo Civil (no√ß√µes)", weight: 0.12, topics:[
          "Lei; vig√™ncia; interpreta√ß√£o; LINDB (no√ß√µes)",
          "Pessoas; bens; fatos jur√≠dicos (no√ß√µes)",
          "Obriga√ß√µes/contratos (no√ß√µes)",
          "Responsabilidade civil (no√ß√µes)",
          "Processo: jurisdi√ß√£o/a√ß√£o/compet√™ncia (no√ß√µes)",
          "Partes/advocacia; atos processuais (no√ß√µes)",
          "Provas (no√ß√µes)",
          "Recursos (no√ß√µes)",
          "Cumprimento de senten√ßa/execu√ß√£o (no√ß√µes)",
          "Tutelas provis√≥rias (no√ß√µes)"
        ]},
        { name:"Direito Penal + Processo Penal (no√ß√µes)", weight: 0.10, topics:[
          "Princ√≠pios; aplica√ß√£o da lei penal (no√ß√µes)",
          "Crime: fato t√≠pico/ilicitude/culpabilidade (no√ß√µes)",
          "Penas; concurso; prescri√ß√£o (no√ß√µes)",
          "Crimes contra a Administra√ß√£o (no√ß√µes)",
          "Inqu√©rito; a√ß√£o penal (no√ß√µes)",
          "Provas (no√ß√µes)",
          "Pris√µes e medidas cautelares (no√ß√µes)",
          "Procedimentos (no√ß√µes)",
          "Recursos (no√ß√µes)",
          "Jurisprud√™ncia (no√ß√µes)"
        ]},
        { name:"Legisla√ß√£o/Regimento/√âtica (no√ß√µes)", weight: 0.08, topics:[
          "Lei de organiza√ß√£o do TRT (no√ß√µes)",
          "Regimento interno (no√ß√µes)",
          "√âtica e conduta na Administra√ß√£o (no√ß√µes)",
          "Acessibilidade/atendimento priorit√°rio (no√ß√µes)",
          "LGPD (no√ß√µes)",
          "Sustentabilidade/gest√£o p√∫blica (no√ß√µes)",
          "Direitos humanos (no√ß√µes)",
          "Atualidades jur√≠dicas (no√ß√µes)"
        ]}
      ]
    },
    tre_aj: {
      name: "TRE ‚Äì Analista Judici√°rio (√Årea Judici√°ria)",
      disciplines: [
        { name:"Direito Constitucional", weight: 0.16, topics:[
          "Constitui√ß√£o e princ√≠pios fundamentais",
          "Direitos e garantias fundamentais",
          "Controle de constitucionalidade",
          "Organiza√ß√£o do Estado e compet√™ncias",
          "Poder Judici√°rio; CNJ (no√ß√µes)",
          "Administra√ß√£o P√∫blica na CF"
        ]},
        { name:"Direito Administrativo", weight: 0.14, topics:[
          "Princ√≠pios; organiza√ß√£o administrativa",
          "Atos; poderes; responsabilidade",
          "Agentes p√∫blicos",
          "Licita√ß√µes/contratos (no√ß√µes)",
          "Improbidade/abuso de autoridade (no√ß√µes)"
        ]},
        { name:"Direito Eleitoral", weight: 0.22, topics:[
          "Direitos pol√≠ticos; alistamento; domic√≠lio eleitoral",
          "Partidos pol√≠ticos; filia√ß√£o",
          "Sistema eleitoral; regras gerais",
          "Propaganda eleitoral",
          "A√ß√µes eleitorais (AIJE, AIME, RCED etc.) ‚Äì no√ß√µes",
          "Inelegibilidades (LC 64/90) ‚Äì no√ß√µes",
          "Presta√ß√£o de contas (no√ß√µes)",
          "Crimes eleitorais (no√ß√µes)",
          "Jurisprud√™ncia TSE (t√≥picos quentes)"
        ]},
        { name:"Processo Eleitoral (no√ß√µes)", weight: 0.14, topics:[
          "Compet√™ncia; jurisdi√ß√£o eleitoral",
          "Prazos; recursos no CE (no√ß√µes)",
          "Procedimentos; representa√ß√µes (no√ß√µes)",
          "Execu√ß√£o de decis√µes (no√ß√µes)"
        ]},
        { name:"Direito Penal + Processo Penal (no√ß√µes)", weight: 0.12, topics:[
          "Lei penal; teoria do crime (no√ß√µes)",
          "Crimes contra a Administra√ß√£o (no√ß√µes)",
          "Processo penal: a√ß√£o penal; provas (no√ß√µes)",
          "Medidas cautelares/pris√£o (no√ß√µes)"
        ]},
        { name:"Portugu√™s/Reda√ß√£o (se aplic√°vel)", weight: 0.12, topics:[
          "Interpreta√ß√£o de textos",
          "Gram√°tica essencial (concord√¢ncia, reg√™ncia, crase)",
          "Pontua√ß√£o; coes√£o/coer√™ncia",
          "Reescrita/estilo (no√ß√µes)"
        ]},
        { name:"Inform√°tica/LGPD (no√ß√µes)", weight: 0.10, topics:[
          "No√ß√µes de inform√°tica",
          "Seguran√ßa da informa√ß√£o (no√ß√µes)",
          "LGPD (no√ß√µes)"
        ]}
      ]
    },
    inss: {
      name: "INSS ‚Äì Analista/T√©cnico",
      disciplines: [
        { name:"Portugu√™s", weight: 0.18, topics:[
          "Interpreta√ß√£o de textos",
          "Ortografia/acentua√ß√£o; crase",
          "Pontua√ß√£o",
          "Concord√¢ncia/reg√™ncia",
          "Coes√£o/coer√™ncia; reescrita"
        ]},
        { name:"Racioc√≠nio L√≥gico/Matem√°tica", weight: 0.14, topics:[
          "Porcentagem; raz√£o/propor√ß√£o",
          "Conjuntos; l√≥gica proposicional",
          "Problemas; sequ√™ncias; probabilidade (no√ß√µes)",
          "Racioc√≠nio anal√≠tico"
        ]},
        { name:"Dir. Constitucional (no√ß√µes)", weight: 0.10, topics:[
          "Princ√≠pios fundamentais",
          "Direitos e garantias",
          "Administra√ß√£o P√∫blica na CF (no√ß√µes)"
        ]},
        { name:"Dir. Administrativo (no√ß√µes)", weight: 0.10, topics:[
          "Princ√≠pios; atos; poderes",
          "Agentes p√∫blicos (no√ß√µes)",
          "Responsabilidade do Estado (no√ß√µes)"
        ]},
        { name:"Seguridade Social / Previdenci√°rio", weight: 0.34, topics:[
          "Seguridade Social (CF)",
          "RGPS: princ√≠pios e organiza√ß√£o",
          "Segurados, dependentes, filia√ß√£o e inscri√ß√£o",
          "Car√™ncia e contribui√ß√µes (no√ß√µes)",
          "Benef√≠cios: esp√©cies e requisitos (no√ß√µes)",
          "C√°lculo/ manuten√ß√£o (no√ß√µes)",
          "Processo administrativo previdenci√°rio (no√ß√µes)",
          "Jurisprud√™ncia (no√ß√µes)"
        ]},
        { name:"Inform√°tica (no√ß√µes)", weight: 0.14, topics:[
          "No√ß√µes de inform√°tica",
          "Internet/seguran√ßa (no√ß√µes)",
          "Pacote Office/Google (no√ß√µes)"
        ]}
      ]
    },
    rfb_auditor: {
      name: "RFB ‚Äì Auditor-Fiscal",
      disciplines: [
        { name:"Portugu√™s", weight: 0.10, topics:["Interpreta√ß√£o","Gram√°tica essencial","Reda√ß√£o (no√ß√µes)"]},
        { name:"Racioc√≠nio L√≥gico/Matem√°tica", weight: 0.10, topics:["L√≥gica","Estat√≠stica b√°sica (no√ß√µes)","Matem√°tica financeira (no√ß√µes)"]},
        { name:"Dir. Constitucional", weight: 0.10, topics:["DF","Controle","Organiza√ß√£o do Estado"]},
        { name:"Dir. Administrativo", weight: 0.08, topics:["Princ√≠pios","Atos/poderes","Licita√ß√µes (no√ß√µes)"]},
        { name:"Dir. Tribut√°rio", weight: 0.22, topics:["Sistema tribut√°rio","Esp√©cies","Cr√©dito tribut√°rio","Obriga√ß√µes","Lan√ßamento","Imunidades/isenc√µes (no√ß√µes)"]},
        { name:"Legisla√ß√£o Tribut√°ria", weight: 0.20, topics:["Tributos federais (no√ß√µes)","Normas gerais","Procedimentos (no√ß√µes)"]},
        { name:"Contabilidade", weight: 0.12, topics:["Contabilidade geral","Demonstra√ß√µes","An√°lise (no√ß√µes)"]},
        { name:"Auditoria", weight: 0.08, topics:["Auditoria (no√ß√µes)","Controles internos (no√ß√µes)"]}
      ]
    },
    aft: {
      name: "AFT ‚Äì Auditor-Fiscal do Trabalho",
      disciplines: [
        { name:"Portugu√™s", weight: 0.12, topics:["Interpreta√ß√£o","Gram√°tica essencial"]},
        { name:"Racioc√≠nio L√≥gico", weight: 0.10, topics:["L√≥gica proposicional","Problemas"]},
        { name:"Dir. Constitucional", weight: 0.10, topics:["DF","Administra√ß√£o P√∫blica"]},
        { name:"Dir. Administrativo", weight: 0.08, topics:["Princ√≠pios","Atos/poderes","Agentes"]},
        { name:"Dir. do Trabalho", weight: 0.25, topics:["Contrato","Jornada","Remunera√ß√£o","Rescis√£o","Coletivo"]},
        { name:"Proc. do Trabalho", weight: 0.15, topics:["Compet√™ncia","Audi√™ncias/provas","Recursos","Execu√ß√£o"]},
        { name:"SST/Leg. Trabalhista", weight: 0.20, topics:["NRs (no√ß√µes)","Fiscaliza√ß√£o","Infra√ß√µes/penalidades (no√ß√µes)"]}
      ]
    },
    pcpr_agente: {
      name: "PCPR ‚Äì Agente de Pol√≠cia Civil",
      disciplines: [
        { name:"Portugu√™s", weight: 0.16, topics:["Interpreta√ß√£o","Gram√°tica essencial","Pontua√ß√£o"]},
        { name:"Racioc√≠nio L√≥gico", weight: 0.12, topics:["L√≥gica","Problemas","Sequ√™ncias"]},
        { name:"Dir. Constitucional", weight: 0.12, topics:["DF","Direitos fundamentais","Seguran√ßa p√∫blica (no√ß√µes)"]},
        { name:"Dir. Administrativo", weight: 0.10, topics:["Princ√≠pios","Atos/poderes","Agentes"]},
        { name:"Dir. Penal", weight: 0.18, topics:["Teoria do crime","Penas","Crimes em esp√©cie (no√ß√µes)","Crimes contra Adm. (no√ß√µes)"]},
        { name:"Proc. Penal", weight: 0.16, topics:["Inqu√©rito","A√ß√£o penal","Provas","Pris√µes/medidas"]},
        { name:"Legisla√ß√£o Especial (no√ß√µes)", weight: 0.10, topics:["Leis penais especiais (no√ß√µes)","Organiza√ß√£o/estatuto (no√ß√µes)"]},
        { name:"Inform√°tica (no√ß√µes)", weight: 0.06, topics:["No√ß√µes de inform√°tica","Seguran√ßa (no√ß√µes)"]}
      ]
    }
  };

  return blueprints[examId] || blueprints.trt_aj;
}

function startOfDay(d){
  const x = new Date(d);
  x.setHours(0,0,0,0);
  return x;
}
function addDays(d, n){
  const x = new Date(d);
  x.setDate(x.getDate()+n);
  return x;
}
function fmtDateISO(d){
  const x = new Date(d);
  return x.toISOString().slice(0,10);
}

function mlComputeConsistencyFromEventsForDisc(discName){
  try{
    const st = (typeof store !== "undefined" && store.getState) ? store.getState() : null;
    if(!st) return null;
    const uid = st.userState?.activeUserId;
    const log = (st.eventLog && uid && st.eventLog[uid]) ? st.eventLog[uid] : [];
    if(!Array.isArray(log) || !log.length) return null;

    // last 30 days only (para estabilidade)
    const now = Date.now();
    const cutoff = now - 30*86400000;

    const byDay = {};
    for(const e of log){
      if(!e || e.type!=="question_done") continue;
      if(e.ts && e.ts < cutoff) continue;
      const p = e.payload||{};
      const disc = p.disciplina || p.disc;
      if(!disc || String(disc)!==String(discName)) continue;
      const day = new Date(e.ts).toISOString().slice(0,10);
      if(!byDay[day]) byDay[day] = { total:0, correct:0 };
      byDay[day].total += 1;
      const ok = !!(p.correct===true || p.acertou===true);
      if(ok) byDay[day].correct += 1;
    }
    const days = Object.keys(byDay).sort();
    let n=0;
    const accs=[];
    for(const d of days){
      const t = byDay[d].total||0;
      n += t;
      const a = t ? (byDay[d].correct/t)*100 : 0;
      // expand capped by volume
      const reps = Math.min(10, Math.max(1, Math.round(t/3)));
      for(let i=0;i<reps;i++) accs.push(a);
    }
    const sd = mlStdDev(accs);
    let band="insuf";
    if(n>=25){
      if(sd < 6) band="stable";
      else if(sd < 12) band="mid";
      else band="high";
    }
    return { n, sd, band };
  }catch(e){
    return null;
  }
}

function computeDisciplineStatsFromEvents(){
  // tenta ajustar pesos pelo desempenho real (se houver eventos)
  const st = (typeof store !== "undefined" && store.getState) ? store.getState() : null;
  if(!st) return null;
  const uid = st.userState?.activeUserId;
  const log = (st.eventLog && uid && st.eventLog[uid]) ? st.eventLog[uid] : [];
  if(!Array.isArray(log) || !log.length) return null;

  const byDisc = {};
  for(const e of log){
    if(!e || e.type !== "question_done") continue;
    const disc = (e.payload && e.payload.disciplina) ? String(e.payload.disciplina) : (e.payload && e.payload.disc) ? String(e.payload.disc) : "";
    if(!disc) continue;
    const ok = !!(e.payload && (e.payload.correct === true || e.payload.acertou === true));
    if(!byDisc[disc]) byDisc[disc] = { n:0, ok:0 };
    byDisc[disc].n += 1;
    byDisc[disc].ok += ok ? 1 : 0;
  }
  // accuracy %
  Object.keys(byDisc).forEach(k=>{
    byDisc[k].acc = byDisc[k].n ? (byDisc[k].ok/byDisc[k].n)*100 : 0;
  });
  return byDisc;
}



function getPerfSignature(){
  // Assinatura leve do desempenho por disciplina (para invalidar cache da Matriz)
  // Considera apenas disciplinas com algum volume; arredonda para evitar churn.
  try{
    const perf = computeDisciplineStatsFromEvents();
    if(!perf) return "no-perf";
    const keys = Object.keys(perf).sort();
    const parts = [];
    keys.forEach(k=>{
      const p = perf[k] || {};
      const n = Number(p.n||0);
      if(!n) return;
      const acc = Number(p.acc||0);
      const acc1 = Math.round(acc*10)/10;
      parts.push(k + ":" + n + ":" + acc1);
    });
    return parts.length ? parts.join("|") : "no-perf";
  }catch(e){
    return "no-perf";
  }
}
function adjustWeightsHybrid(disciplines){
  // Modelo C: pesos base + ajuste por desempenho (se houver)
  const perf = computeDisciplineStatsFromEvents(); // may be null
  if(!perf) return disciplines.map(d=>({...d, weightAdj:d.weight, adjReason:"base"}));

  return disciplines.map(d=>{
    const p = perf[d.name];
    if(!p || p.n < 25) return {...d, weightAdj:d.weight, adjReason:"base (sem dados suficientes)"};

    // regras simples (pode refinar depois):
    // <65%: +20% de peso | 65-75: +10% | 75-85: base | >85: -10%
    let mult = 1.0;
    if(p.acc < 65) mult = 1.20;
    else if(p.acc < 75) mult = 1.10;
    else if(p.acc > 85) mult = 0.90;

    
// Sinal auxiliar (beta): consist√™ncia ‚Äî se ativado e a disciplina estiver muito oscilante, aumenta levemente o peso
try{
  if(mlGetUseConsistency && mlGetUseConsistency()){
    const c = mlComputeConsistencyFromEventsForDisc(d.name);
    if(c && c.n>=25 && c.band==="high" && p.acc < 75){
      mult *= 1.05; // leve, para n√£o causar instabilidade
    }
  }
}catch(e){}

    return {...d, weightAdj: d.weight*mult, adjReason:`ajuste por desempenho (${Math.round(p.acc)}% em ${p.n} quest√µes)`};
  });
}

function normalizeWeights(ds){
  const sum = ds.reduce((a,x)=>a+(x.weightAdj||x.weight||0),0) || 1;
  return ds.map(x=>({...x, weightNorm:(x.weightAdj||x.weight)/sum}));
}

function generateMatrixPlan(profile){
  const examId = profile.mainExamId;
  const bp = getExamBlueprint(examId);
  const horizonMonths = getHorizonMonthsByExam(examId);
  const weeks = horizonMonths * 4; // aproxima√ß√£o pr√°tica (32 / 48 semanas)
  const start = startOfDay(profile.startDateISO);
  const totalDays = weeks * 7;

  // fases (C h√≠brido): base fixa, mas fases estruturam did√°tica
  const phase1 = Math.round(totalDays * 0.35); // Fundamentos
  const phase2 = Math.round(totalDays * 0.35); // Constru√ß√£o
  const phase3 = Math.round(totalDays * 0.20); // Consolida√ß√£o
  const phase4 = totalDays - phase1 - phase2 - phase3; // Revis√£o intensiva

  const dsAdj = normalizeWeights(normalizeWeights(adjustWeightsHybrid(bp.disciplines)));

  // round-robin ponderado: acumulador
  const acc = dsAdj.map(d=>({name:d.name, w:d.weightNorm, c:0, idx:0, topics:d.topics||[]}));

  function pickDisc(){
    // escolhe maior (c + w) e depois subtrai 1 (smooth weighted round robin)
    let best = acc[0];
    for(const it of acc){
      it.c += it.w;
      if(it.c > best.c) best = it;
    }
    best.c -= 1;
    return best;
  }

  function getTopic(it, dayIndex){
    const phase = (dayIndex < phase1) ? "Fundamentos" : (dayIndex < phase1+phase2) ? "Constru√ß√£o" : (dayIndex < phase1+phase2+phase3) ? "Consolida√ß√£o" : "Revis√£o";
    // progresso de t√≥picos nas 3 primeiras fases; na fase 4 vira revis√£o autom√°tica
    if(phase === "Revis√£o") return { phase, topic: "Revis√£o dirigida + quest√µes (Bloco 0 + simulados)", mode:"review" };
    if(it.idx < it.topics.length){
      const t = it.topics[it.idx];
      it.idx += 1;
      return { phase, topic: t, mode:"new" };
    }
    // se acabou t√≥picos, entra em revis√£o daquela disciplina
    return { phase, topic: "Revis√£o + quest√µes (t√≥picos j√° conclu√≠dos)", mode:"review" };
  }

  const days = [];
  for(let i=0;i<totalDays;i++){
    const date = addDays(start, i);
    const d1 = pickDisc();
    const d2 = pickDisc();
    const t1 = getTopic(d1, i);
    const t2 = getTopic(d2, i);

    days.push({
      dateISO: fmtDateISO(date),
      weekday: date.toLocaleDateString("pt-BR", { weekday:"long" }),
      blocks: [
        { disc: d1.name, topic: t1.topic, phase: t1.phase, mode: t1.mode },
        { disc: d2.name, topic: t2.topic, phase: t2.phase, mode: t2.mode }
      ]
    });
  }

  return {
    examName: bp.name,
    examKey: normalizeExamKey(examId),
    perfSig: getPerfSignature(),
    horizonMonths,
    weeks,
    startISO: fmtDateISO(start),
    endISO: fmtDateISO(addDays(start, totalDays-1)),
    phases: {
      fundamentos: { days: phase1, endISO: fmtDateISO(addDays(start, phase1-1)) },
      construcao: { days: phase2, endISO: fmtDateISO(addDays(start, phase1+phase2-1)) },
      consolidacao: { days: phase3, endISO: fmtDateISO(addDays(start, phase1+phase2+phase3-1)) },
      revisao: { days: phase4, endISO: fmtDateISO(addDays(start, totalDays-1)) }
    },
    disciplines: dsAdj,
    days
  };
}

function saveMatrixForExam(examId, matrix){
  try{
    const key = mlKey("ML_MATRIX_" + normalizeExamKey(examId));
    localStorage.setItem(key, JSON.stringify(matrix));
  }catch{}
}
function loadMatrixForExam(examId){
  try{
    const key = mlKey("ML_MATRIX_" + normalizeExamKey(examId));
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : null;
  }catch{ return null; }
}


/* =========================
   v3.0 Helpers (Cache, Events, Snapshots)
========================= */
const SNAPSHOT_KEY_V3 = "ML_SNAPSHOTS_V3";

function pushSnapshot(reason, payload){
  try{
    const arrRaw = localStorage.getItem(SNAPSHOT_KEY_V3);
    const arr = arrRaw ? JSON.parse(arrRaw) : [];
    const ex = (payload && payload.profile && payload.profile.mainExamId) ? payload.profile.mainExamId : getActiveExam();
    const item = {
      id: "ss_" + Math.random().toString(36).slice(2,10),
      at: new Date().toISOString(),
      reason: reason || "manual",
      appVersion: (typeof STATE_VERSION!=="undefined") ? STATE_VERSION : "unknown",
      examId: ex || "",
      payload: payload
    };
    const next = [item, ...arr].slice(0, 8);
    localStorage.setItem(SNAPSHOT_KEY_V3, JSON.stringify(next));
    return item;
  }catch(e){ return null; }
}

function listSnapshots(){
  try{
    const arrRaw = localStorage.getItem(SNAPSHOT_KEY_V3);
    return arrRaw ? JSON.parse(arrRaw) : [];
  }catch(e){ return []; }
}

function invalidateMatrixCacheForExam(examId){
  try{
    const ex = examId || getActiveExam();
    if(!ex) return;
    if(typeof normalizeExamKey === "function"){
      const key = mlKey("ML_MATRIX_" + normalizeExamKey(ex));
      localStorage.removeItem(key);
      // also clear matrix-day caches for this examKey prefix
      const prefix = "ML_MATRIXDAY_" + normalizeExamKey(ex) + "_";
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith(prefix)){
          localStorage.removeItem(k);
          i--; // adjust
        }
      }
    }
  }catch(e){}
}

function ensureMatrixDay(profile, dateISO){
  try{
    const examId = profile.mainExamId;
    const examKey = (typeof normalizeExamKey==="function") ? normalizeExamKey(examId) : String(examId||"");
    const startISO = String(profile.startDateISO||"").slice(0,10);
    const perfSig = getPerfSignature ? (getPerfSignature()||"") : "";
    const dISO = String(dateISO||"").slice(0,10);
    const k = "ML_MATRIXDAY_" + examKey + "_" + startISO + "_" + (perfSig||"") + "_" + dISO;
    const raw = localStorage.getItem(k);
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && parsed.dateISO === dISO) return parsed;
    }
    const m = ensureMatrix(profile);
    if(!m || !m.days) return null;
    const idx = m.days.findIndex(x=>x.dateISO===dISO);
    const day = (idx>=0) ? m.days[idx] : (m.days[0] || null);
    if(day) localStorage.setItem(k, JSON.stringify(day));
    return day;
  }catch(e){ return null; }
}

function emitML(name, detail){
  try{ window.dispatchEvent(new CustomEvent(name, { detail: detail||{} })); }catch(e){}
}
function ensureMatrix(profile){
  const examId = profile.mainExamId;
  let m = loadMatrixForExam(examId);
  // Se n√£o existe OU se start mudou, regen
  if(!m || m.startISO !== String(profile.startDateISO).slice(0,10) || normalizeExamKey(examId) !== m.examKey || m.perfSig !== getPerfSignature()){
    m = generateMatrixPlan(profile);
    saveMatrixForExam(examId, m);
  try{ window.dispatchEvent(new CustomEvent("ML:MATRIX_REGEN", { detail: { examId: examId, startISO: m.startISO, perfSig: m.perfSig || "" } })); }catch(e){}
    }
  return m;
}

function mountMatrix(){
  const container = document.getElementById("app");
  const p = loadProfile();
  if(!p || !isProfileComplete(p)){
    container.innerHTML = `<div style="padding:20px" class="card">Complete seu Perfil (Nome + Concurso + Data de in√≠cio) para gerar a Matriz.</div>`;
    return;
  }

  const matrix = ensureMatrix(p);

  // Dia atual
  const todayKey = fmtDateISO(new Date());
  const todayIdx = matrix.days.findIndex(x=>x.dateISO === todayKey);
  const day = (todayIdx >= 0) ? matrix.days[todayIdx] : matrix.days[0];

  // Relat√≥rio resumido
  const totalHours = (p.studyHoursPerDay || 6) * matrix.days.length;
  const dsRows = matrix.disciplines.map(d=>{
    const pct = Math.round((d.weightNorm||0)*100);
    return `<tr>
      <td>${escapeHtml(d.name)}</td>
      <td style="text-align:right">${pct}%</td>
      <td>${escapeHtml(d.adjReason||"base")}</td>
    </tr>`;
  }).join("");

  // Lista dos pr√≥ximos 14 dias
  const nextDays = matrix.days.slice(Math.max(0, todayIdx), Math.max(0, todayIdx)+14);
  const nextHtml = nextDays.map(x=>`
    <div class="card" style="margin-bottom:10px">
      <div class="section-title">
        <div><b>${escapeHtml(x.weekday)}</b> ‚Äî ${escapeHtml(x.dateISO)}</div>
        <span class="pill">${escapeHtml(x.blocks[0].phase)}</span>
      </div>
      <div style="margin-top:8px">
        <div><b>Bloco 1:</b> ${escapeHtml(x.blocks[0].disc)} ‚Äî ${escapeHtml(x.blocks[0].topic)}</div>
        <div><b>Bloco 2:</b> ${escapeHtml(x.blocks[1].disc)} ‚Äî ${escapeHtml(x.blocks[1].topic)}</div>
      </div>
    </div>
  `).join("");

  container.innerHTML = `
    <div class="card">
      <div class="section-title">
        <div>
          <h2 style="margin:0">üìö Matriz Curricular ‚Äî ${escapeHtml(matrix.examName)}</h2>
          <div class="note">Modelo C h√≠brido: corte hist√≥rico (refer√™ncia) + estrutura do edital (base) + calibra√ß√£o por desempenho (quando houver dados).</div>
        </div>
        <span class="pill">${escapeHtml(matrix.horizonMonths)} meses</span>
      </div>

      <div class="row">
        <div>
          <label>In√≠cio</label>
          <div class="pill">${escapeHtml(matrix.startISO)}</div>
        </div>
        <div>
          <label>Fim (proje√ß√£o)</label>
          <div class="pill">${escapeHtml(matrix.endISO)}</div>
        </div>
        <div>
          <label>Horas/dia</label>
          <div class="pill">${escapeHtml(String(p.studyHoursPerDay||6))}</div>
        </div>
        <div>
          <label>Total horas (estimado)</label>
          <div class="pill">${escapeHtml(String(totalHours))}</div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div class="card" style="box-shadow:none;border:1px solid #e5e7eb;">
          <b>Fases</b><br>
          <div class="note">Fundamentos ‚Üí Constru√ß√£o ‚Üí Consolida√ß√£o ‚Üí Revis√£o intensiva</div>
          <div style="margin-top:8px">
            <div>Fundamentos: at√© <b>${escapeHtml(matrix.phases.fundamentos.endISO)}</b></div>
            <div>Constru√ß√£o: at√© <b>${escapeHtml(matrix.phases.construcao.endISO)}</b></div>
            <div>Consolida√ß√£o: at√© <b>${escapeHtml(matrix.phases.consolidacao.endISO)}</b></div>
            <div>Revis√£o: at√© <b>${escapeHtml(matrix.phases.revisao.endISO)}</b></div>
          </div>
        </div>

        <div class="card" style="box-shadow:none;border:1px solid #e5e7eb;">
          <b>Hoje / pr√≥ximo dia da Matriz</b><br>
          <div class="note">O Cronograma puxa as revis√µes (Bloco 0) e voc√™ executa os 2 blocos principais.</div>
          <div style="margin-top:8px">
            <div><b>${escapeHtml(day.weekday)}</b> ‚Äî ${escapeHtml(day.dateISO)}</div>
            <div style="margin-top:6px"><b>Bloco 1:</b> ${escapeHtml(day.blocks[0].disc)} ‚Äî ${escapeHtml(day.blocks[0].topic)}</div>
            <div><b>Bloco 2:</b> ${escapeHtml(day.blocks[1].disc)} ‚Äî ${escapeHtml(day.blocks[1].topic)}</div>
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <div class="section-title">
        <div><b>Distribui√ß√£o por disciplina (base + ajuste)</b></div>
        <span class="pill">calibr√°vel</span>
      </div>

      <div style="overflow:auto">
        <table class="table">
          <thead>
            <tr><th>Disciplina</th><th style="text-align:right">Peso</th><th>Motivo</th></tr>
          </thead>
          <tbody>${dsRows}</tbody>
        </table>
      </div>

      <div class="hr"></div>

      <div class="section-title">
        <div><b>Pr√≥ximos 14 dias (2 disciplinas/dia)</b></div>
        <span class="pill">autom√°tico</span>
      </div>

      ${nextHtml}

      <div class="btnbar" style="margin-top:10px">
        <button class="btn" id="regenMatrixBtn">Regerar (recalcular)</button>
        <button class="btn" id="exportMatrixBtn">Exportar relat√≥rio</button>
      </div>
    </div>
  `;

  const regen = document.getElementById("regenMatrixBtn");
  if(regen){
    regen.onclick = ()=>{
      const m2 = generateMatrixPlan(p);
      saveMatrixForExam(p.mainExamId, m2);
      try{ window.dispatchEvent(new CustomEvent("ML:MATRIX_REGEN", { detail: { examId: p.mainExamId, startISO: m2.startISO, perfSig: m2.perfSig || "" } })); }catch(e){}
      toast("Matriz recalculada ‚úì");
      mountMatrix();
    };
  }
  const exp = document.getElementById("exportMatrixBtn");
  if(exp){
    exp.onclick = ()=>{
      try{
        const blob = new Blob([JSON.stringify(matrix, null, 2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "matriz_" + matrix.examKey + "_" + matrix.startISO + ".json";
        a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      }catch(e){
        alert("N√£o foi poss√≠vel exportar.");
      }
    };
  }
}
</script>

</body>
</html>
